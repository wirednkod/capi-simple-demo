/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@deno/shim-deno-test/dist/definitions.js":
/*!***************************************************************!*\
  !*** ./node_modules/@deno/shim-deno-test/dist/definitions.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.testDefinitions = void 0;
/** Reference to the array that `Deno.test` calls insert their definition into. */
exports.testDefinitions = [];


/***/ }),

/***/ "./node_modules/@deno/shim-deno-test/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@deno/shim-deno-test/dist/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.testDefinitions = exports.Deno = void 0;
exports.Deno = __webpack_require__(/*! ./test.js */ "./node_modules/@deno/shim-deno-test/dist/test.js");
__exportStar(__webpack_require__(/*! ./test.js */ "./node_modules/@deno/shim-deno-test/dist/test.js"), exports);
var definitions_js_1 = __webpack_require__(/*! ./definitions.js */ "./node_modules/@deno/shim-deno-test/dist/definitions.js");
Object.defineProperty(exports, "testDefinitions", ({ enumerable: true, get: function () { return definitions_js_1.testDefinitions; } }));


/***/ }),

/***/ "./node_modules/@deno/shim-deno-test/dist/test.js":
/*!********************************************************!*\
  !*** ./node_modules/@deno/shim-deno-test/dist/test.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.test = void 0;
const definitions_js_1 = __webpack_require__(/*! ./definitions.js */ "./node_modules/@deno/shim-deno-test/dist/definitions.js");
const test = function test() {
    var _a, _b;
    let testDef;
    const firstArg = arguments[0];
    const secondArg = arguments[1];
    const thirdArg = arguments[2];
    if (typeof firstArg === "string") {
        if (typeof secondArg === "object") {
            if (typeof thirdArg === "function") {
                if (secondArg.fn != null) {
                    throw new TypeError("Unexpected 'fn' field in options, test function is already provided as the third argument.");
                }
            }
            if (secondArg.name != null) {
                throw new TypeError("Unexpected 'name' field in options, test name is already provided as the first argument.");
            }
            // name, options, fn
            testDef = { name: firstArg, fn: thirdArg, ...secondArg };
        }
        else {
            // name, fn
            testDef = { name: firstArg, fn: secondArg };
        }
    }
    else if (firstArg instanceof Function) {
        // function only
        if (firstArg.name.length === 0) {
            throw new TypeError("The test function must have a name");
        }
        testDef = { fn: firstArg, name: firstArg.name };
        if (secondArg != null) {
            throw new TypeError("Unexpected second argument to Deno.test()");
        }
    }
    else if (typeof firstArg === "object") {
        testDef = { ...firstArg };
        if (typeof secondArg === "function") {
            // options, fn
            testDef.fn = secondArg;
            if (firstArg.fn != null) {
                throw new TypeError("Unexpected 'fn' field in options, test function is already provided as the second argument.");
            }
            if (testDef.name == null) {
                if (secondArg.name.length === 0) {
                    throw new TypeError("The test function must have a name");
                }
                // options without name, fn
                testDef.name = secondArg.name;
            }
        }
        else {
            if (typeof firstArg.fn !== "function") {
                throw new TypeError("Expected 'fn' field in the first argument to be a test function.");
            }
        }
    }
    else {
        throw new TypeError("Unknown test overload");
    }
    if (typeof testDef.fn !== "function") {
        throw new TypeError("Missing test function");
    }
    if (((_b = (_a = testDef.name) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) === 0) {
        throw new TypeError("The test name can't be empty");
    }
    definitions_js_1.testDefinitions.push(testDef);
};
exports.test = test;


/***/ }),

/***/ "./node_modules/capi/node_modules/tslib/tslib.es6.js":
/*!***********************************************************!*\
  !*** ./node_modules/capi/node_modules/tslib/tslib.es6.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "__assign": function() { return /* binding */ __assign; },
/* harmony export */   "__asyncDelegator": function() { return /* binding */ __asyncDelegator; },
/* harmony export */   "__asyncGenerator": function() { return /* binding */ __asyncGenerator; },
/* harmony export */   "__asyncValues": function() { return /* binding */ __asyncValues; },
/* harmony export */   "__await": function() { return /* binding */ __await; },
/* harmony export */   "__awaiter": function() { return /* binding */ __awaiter; },
/* harmony export */   "__classPrivateFieldGet": function() { return /* binding */ __classPrivateFieldGet; },
/* harmony export */   "__classPrivateFieldSet": function() { return /* binding */ __classPrivateFieldSet; },
/* harmony export */   "__createBinding": function() { return /* binding */ __createBinding; },
/* harmony export */   "__decorate": function() { return /* binding */ __decorate; },
/* harmony export */   "__exportStar": function() { return /* binding */ __exportStar; },
/* harmony export */   "__extends": function() { return /* binding */ __extends; },
/* harmony export */   "__generator": function() { return /* binding */ __generator; },
/* harmony export */   "__importDefault": function() { return /* binding */ __importDefault; },
/* harmony export */   "__importStar": function() { return /* binding */ __importStar; },
/* harmony export */   "__makeTemplateObject": function() { return /* binding */ __makeTemplateObject; },
/* harmony export */   "__metadata": function() { return /* binding */ __metadata; },
/* harmony export */   "__param": function() { return /* binding */ __param; },
/* harmony export */   "__read": function() { return /* binding */ __read; },
/* harmony export */   "__rest": function() { return /* binding */ __rest; },
/* harmony export */   "__spread": function() { return /* binding */ __spread; },
/* harmony export */   "__spreadArray": function() { return /* binding */ __spreadArray; },
/* harmony export */   "__spreadArrays": function() { return /* binding */ __spreadArrays; },
/* harmony export */   "__values": function() { return /* binding */ __values; }
/* harmony export */ });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

function __exportStar(m, o) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

/** @deprecated */
function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/** @deprecated */
function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}


/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/***/ (function(module) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  define(Gp, "constructor", GeneratorFunctionPrototype);
  define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  });
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  define(Gp, iteratorSymbol, function() {
    return this;
  });

  define(Gp, "toString", function() {
    return "[object Generator]";
  });

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : 0
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, in modern engines
  // we can explicitly access globalThis. In older engines we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");
/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./view */ "./src/view.ts");
/* harmony import */ var capi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! capi */ "./node_modules/capi/esm/mod.js");
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/no-unsafe-call */
/* eslint-disable @typescript-eslint/no-floating-promises */
/* eslint-disable @typescript-eslint/restrict-template-expressions */



window.onload = () => {
    const loadTime = performance.now();
    const ui = new _view__WEBPACK_IMPORTED_MODULE_1__["default"]({ containerId: "messages" }, { loadTime });
    ui.showSyncing();
    void (async () => {
        try {
            const { block: { block } } = await capi__WEBPACK_IMPORTED_MODULE_2__.readBlock(capi__WEBPACK_IMPORTED_MODULE_2__.westend).run();
            ui.showSynced();
            ui.log(`${_view__WEBPACK_IMPORTED_MODULE_1__.emojis.seedling} Chain is ready (powered by CAPI) - Reading at block #${parseInt(block.header.number, 0)}`, true);
            const chainName = await capi__WEBPACK_IMPORTED_MODULE_2__.rpcCall(capi__WEBPACK_IMPORTED_MODULE_2__.westend, "system_chain", []).select("result").run();
            const health = await capi__WEBPACK_IMPORTED_MODULE_2__.rpcCall(capi__WEBPACK_IMPORTED_MODULE_2__.westend, "system_health", []).select("result").run();
            const genesisHash = await capi__WEBPACK_IMPORTED_MODULE_2__.rpcCall(capi__WEBPACK_IMPORTED_MODULE_2__.westend, "chain_getBlockHash", [0]).select("result").run();
            ui.log(`${_view__WEBPACK_IMPORTED_MODULE_1__.emojis.info} Connected to ${chainName} with ${health.peers} peers.`);
            ui.log(`${_view__WEBPACK_IMPORTED_MODULE_1__.emojis.chequeredFlag} Genesis hash is ${genesisHash}`);
            ui.log(`${_view__WEBPACK_IMPORTED_MODULE_1__.emojis.newspaper} Subscribing to new block headers`);
            const rpc = capi__WEBPACK_IMPORTED_MODULE_2__.rpcSubscription(capi__WEBPACK_IMPORTED_MODULE_2__.westend, "chain_subscribeNewHead", [], () => (m) => ui.log(`${_view__WEBPACK_IMPORTED_MODULE_1__.emojis.brick} New block #${parseInt(m.params.result.number, 0)} has hash ${m.params.result.parentHash}`));
            await capi__WEBPACK_IMPORTED_MODULE_2__.run(rpc);
        }
        catch (error) {
            ui.error(error);
        }
    })();
};


/***/ }),

/***/ "./src/view.ts":
/*!*********************!*\
  !*** ./src/view.ts ***!
  \*********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ UI; },
/* harmony export */   "emojis": function() { return /* binding */ emojis; }
/* harmony export */ });
const emojis = {
    banknote: "ðŸ’µ",
    brick: "ðŸ§±",
    chain: "ðŸ”—",
    chequeredFlag: "ðŸ",
    clock: "ðŸ•’",
    info: "â„¹ï¸",
    newspaper: "ðŸ—žï¸",
    seedling: "ðŸŒ±",
    stethoscope: "ðŸ©º",
    tick: "âœ…",
};
class UI {
    options;
    model;
    container;
    syncState;
    syncMessage;
    constructor(options, model) {
        this.options = options;
        this.model = model;
        const container = document.getElementById(this.options.containerId);
        if (container === null) {
            throw Error("Could not find the container. Did you change the Html?");
        }
        this.container = container;
    }
    timeElapsed = (from, till) => {
        return ((till - from) / 1000).toFixed(2);
    };
    timestampHtml = (withTime) => {
        const timestampDiv = document.createElement("time");
        if (!withTime) {
            return timestampDiv;
        }
        const time = performance.now();
        timestampDiv.appendChild(document.createTextNode(`${new Date().toLocaleTimeString()} (${this.timeElapsed(this.model.loadTime, time)}s)`));
        return timestampDiv;
    };
    messageHtml = (message, withTime) => {
        const messageDiv = document.createElement("div");
        messageDiv.classList.add("message");
        messageDiv.appendChild(this.timestampHtml(withTime));
        messageDiv.appendChild(document.createTextNode(message));
        return messageDiv;
    };
    errorHtml = (message) => {
        const messageDiv = document.createElement("div");
        messageDiv.classList.add("message");
        messageDiv.classList.add("error");
        messageDiv.appendChild(document.createTextNode(message));
        return messageDiv;
    };
    displayMessage = (message) => {
        this.container.appendChild(message);
    };
    error = (error) => {
        this.displayMessage(this.errorHtml(error.message));
        throw error;
    };
    log = (message, withTime) => {
        this.displayMessage(this.messageHtml(message, withTime));
    };
    insertAtTopOfContainer = (el) => {
        if (this.container.firstChild == null) {
            this.container.appendChild(el);
        }
        else {
            this.container.insertBefore(el, this.container.firstChild);
        }
    };
    ensureClassOn = (el, className) => {
        if (!el.classList.contains(className)) {
            el.classList.add(className);
        }
    };
    showSyncing = () => {
        if (!this.syncMessage) {
            // message container
            const syncState = document.createElement("div");
            syncState.classList.add("message");
            //contents - empty timestamp and pulsing message
            syncState.appendChild(this.timestampHtml());
            const syncMessage = document.createElement("em");
            syncMessage.classList.add("pulse");
            syncMessage.innerHTML = `${emojis.chain} Chain is syncing...`;
            syncState.appendChild(syncMessage);
            this.syncMessage = syncMessage;
            this.syncState = syncState;
            this.insertAtTopOfContainer(this.syncState);
        }
        else {
            // Cover case that we change from synced state back to syncing.
            this.syncMessage.innerHTML = `${emojis.chain} Chain is syncing...`;
            this.ensureClassOn(this.syncMessage, "pulse");
        }
    };
    showSynced = () => {
        if (!this.syncState || !this.syncMessage) {
            throw new Error("There is no sync state UI to update. You should have called `showSyncing()` first.");
        }
        this.syncMessage.classList.remove("pulse");
        this.syncMessage.innerHTML = `${emojis.tick} Chain synced!`;
    };
}


/***/ }),

/***/ "./node_modules/@noble/hashes/esm/_assert.js":
/*!***************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_assert.js ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bool": function() { return /* binding */ bool; },
/* harmony export */   "bytes": function() { return /* binding */ bytes; },
/* harmony export */   "exists": function() { return /* binding */ exists; },
/* harmony export */   "hash": function() { return /* binding */ hash; },
/* harmony export */   "number": function() { return /* binding */ number; },
/* harmony export */   "output": function() { return /* binding */ output; }
/* harmony export */ });
function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
}
function bool(b) {
    if (typeof b !== 'boolean')
        throw new Error(`Expected boolean, not ${b}`);
}
function bytes(b, ...lengths) {
    if (!(b instanceof Uint8Array))
        throw new TypeError('Expected Uint8Array');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function hash(hash) {
    if (typeof hash !== 'function' || typeof hash.create !== 'function')
        throw new Error('Hash should be wrapped by utils.wrapConstructor');
    number(hash.outputLen);
    number(hash.blockLen);
}
function exists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
}
const assert = {
    number,
    bool,
    bytes,
    hash,
    exists,
    output,
};
/* harmony default export */ __webpack_exports__["default"] = (assert);


/***/ }),

/***/ "./node_modules/@noble/hashes/esm/_blake2.js":
/*!***************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_blake2.js ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BLAKE2": function() { return /* binding */ BLAKE2; },
/* harmony export */   "SIGMA": function() { return /* binding */ SIGMA; }
/* harmony export */ });
/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ "./node_modules/@noble/hashes/esm/_assert.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@noble/hashes/esm/utils.js");


// prettier-ignore
const SIGMA = new Uint8Array([
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,
    11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,
    7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,
    9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,
    2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,
    12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11,
    13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10,
    6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5,
    10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0,
    // For BLAKE2b, the two extra permutations for rounds 10 and 11 are SIGMA[10..11] = SIGMA[0..1].
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,
]);
class BLAKE2 extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {
    constructor(blockLen, outputLen, opts = {}, keyLen, saltLen, persLen) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.length = 0;
        this.pos = 0;
        this.finished = false;
        this.destroyed = false;
        _assert_js__WEBPACK_IMPORTED_MODULE_0__["default"].number(blockLen);
        _assert_js__WEBPACK_IMPORTED_MODULE_0__["default"].number(outputLen);
        _assert_js__WEBPACK_IMPORTED_MODULE_0__["default"].number(keyLen);
        if (outputLen < 0 || outputLen > keyLen)
            throw new Error('Blake2: outputLen bigger than keyLen');
        if (opts.key !== undefined && (opts.key.length < 1 || opts.key.length > keyLen))
            throw new Error(`Key should be up 1..${keyLen} byte long or undefined`);
        if (opts.salt !== undefined && opts.salt.length !== saltLen)
            throw new Error(`Salt should be ${saltLen} byte long or undefined`);
        if (opts.personalization !== undefined && opts.personalization.length !== persLen)
            throw new Error(`Personalization should be ${persLen} byte long or undefined`);
        this.buffer32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)((this.buffer = new Uint8Array(blockLen)));
    }
    update(data) {
        _assert_js__WEBPACK_IMPORTED_MODULE_0__["default"].exists(this);
        // Main difference with other hashes: there is flag for last block,
        // so we cannot process current block before we know that there
        // is the next one. This significantly complicates logic and reduces ability
        // to do zero-copy processing
        const { blockLen, buffer, buffer32 } = this;
        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            // If buffer is full and we still have input (don't process last block, same as blake2s)
            if (this.pos === blockLen) {
                this.compress(buffer32, 0, false);
                this.pos = 0;
            }
            const take = Math.min(blockLen - this.pos, len - pos);
            const dataOffset = data.byteOffset + pos;
            // full block && aligned to 4 bytes && not last in input
            if (take === blockLen && !(dataOffset % 4) && pos + take < len) {
                const data32 = new Uint32Array(data.buffer, dataOffset, Math.floor((len - pos) / 4));
                for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {
                    this.length += blockLen;
                    this.compress(data32, pos32, false);
                }
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            this.length += take;
            pos += take;
        }
        return this;
    }
    digestInto(out) {
        _assert_js__WEBPACK_IMPORTED_MODULE_0__["default"].exists(this);
        _assert_js__WEBPACK_IMPORTED_MODULE_0__["default"].output(out, this);
        const { pos, buffer32 } = this;
        this.finished = true;
        // Padding
        this.buffer.subarray(pos).fill(0);
        this.compress(buffer32, 0, true);
        const out32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(out);
        this.get().forEach((v, i) => (out32[i] = v));
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        const { buffer, length, finished, destroyed, outputLen, pos } = this;
        to || (to = new this.constructor({ dkLen: outputLen }));
        to.set(...this.get());
        to.length = length;
        to.finished = finished;
        to.destroyed = destroyed;
        to.outputLen = outputLen;
        to.buffer.set(buffer);
        to.pos = pos;
        return to;
    }
}


/***/ }),

/***/ "./node_modules/@noble/hashes/esm/_u64.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_u64.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "add": function() { return /* binding */ add; },
/* harmony export */   "fromBig": function() { return /* binding */ fromBig; },
/* harmony export */   "split": function() { return /* binding */ split; },
/* harmony export */   "toBig": function() { return /* binding */ toBig; }
/* harmony export */ });
const U32_MASK64 = BigInt(2 ** 32 - 1);
const _32n = BigInt(32);
// We are not using BigUint64Array, because they are extremely slow as per 2022
function fromBig(n, le = false) {
    if (le)
        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
}
const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
// for Shift in [0, 32)
const shrSH = (h, l, s) => h >>> s;
const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (h, l) => l;
const rotr32L = (h, l) => h;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
// Removing "export" has 5% perf penalty -_-
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
}
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
// prettier-ignore
const u64 = {
    fromBig, split, toBig,
    shrSH, shrSL,
    rotrSH, rotrSL, rotrBH, rotrBL,
    rotr32H, rotr32L,
    rotlSH, rotlSL, rotlBH, rotlBL,
    add, add3L, add3H, add4L, add4H, add5H, add5L,
};
/* harmony default export */ __webpack_exports__["default"] = (u64);


/***/ }),

/***/ "./node_modules/@noble/hashes/esm/blake2b.js":
/*!***************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/blake2b.js ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "blake2b": function() { return /* binding */ blake2b; }
/* harmony export */ });
/* harmony import */ var _blake2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_blake2.js */ "./node_modules/@noble/hashes/esm/_blake2.js");
/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_u64.js */ "./node_modules/@noble/hashes/esm/_u64.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@noble/hashes/esm/utils.js");



// Same as SHA-512 but LE
// prettier-ignore
const IV = new Uint32Array([
    0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85, 0xfe94f82b, 0x3c6ef372, 0x5f1d36f1, 0xa54ff53a,
    0xade682d1, 0x510e527f, 0x2b3e6c1f, 0x9b05688c, 0xfb41bd6b, 0x1f83d9ab, 0x137e2179, 0x5be0cd19
]);
// Temporary buffer
const BUF = new Uint32Array(32);
// Mixing function G splitted in two halfs
function G1(a, b, c, d, msg, x) {
    // NOTE: V is LE here
    const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore
    let Al = BUF[2 * a], Ah = BUF[2 * a + 1]; // prettier-ignore
    let Bl = BUF[2 * b], Bh = BUF[2 * b + 1]; // prettier-ignore
    let Cl = BUF[2 * c], Ch = BUF[2 * c + 1]; // prettier-ignore
    let Dl = BUF[2 * d], Dh = BUF[2 * d + 1]; // prettier-ignore
    // v[a] = (v[a] + v[b] + x) | 0;
    let ll = _u64_js__WEBPACK_IMPORTED_MODULE_1__["default"].add3L(Al, Bl, Xl);
    Ah = _u64_js__WEBPACK_IMPORTED_MODULE_1__["default"].add3H(ll, Ah, Bh, Xh);
    Al = ll | 0;
    // v[d] = rotr(v[d] ^ v[a], 32)
    ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
    ({ Dh, Dl } = { Dh: _u64_js__WEBPACK_IMPORTED_MODULE_1__["default"].rotr32H(Dh, Dl), Dl: _u64_js__WEBPACK_IMPORTED_MODULE_1__["default"].rotr32L(Dh, Dl) });
    // v[c] = (v[c] + v[d]) | 0;
    ({ h: Ch, l: Cl } = _u64_js__WEBPACK_IMPORTED_MODULE_1__["default"].add(Ch, Cl, Dh, Dl));
    // v[b] = rotr(v[b] ^ v[c], 24)
    ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
    ({ Bh, Bl } = { Bh: _u64_js__WEBPACK_IMPORTED_MODULE_1__["default"].rotrSH(Bh, Bl, 24), Bl: _u64_js__WEBPACK_IMPORTED_MODULE_1__["default"].rotrSL(Bh, Bl, 24) });
    (BUF[2 * a] = Al), (BUF[2 * a + 1] = Ah);
    (BUF[2 * b] = Bl), (BUF[2 * b + 1] = Bh);
    (BUF[2 * c] = Cl), (BUF[2 * c + 1] = Ch);
    (BUF[2 * d] = Dl), (BUF[2 * d + 1] = Dh);
}
function G2(a, b, c, d, msg, x) {
    // NOTE: V is LE here
    const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore
    let Al = BUF[2 * a], Ah = BUF[2 * a + 1]; // prettier-ignore
    let Bl = BUF[2 * b], Bh = BUF[2 * b + 1]; // prettier-ignore
    let Cl = BUF[2 * c], Ch = BUF[2 * c + 1]; // prettier-ignore
    let Dl = BUF[2 * d], Dh = BUF[2 * d + 1]; // prettier-ignore
    // v[a] = (v[a] + v[b] + x) | 0;
    let ll = _u64_js__WEBPACK_IMPORTED_MODULE_1__["default"].add3L(Al, Bl, Xl);
    Ah = _u64_js__WEBPACK_IMPORTED_MODULE_1__["default"].add3H(ll, Ah, Bh, Xh);
    Al = ll | 0;
    // v[d] = rotr(v[d] ^ v[a], 16)
    ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
    ({ Dh, Dl } = { Dh: _u64_js__WEBPACK_IMPORTED_MODULE_1__["default"].rotrSH(Dh, Dl, 16), Dl: _u64_js__WEBPACK_IMPORTED_MODULE_1__["default"].rotrSL(Dh, Dl, 16) });
    // v[c] = (v[c] + v[d]) | 0;
    ({ h: Ch, l: Cl } = _u64_js__WEBPACK_IMPORTED_MODULE_1__["default"].add(Ch, Cl, Dh, Dl));
    // v[b] = rotr(v[b] ^ v[c], 63)
    ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
    ({ Bh, Bl } = { Bh: _u64_js__WEBPACK_IMPORTED_MODULE_1__["default"].rotrBH(Bh, Bl, 63), Bl: _u64_js__WEBPACK_IMPORTED_MODULE_1__["default"].rotrBL(Bh, Bl, 63) });
    (BUF[2 * a] = Al), (BUF[2 * a + 1] = Ah);
    (BUF[2 * b] = Bl), (BUF[2 * b + 1] = Bh);
    (BUF[2 * c] = Cl), (BUF[2 * c + 1] = Ch);
    (BUF[2 * d] = Dl), (BUF[2 * d + 1] = Dh);
}
class BLAKE2b extends _blake2_js__WEBPACK_IMPORTED_MODULE_0__.BLAKE2 {
    constructor(opts = {}) {
        super(128, opts.dkLen === undefined ? 64 : opts.dkLen, opts, 64, 16, 16);
        // Same as SHA-512, but LE
        this.v0l = IV[0] | 0;
        this.v0h = IV[1] | 0;
        this.v1l = IV[2] | 0;
        this.v1h = IV[3] | 0;
        this.v2l = IV[4] | 0;
        this.v2h = IV[5] | 0;
        this.v3l = IV[6] | 0;
        this.v3h = IV[7] | 0;
        this.v4l = IV[8] | 0;
        this.v4h = IV[9] | 0;
        this.v5l = IV[10] | 0;
        this.v5h = IV[11] | 0;
        this.v6l = IV[12] | 0;
        this.v6h = IV[13] | 0;
        this.v7l = IV[14] | 0;
        this.v7h = IV[15] | 0;
        const keyLength = opts.key ? opts.key.length : 0;
        this.v0l ^= this.outputLen | (keyLength << 8) | (0x01 << 16) | (0x01 << 24);
        if (opts.salt) {
            const salt = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.u32)((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.toBytes)(opts.salt));
            this.v4l ^= salt[0];
            this.v4h ^= salt[1];
            this.v5l ^= salt[2];
            this.v5h ^= salt[3];
        }
        if (opts.personalization) {
            const pers = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.u32)((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.toBytes)(opts.personalization));
            this.v6l ^= pers[0];
            this.v6h ^= pers[1];
            this.v7l ^= pers[2];
            this.v7h ^= pers[3];
        }
        if (opts.key) {
            // Pad to blockLen and update
            const tmp = new Uint8Array(this.blockLen);
            tmp.set((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.toBytes)(opts.key));
            this.update(tmp);
        }
    }
    // prettier-ignore
    get() {
        let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;
        return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];
    }
    // prettier-ignore
    set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {
        this.v0l = v0l | 0;
        this.v0h = v0h | 0;
        this.v1l = v1l | 0;
        this.v1h = v1h | 0;
        this.v2l = v2l | 0;
        this.v2h = v2h | 0;
        this.v3l = v3l | 0;
        this.v3h = v3h | 0;
        this.v4l = v4l | 0;
        this.v4h = v4h | 0;
        this.v5l = v5l | 0;
        this.v5h = v5h | 0;
        this.v6l = v6l | 0;
        this.v6h = v6h | 0;
        this.v7l = v7l | 0;
        this.v7h = v7h | 0;
    }
    compress(msg, offset, isLast) {
        this.get().forEach((v, i) => (BUF[i] = v)); // First half from state.
        BUF.set(IV, 16); // Second half from IV.
        let { h, l } = _u64_js__WEBPACK_IMPORTED_MODULE_1__["default"].fromBig(BigInt(this.length));
        BUF[24] = IV[8] ^ l; // Low word of the offset.
        BUF[25] = IV[9] ^ h; // High word.
        // Invert all bits for last block
        if (isLast) {
            BUF[28] = ~BUF[28];
            BUF[29] = ~BUF[29];
        }
        let j = 0;
        const s = _blake2_js__WEBPACK_IMPORTED_MODULE_0__.SIGMA;
        for (let i = 0; i < 12; i++) {
            G1(0, 4, 8, 12, msg, offset + 2 * s[j++]);
            G2(0, 4, 8, 12, msg, offset + 2 * s[j++]);
            G1(1, 5, 9, 13, msg, offset + 2 * s[j++]);
            G2(1, 5, 9, 13, msg, offset + 2 * s[j++]);
            G1(2, 6, 10, 14, msg, offset + 2 * s[j++]);
            G2(2, 6, 10, 14, msg, offset + 2 * s[j++]);
            G1(3, 7, 11, 15, msg, offset + 2 * s[j++]);
            G2(3, 7, 11, 15, msg, offset + 2 * s[j++]);
            G1(0, 5, 10, 15, msg, offset + 2 * s[j++]);
            G2(0, 5, 10, 15, msg, offset + 2 * s[j++]);
            G1(1, 6, 11, 12, msg, offset + 2 * s[j++]);
            G2(1, 6, 11, 12, msg, offset + 2 * s[j++]);
            G1(2, 7, 8, 13, msg, offset + 2 * s[j++]);
            G2(2, 7, 8, 13, msg, offset + 2 * s[j++]);
            G1(3, 4, 9, 14, msg, offset + 2 * s[j++]);
            G2(3, 4, 9, 14, msg, offset + 2 * s[j++]);
        }
        this.v0l ^= BUF[0] ^ BUF[16];
        this.v0h ^= BUF[1] ^ BUF[17];
        this.v1l ^= BUF[2] ^ BUF[18];
        this.v1h ^= BUF[3] ^ BUF[19];
        this.v2l ^= BUF[4] ^ BUF[20];
        this.v2h ^= BUF[5] ^ BUF[21];
        this.v3l ^= BUF[6] ^ BUF[22];
        this.v3h ^= BUF[7] ^ BUF[23];
        this.v4l ^= BUF[8] ^ BUF[24];
        this.v4h ^= BUF[9] ^ BUF[25];
        this.v5l ^= BUF[10] ^ BUF[26];
        this.v5h ^= BUF[11] ^ BUF[27];
        this.v6l ^= BUF[12] ^ BUF[28];
        this.v6h ^= BUF[13] ^ BUF[29];
        this.v7l ^= BUF[14] ^ BUF[30];
        this.v7h ^= BUF[15] ^ BUF[31];
        BUF.fill(0);
    }
    destroy() {
        this.destroyed = true;
        this.buffer32.fill(0);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}
/**
 * BLAKE2b - optimized for 64-bit platforms. JS doesn't have uint64, so it's slower than BLAKE2s.
 * @param msg - message that would be hashed
 * @param opts - dkLen, key, salt, personalization
 */
const blake2b = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructorWithOpts)((opts) => new BLAKE2b(opts));


/***/ }),

/***/ "./node_modules/@noble/hashes/esm/cryptoBrowser.js":
/*!*********************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/cryptoBrowser.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "crypto": function() { return /* binding */ crypto; }
/* harmony export */ });
const crypto = {
    node: undefined,
    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,
};


/***/ }),

/***/ "./node_modules/@noble/hashes/esm/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/utils.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Hash": function() { return /* binding */ Hash; },
/* harmony export */   "asyncLoop": function() { return /* binding */ asyncLoop; },
/* harmony export */   "bytesToHex": function() { return /* binding */ bytesToHex; },
/* harmony export */   "checkOpts": function() { return /* binding */ checkOpts; },
/* harmony export */   "concatBytes": function() { return /* binding */ concatBytes; },
/* harmony export */   "createView": function() { return /* binding */ createView; },
/* harmony export */   "hexToBytes": function() { return /* binding */ hexToBytes; },
/* harmony export */   "isLE": function() { return /* binding */ isLE; },
/* harmony export */   "nextTick": function() { return /* binding */ nextTick; },
/* harmony export */   "randomBytes": function() { return /* binding */ randomBytes; },
/* harmony export */   "rotr": function() { return /* binding */ rotr; },
/* harmony export */   "toBytes": function() { return /* binding */ toBytes; },
/* harmony export */   "u32": function() { return /* binding */ u32; },
/* harmony export */   "u8": function() { return /* binding */ u8; },
/* harmony export */   "utf8ToBytes": function() { return /* binding */ utf8ToBytes; },
/* harmony export */   "wrapConstructor": function() { return /* binding */ wrapConstructor; },
/* harmony export */   "wrapConstructorWithOpts": function() { return /* binding */ wrapConstructorWithOpts; }
/* harmony export */ });
/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ "./node_modules/@noble/hashes/esm/cryptoBrowser.js");
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// The import here is via the package name. This is to ensure
// that exports mapping/resolution does fall into place.

// Cast array to different type
const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
// Cast array to view
const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
// The rotate right (circular right shift) operation for uint32
const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
// There is almost no big endian hardware, but js typed arrays uses platform specific endianness.
// So, just to be sure not to corrupt anything.
if (!isLE)
    throw new Error('Non little-endian hardware is not supported');
const hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));
/**
 * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]))
 */
function bytesToHex(uint8a) {
    // pre-caching improves the speed 6x
    if (!(uint8a instanceof Uint8Array))
        throw new Error('Uint8Array expected');
    let hex = '';
    for (let i = 0; i < uint8a.length; i++) {
        hex += hexes[uint8a[i]];
    }
    return hex;
}
/**
 * @example hexToBytes('deadbeef')
 */
function hexToBytes(hex) {
    if (typeof hex !== 'string') {
        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);
    }
    if (hex.length % 2)
        throw new Error('hexToBytes: received invalid unpadded hex');
    const array = new Uint8Array(hex.length / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
            throw new Error('Invalid byte sequence');
        array[i] = byte;
    }
    return array;
}
// There is no setImmediate in browser and setTimeout is slow. However, call to async function will return Promise
// which will be fullfiled only on next scheduler queue processing step and this is exactly what we need.
const nextTick = async () => { };
// Returns control to thread each 'tick' ms to avoid blocking
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0; i < iters; i++) {
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
            continue;
        await nextTick();
        ts += diff;
    }
}
function utf8ToBytes(str) {
    if (typeof str !== 'string') {
        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
    }
    return new TextEncoder().encode(str);
}
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    if (!(data instanceof Uint8Array))
        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
    return data;
}
/**
 * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`
 * @example concatBytes(buf1, buf2)
 */
function concatBytes(...arrays) {
    if (!arrays.every((a) => a instanceof Uint8Array))
        throw new Error('Uint8Array list expected');
    if (arrays.length === 1)
        return arrays[0];
    const length = arrays.reduce((a, arr) => a + arr.length, 0);
    const result = new Uint8Array(length);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
    }
    return result;
}
// For runtime check if class implements interface
class Hash {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
// Check if object doens't have custom constructor (like Uint8Array/Array)
const isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;
function checkOpts(defaults, opts) {
    if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))
        throw new TypeError('Options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
function wrapConstructor(hashConstructor) {
    const hashC = (message) => hashConstructor().update(toBytes(message)).digest();
    const tmp = hashConstructor();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashConstructor();
    return hashC;
}
function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
/**
 * Secure PRNG
 */
function randomBytes(bytesLength = 32) {
    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.web) {
        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.web.getRandomValues(new Uint8Array(bytesLength));
    }
    else if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.node) {
        return new Uint8Array(_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.node.randomBytes(bytesLength).buffer);
    }
    else {
        throw new Error("The environment doesn't have randomBytes function");
    }
}


/***/ }),

/***/ "./node_modules/capi/esm/_dnt.shims.js":
/*!*********************************************!*\
  !*** ./node_modules/capi/esm/_dnt.shims.js ***!
  \*********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Deno": function() { return /* reexport safe */ _deno_shim_deno_test__WEBPACK_IMPORTED_MODULE_0__.Deno; },
/* harmony export */   "dntGlobalThis": function() { return /* binding */ dntGlobalThis; }
/* harmony export */ });
/* harmony import */ var _deno_shim_deno_test__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @deno/shim-deno-test */ "./node_modules/@deno/shim-deno-test/dist/index.js");


const dntGlobals = {
    Deno: _deno_shim_deno_test__WEBPACK_IMPORTED_MODULE_0__.Deno,
};
const dntGlobalThis = createMergeProxy(globalThis, dntGlobals);
// deno-lint-ignore ban-types
function createMergeProxy(baseObj, extObj) {
    return new Proxy(baseObj, {
        get(_target, prop, _receiver) {
            if (prop in extObj) {
                return extObj[prop];
            }
            else {
                return baseObj[prop];
            }
        },
        set(_target, prop, value) {
            if (prop in extObj) {
                delete extObj[prop];
            }
            baseObj[prop] = value;
            return true;
        },
        deleteProperty(_target, prop) {
            let success = false;
            if (prop in extObj) {
                delete extObj[prop];
                success = true;
            }
            if (prop in baseObj) {
                delete baseObj[prop];
                success = true;
            }
            return success;
        },
        ownKeys(_target) {
            const baseKeys = Reflect.ownKeys(baseObj);
            const extKeys = Reflect.ownKeys(extObj);
            const extKeysSet = new Set(extKeys);
            return [...baseKeys.filter((k) => !extKeysSet.has(k)), ...extKeys];
        },
        defineProperty(_target, prop, desc) {
            if (prop in extObj) {
                delete extObj[prop];
            }
            Reflect.defineProperty(baseObj, prop, desc);
            return true;
        },
        getOwnPropertyDescriptor(_target, prop) {
            if (prop in extObj) {
                return Reflect.getOwnPropertyDescriptor(extObj, prop);
            }
            else {
                return Reflect.getOwnPropertyDescriptor(baseObj, prop);
            }
        },
        has(_target, prop) {
            return prop in extObj || prop in baseObj;
        },
    });
}
//# sourceMappingURL=_dnt.shims.js.map

/***/ }),

/***/ "./node_modules/capi/esm/config/mod.js":
/*!*********************************************!*\
  !*** ./node_modules/capi/esm/config/mod.js ***!
  \*********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Config": function() { return /* binding */ Config; }
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/capi/node_modules/tslib/tslib.es6.js");
var _Config_discoveryValue;

class Config {
    constructor(initDiscoveryValue, addressPrefix) {
        Object.defineProperty(this, "initDiscoveryValue", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: initDiscoveryValue
        });
        Object.defineProperty(this, "addressPrefix", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: addressPrefix
        });
        // TODO: get rid of this gunk
        Object.defineProperty(this, "RpcMethods", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "RpcCallMethods", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "RpcSubscriptionMethods", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "RpcErrorDetails", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        _Config_discoveryValue.set(this, void 0);
    }
    get discoveryValue() {
        if (!(0,tslib__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _Config_discoveryValue, "f")) {
            (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _Config_discoveryValue, this.initDiscoveryValue(), "f");
        }
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _Config_discoveryValue, "f");
    }
}
_Config_discoveryValue = new WeakMap();
//# sourceMappingURL=mod.js.map

/***/ }),

/***/ "./node_modules/capi/esm/deps/blake2b.js":
/*!***********************************************!*\
  !*** ./node_modules/capi/esm/deps/blake2b.js ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "blake2b": function() { return /* reexport safe */ _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_0__.blake2b; }
/* harmony export */ });
/* harmony import */ var _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/blake2b */ "./node_modules/@noble/hashes/esm/blake2b.js");

//# sourceMappingURL=blake2b.js.map

/***/ }),

/***/ "./node_modules/capi/esm/deps/scale.js":
/*!*********************************************!*\
  !*** ./node_modules/capi/esm/deps/scale.js ***!
  \*********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BitSequence": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.BitSequence; },
/* harmony export */   "CodecError": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.CodecError; },
/* harmony export */   "CodecVisitor": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.CodecVisitor; },
/* harmony export */   "Context": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.Context; },
/* harmony export */   "DecodeBuffer": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.DecodeBuffer; },
/* harmony export */   "DecodeError": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.DecodeError; },
/* harmony export */   "EncodeBuffer": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.EncodeBuffer; },
/* harmony export */   "EncodeError": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.EncodeError; },
/* harmony export */   "array": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.array; },
/* harmony export */   "bitSequence": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.bitSequence; },
/* harmony export */   "bool": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.bool; },
/* harmony export */   "compactU128": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.compactU128; },
/* harmony export */   "compactU16": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.compactU16; },
/* harmony export */   "compactU256": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.compactU256; },
/* harmony export */   "compactU32": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.compactU32; },
/* harmony export */   "compactU64": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.compactU64; },
/* harmony export */   "compactU8": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.compactU8; },
/* harmony export */   "constantPattern": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.constantPattern; },
/* harmony export */   "createAsyncCodec": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.createAsyncCodec; },
/* harmony export */   "createCodec": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.createCodec; },
/* harmony export */   "deferred": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.deferred; },
/* harmony export */   "dummy": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.dummy; },
/* harmony export */   "i128": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.i128; },
/* harmony export */   "i16": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.i16; },
/* harmony export */   "i256": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.i256; },
/* harmony export */   "i32": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.i32; },
/* harmony export */   "i64": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.i64; },
/* harmony export */   "i8": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.i8; },
/* harmony export */   "instance": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.instance; },
/* harmony export */   "int": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.int; },
/* harmony export */   "iterable": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.iterable; },
/* harmony export */   "lenPrefixed": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.lenPrefixed; },
/* harmony export */   "map": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.map; },
/* harmony export */   "never": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.never; },
/* harmony export */   "object": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.object; },
/* harmony export */   "option": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.option; },
/* harmony export */   "optionBool": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.optionBool; },
/* harmony export */   "promise": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.promise; },
/* harmony export */   "result": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.result; },
/* harmony export */   "set": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.set; },
/* harmony export */   "sizedArray": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.sizedArray; },
/* harmony export */   "sizedUint8Array": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.sizedUint8Array; },
/* harmony export */   "sizedUint8array": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.sizedUint8array; },
/* harmony export */   "spread": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.spread; },
/* harmony export */   "str": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.str; },
/* harmony export */   "stringUnion": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.stringUnion; },
/* harmony export */   "taggedUnion": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.taggedUnion; },
/* harmony export */   "transform": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.transform; },
/* harmony export */   "tuple": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.tuple; },
/* harmony export */   "u128": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.u128; },
/* harmony export */   "u16": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.u16; },
/* harmony export */   "u256": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.u256; },
/* harmony export */   "u32": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.u32; },
/* harmony export */   "u64": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.u64; },
/* harmony export */   "u8": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.u8; },
/* harmony export */   "uint8Array": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.uint8Array; },
/* harmony export */   "uint8array": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.uint8array; },
/* harmony export */   "union": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.union; },
/* harmony export */   "withMetadata": function() { return /* reexport safe */ parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__.withMetadata; }
/* harmony export */ });
/* harmony import */ var parity_scale_codec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! parity-scale-codec */ "./node_modules/parity-scale-codec/esm/mod.js");

//# sourceMappingURL=scale.js.map

/***/ }),

/***/ "./node_modules/capi/esm/deps/std/async.js":
/*!*************************************************!*\
  !*** ./node_modules/capi/esm/deps/std/async.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DeadlineError": function() { return /* reexport safe */ _deps_2_deno_land_std_0_127_0_async_mod_js__WEBPACK_IMPORTED_MODULE_0__.DeadlineError; },
/* harmony export */   "MuxAsyncIterator": function() { return /* reexport safe */ _deps_2_deno_land_std_0_127_0_async_mod_js__WEBPACK_IMPORTED_MODULE_0__.MuxAsyncIterator; },
/* harmony export */   "deadline": function() { return /* reexport safe */ _deps_2_deno_land_std_0_127_0_async_mod_js__WEBPACK_IMPORTED_MODULE_0__.deadline; },
/* harmony export */   "debounce": function() { return /* reexport safe */ _deps_2_deno_land_std_0_127_0_async_mod_js__WEBPACK_IMPORTED_MODULE_0__.debounce; },
/* harmony export */   "deferred": function() { return /* reexport safe */ _deps_2_deno_land_std_0_127_0_async_mod_js__WEBPACK_IMPORTED_MODULE_0__.deferred; },
/* harmony export */   "delay": function() { return /* reexport safe */ _deps_2_deno_land_std_0_127_0_async_mod_js__WEBPACK_IMPORTED_MODULE_0__.delay; },
/* harmony export */   "pooledMap": function() { return /* reexport safe */ _deps_2_deno_land_std_0_127_0_async_mod_js__WEBPACK_IMPORTED_MODULE_0__.pooledMap; },
/* harmony export */   "tee": function() { return /* reexport safe */ _deps_2_deno_land_std_0_127_0_async_mod_js__WEBPACK_IMPORTED_MODULE_0__.tee; }
/* harmony export */ });
/* harmony import */ var _deps_2_deno_land_std_0_127_0_async_mod_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../deps_2/deno.land/std@0.127.0/async/mod.js */ "./node_modules/capi/esm/deps_2/deno.land/std@0.127.0/async/mod.js");

//# sourceMappingURL=async.js.map

/***/ }),

/***/ "./node_modules/capi/esm/deps/std/encoding/base58.js":
/*!***********************************************************!*\
  !*** ./node_modules/capi/esm/deps/std/encoding/base58.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "decode": function() { return /* reexport safe */ _deps_2_deno_land_std_0_154_0_encoding_base58_js__WEBPACK_IMPORTED_MODULE_0__.decode; },
/* harmony export */   "encode": function() { return /* reexport safe */ _deps_2_deno_land_std_0_154_0_encoding_base58_js__WEBPACK_IMPORTED_MODULE_0__.encode; }
/* harmony export */ });
/* harmony import */ var _deps_2_deno_land_std_0_154_0_encoding_base58_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../deps_2/deno.land/std@0.154.0/encoding/base58.js */ "./node_modules/capi/esm/deps_2/deno.land/std@0.154.0/encoding/base58.js");

//# sourceMappingURL=base58.js.map

/***/ }),

/***/ "./node_modules/capi/esm/deps/std/encoding/hex.js":
/*!********************************************************!*\
  !*** ./node_modules/capi/esm/deps/std/encoding/hex.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "decode": function() { return /* reexport safe */ _deps_2_deno_land_std_0_127_0_encoding_hex_js__WEBPACK_IMPORTED_MODULE_0__.decode; },
/* harmony export */   "encode": function() { return /* reexport safe */ _deps_2_deno_land_std_0_127_0_encoding_hex_js__WEBPACK_IMPORTED_MODULE_0__.encode; }
/* harmony export */ });
/* harmony import */ var _deps_2_deno_land_std_0_127_0_encoding_hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../deps_2/deno.land/std@0.127.0/encoding/hex.js */ "./node_modules/capi/esm/deps_2/deno.land/std@0.127.0/encoding/hex.js");

//# sourceMappingURL=hex.js.map

/***/ }),

/***/ "./node_modules/capi/esm/deps/std/testing/asserts.js":
/*!***********************************************************!*\
  !*** ./node_modules/capi/esm/deps/std/testing/asserts.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AssertionError": function() { return /* reexport safe */ _deps_2_deno_land_std_0_158_0_testing_asserts_js__WEBPACK_IMPORTED_MODULE_0__.AssertionError; },
/* harmony export */   "assert": function() { return /* reexport safe */ _deps_2_deno_land_std_0_158_0_testing_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert; },
/* harmony export */   "assertAlmostEquals": function() { return /* reexport safe */ _deps_2_deno_land_std_0_158_0_testing_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assertAlmostEquals; },
/* harmony export */   "assertArrayIncludes": function() { return /* reexport safe */ _deps_2_deno_land_std_0_158_0_testing_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assertArrayIncludes; },
/* harmony export */   "assertEquals": function() { return /* reexport safe */ _deps_2_deno_land_std_0_158_0_testing_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assertEquals; },
/* harmony export */   "assertExists": function() { return /* reexport safe */ _deps_2_deno_land_std_0_158_0_testing_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assertExists; },
/* harmony export */   "assertFalse": function() { return /* reexport safe */ _deps_2_deno_land_std_0_158_0_testing_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assertFalse; },
/* harmony export */   "assertInstanceOf": function() { return /* reexport safe */ _deps_2_deno_land_std_0_158_0_testing_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assertInstanceOf; },
/* harmony export */   "assertIsError": function() { return /* reexport safe */ _deps_2_deno_land_std_0_158_0_testing_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assertIsError; },
/* harmony export */   "assertMatch": function() { return /* reexport safe */ _deps_2_deno_land_std_0_158_0_testing_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assertMatch; },
/* harmony export */   "assertNotEquals": function() { return /* reexport safe */ _deps_2_deno_land_std_0_158_0_testing_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assertNotEquals; },
/* harmony export */   "assertNotInstanceOf": function() { return /* reexport safe */ _deps_2_deno_land_std_0_158_0_testing_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assertNotInstanceOf; },
/* harmony export */   "assertNotMatch": function() { return /* reexport safe */ _deps_2_deno_land_std_0_158_0_testing_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assertNotMatch; },
/* harmony export */   "assertNotStrictEquals": function() { return /* reexport safe */ _deps_2_deno_land_std_0_158_0_testing_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assertNotStrictEquals; },
/* harmony export */   "assertObjectMatch": function() { return /* reexport safe */ _deps_2_deno_land_std_0_158_0_testing_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assertObjectMatch; },
/* harmony export */   "assertRejects": function() { return /* reexport safe */ _deps_2_deno_land_std_0_158_0_testing_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assertRejects; },
/* harmony export */   "assertStrictEquals": function() { return /* reexport safe */ _deps_2_deno_land_std_0_158_0_testing_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assertStrictEquals; },
/* harmony export */   "assertStringIncludes": function() { return /* reexport safe */ _deps_2_deno_land_std_0_158_0_testing_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assertStringIncludes; },
/* harmony export */   "assertThrows": function() { return /* reexport safe */ _deps_2_deno_land_std_0_158_0_testing_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assertThrows; },
/* harmony export */   "equal": function() { return /* reexport safe */ _deps_2_deno_land_std_0_158_0_testing_asserts_js__WEBPACK_IMPORTED_MODULE_0__.equal; },
/* harmony export */   "fail": function() { return /* reexport safe */ _deps_2_deno_land_std_0_158_0_testing_asserts_js__WEBPACK_IMPORTED_MODULE_0__.fail; },
/* harmony export */   "unimplemented": function() { return /* reexport safe */ _deps_2_deno_land_std_0_158_0_testing_asserts_js__WEBPACK_IMPORTED_MODULE_0__.unimplemented; },
/* harmony export */   "unreachable": function() { return /* reexport safe */ _deps_2_deno_land_std_0_158_0_testing_asserts_js__WEBPACK_IMPORTED_MODULE_0__.unreachable; }
/* harmony export */ });
/* harmony import */ var _deps_2_deno_land_std_0_158_0_testing_asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../deps_2/deno.land/std@0.158.0/testing/asserts.js */ "./node_modules/capi/esm/deps_2/deno.land/std@0.158.0/testing/asserts.js");

//# sourceMappingURL=asserts.js.map

/***/ }),

/***/ "./node_modules/capi/esm/deps_2/deno.land/std@0.127.0/async/deadline.js":
/*!******************************************************************************!*\
  !*** ./node_modules/capi/esm/deps_2/deno.land/std@0.127.0/async/deadline.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DeadlineError": function() { return /* binding */ DeadlineError; },
/* harmony export */   "deadline": function() { return /* binding */ deadline; }
/* harmony export */ });
/* harmony import */ var _deferred_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./deferred.js */ "./node_modules/capi/esm/deps_2/deno.land/std@0.127.0/async/deferred.js");
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.

class DeadlineError extends Error {
    constructor() {
        super("Deadline");
        this.name = "DeadlineError";
    }
}
/**
 * Create a promise which will be rejected with DeadlineError when a given delay is exceeded.
 */
function deadline(p, delay) {
    const d = (0,_deferred_js__WEBPACK_IMPORTED_MODULE_0__.deferred)();
    const t = setTimeout(() => d.reject(new DeadlineError()), delay);
    return Promise.race([p, d]).finally(() => clearTimeout(t));
}
//# sourceMappingURL=deadline.js.map

/***/ }),

/***/ "./node_modules/capi/esm/deps_2/deno.land/std@0.127.0/async/debounce.js":
/*!******************************************************************************!*\
  !*** ./node_modules/capi/esm/deps_2/deno.land/std@0.127.0/async/debounce.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "debounce": function() { return /* binding */ debounce; }
/* harmony export */ });
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
/**
 * Creates a debounced function that delays the given `func`
 * by a given `wait` time in milliseconds. If the method is called
 * again before the timeout expires, the previous call will be
 * aborted.
 *
 * ```
 * import { debounce } from "./debounce.ts";
 *
 * const log = debounce(
 *   (event: Deno.FsEvent) =>
 *     console.log("[%s] %s", event.kind, event.paths[0]),
 *   200,
 * );
 *
 * for await (const event of Deno.watchFs("./")) {
 *   log(event);
 * }
 * ```
 *
 * @param fn    The function to debounce.
 * @param wait  The time in milliseconds to delay the function.
 */
// deno-lint-ignore no-explicit-any
function debounce(fn, wait) {
    let timeout = null;
    let flush = null;
    const debounced = ((...args) => {
        debounced.clear();
        flush = () => {
            debounced.clear();
            fn.call(debounced, ...args);
        };
        timeout = setTimeout(flush, wait);
    });
    debounced.clear = () => {
        if (typeof timeout === "number") {
            clearTimeout(timeout);
            timeout = null;
            flush = null;
        }
    };
    debounced.flush = () => {
        flush?.();
    };
    Object.defineProperty(debounced, "pending", {
        get: () => typeof timeout === "number",
    });
    return debounced;
}
//# sourceMappingURL=debounce.js.map

/***/ }),

/***/ "./node_modules/capi/esm/deps_2/deno.land/std@0.127.0/async/deferred.js":
/*!******************************************************************************!*\
  !*** ./node_modules/capi/esm/deps_2/deno.land/std@0.127.0/async/deferred.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "deferred": function() { return /* binding */ deferred; }
/* harmony export */ });
/** Creates a Promise with the `reject` and `resolve` functions
 * placed as methods on the promise object itself. It allows you to do:
 *
 * ```ts
 *     import { deferred } from "./deferred.ts";
 *
 *     const p = deferred<number>();
 *     // ...
 *     p.resolve(42);
 * ```
 */
function deferred() {
    let methods;
    let state = "pending";
    const promise = new Promise((resolve, reject) => {
        methods = {
            async resolve(value) {
                await value;
                state = "fulfilled";
                resolve(value);
            },
            // deno-lint-ignore no-explicit-any
            reject(reason) {
                state = "rejected";
                reject(reason);
            },
        };
    });
    Object.defineProperty(promise, "state", { get: () => state });
    return Object.assign(promise, methods);
}
//# sourceMappingURL=deferred.js.map

/***/ }),

/***/ "./node_modules/capi/esm/deps_2/deno.land/std@0.127.0/async/delay.js":
/*!***************************************************************************!*\
  !*** ./node_modules/capi/esm/deps_2/deno.land/std@0.127.0/async/delay.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "delay": function() { return /* binding */ delay; }
/* harmony export */ });
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
/* Resolves after the given number of milliseconds. */
function delay(ms, options = {}) {
    const { signal } = options;
    if (signal?.aborted) {
        return Promise.reject(new DOMException("Delay was aborted.", "AbortError"));
    }
    return new Promise((resolve, reject) => {
        const abort = () => {
            clearTimeout(i);
            reject(new DOMException("Delay was aborted.", "AbortError"));
        };
        const done = () => {
            signal?.removeEventListener("abort", abort);
            resolve();
        };
        const i = setTimeout(done, ms);
        signal?.addEventListener("abort", abort, { once: true });
    });
}
//# sourceMappingURL=delay.js.map

/***/ }),

/***/ "./node_modules/capi/esm/deps_2/deno.land/std@0.127.0/async/mod.js":
/*!*************************************************************************!*\
  !*** ./node_modules/capi/esm/deps_2/deno.land/std@0.127.0/async/mod.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DeadlineError": function() { return /* reexport safe */ _deadline_js__WEBPACK_IMPORTED_MODULE_6__.DeadlineError; },
/* harmony export */   "MuxAsyncIterator": function() { return /* reexport safe */ _mux_async_iterator_js__WEBPACK_IMPORTED_MODULE_3__.MuxAsyncIterator; },
/* harmony export */   "deadline": function() { return /* reexport safe */ _deadline_js__WEBPACK_IMPORTED_MODULE_6__.deadline; },
/* harmony export */   "debounce": function() { return /* reexport safe */ _debounce_js__WEBPACK_IMPORTED_MODULE_0__.debounce; },
/* harmony export */   "deferred": function() { return /* reexport safe */ _deferred_js__WEBPACK_IMPORTED_MODULE_1__.deferred; },
/* harmony export */   "delay": function() { return /* reexport safe */ _delay_js__WEBPACK_IMPORTED_MODULE_2__.delay; },
/* harmony export */   "pooledMap": function() { return /* reexport safe */ _pool_js__WEBPACK_IMPORTED_MODULE_4__.pooledMap; },
/* harmony export */   "tee": function() { return /* reexport safe */ _tee_js__WEBPACK_IMPORTED_MODULE_5__.tee; }
/* harmony export */ });
/* harmony import */ var _debounce_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./debounce.js */ "./node_modules/capi/esm/deps_2/deno.land/std@0.127.0/async/debounce.js");
/* harmony import */ var _deferred_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./deferred.js */ "./node_modules/capi/esm/deps_2/deno.land/std@0.127.0/async/deferred.js");
/* harmony import */ var _delay_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./delay.js */ "./node_modules/capi/esm/deps_2/deno.land/std@0.127.0/async/delay.js");
/* harmony import */ var _mux_async_iterator_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mux_async_iterator.js */ "./node_modules/capi/esm/deps_2/deno.land/std@0.127.0/async/mux_async_iterator.js");
/* harmony import */ var _pool_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./pool.js */ "./node_modules/capi/esm/deps_2/deno.land/std@0.127.0/async/pool.js");
/* harmony import */ var _tee_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tee.js */ "./node_modules/capi/esm/deps_2/deno.land/std@0.127.0/async/tee.js");
/* harmony import */ var _deadline_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./deadline.js */ "./node_modules/capi/esm/deps_2/deno.land/std@0.127.0/async/deadline.js");
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.







//# sourceMappingURL=mod.js.map

/***/ }),

/***/ "./node_modules/capi/esm/deps_2/deno.land/std@0.127.0/async/mux_async_iterator.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/capi/esm/deps_2/deno.land/std@0.127.0/async/mux_async_iterator.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MuxAsyncIterator": function() { return /* binding */ MuxAsyncIterator; }
/* harmony export */ });
/* harmony import */ var _deferred_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./deferred.js */ "./node_modules/capi/esm/deps_2/deno.land/std@0.127.0/async/deferred.js");
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.

/** The MuxAsyncIterator class multiplexes multiple async iterators into a
 * single stream. It currently makes an assumption:
 * - The final result (the value returned and not yielded from the iterator)
 *   does not matter; if there is any, it is discarded.
 */
class MuxAsyncIterator {
    constructor() {
        Object.defineProperty(this, "iteratorCount", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "yields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        // deno-lint-ignore no-explicit-any
        Object.defineProperty(this, "throws", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "signal", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (0,_deferred_js__WEBPACK_IMPORTED_MODULE_0__.deferred)()
        });
    }
    add(iterable) {
        ++this.iteratorCount;
        this.callIteratorNext(iterable[Symbol.asyncIterator]());
    }
    async callIteratorNext(iterator) {
        try {
            const { value, done } = await iterator.next();
            if (done) {
                --this.iteratorCount;
            }
            else {
                this.yields.push({ iterator, value });
            }
        }
        catch (e) {
            this.throws.push(e);
        }
        this.signal.resolve();
    }
    async *iterate() {
        while (this.iteratorCount > 0) {
            // Sleep until any of the wrapped iterators yields.
            await this.signal;
            // Note that while we're looping over `yields`, new items may be added.
            for (let i = 0; i < this.yields.length; i++) {
                const { iterator, value } = this.yields[i];
                yield value;
                this.callIteratorNext(iterator);
            }
            if (this.throws.length) {
                for (const e of this.throws) {
                    throw e;
                }
                this.throws.length = 0;
            }
            // Clear the `yields` list and reset the `signal` promise.
            this.yields.length = 0;
            this.signal = (0,_deferred_js__WEBPACK_IMPORTED_MODULE_0__.deferred)();
        }
    }
    [Symbol.asyncIterator]() {
        return this.iterate();
    }
}
//# sourceMappingURL=mux_async_iterator.js.map

/***/ }),

/***/ "./node_modules/capi/esm/deps_2/deno.land/std@0.127.0/async/pool.js":
/*!**************************************************************************!*\
  !*** ./node_modules/capi/esm/deps_2/deno.land/std@0.127.0/async/pool.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pooledMap": function() { return /* binding */ pooledMap; }
/* harmony export */ });
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
/**
 * pooledMap transforms values from an (async) iterable into another async
 * iterable. The transforms are done concurrently, with a max concurrency
 * defined by the poolLimit.
 *
 * If an error is thrown from `iterableFn`, no new transformations will begin.
 * All currently executing transformations are allowed to finish and still
 * yielded on success. After that, the rejections among them are gathered and
 * thrown by the iterator in an `AggregateError`.
 *
 * @param poolLimit The maximum count of items being processed concurrently.
 * @param array The input array for mapping.
 * @param iteratorFn The function to call for every item of the array.
 */
function pooledMap(poolLimit, array, iteratorFn) {
    // Create the async iterable that is returned from this function.
    const res = new TransformStream({
        async transform(p, controller) {
            controller.enqueue(await p);
        },
    });
    // Start processing items from the iterator
    (async () => {
        const writer = res.writable.getWriter();
        const executing = [];
        try {
            for await (const item of array) {
                const p = Promise.resolve().then(() => iteratorFn(item));
                // Only write on success. If we `writer.write()` a rejected promise,
                // that will end the iteration. We don't want that yet. Instead let it
                // fail the race, taking us to the catch block where all currently
                // executing jobs are allowed to finish and all rejections among them
                // can be reported together.
                p.then((v) => writer.write(Promise.resolve(v))).catch(() => { });
                const e = p.then(() => executing.splice(executing.indexOf(e), 1));
                executing.push(e);
                if (executing.length >= poolLimit) {
                    await Promise.race(executing);
                }
            }
            // Wait until all ongoing events have processed, then close the writer.
            await Promise.all(executing);
            writer.close();
        }
        catch {
            const errors = [];
            for (const result of await Promise.allSettled(executing)) {
                if (result.status == "rejected") {
                    errors.push(result.reason);
                }
            }
            writer.write(Promise.reject(new AggregateError(errors, "Threw while mapping."))).catch(() => { });
        }
    })();
    return res.readable[Symbol.asyncIterator]();
}
//# sourceMappingURL=pool.js.map

/***/ }),

/***/ "./node_modules/capi/esm/deps_2/deno.land/std@0.127.0/async/tee.js":
/*!*************************************************************************!*\
  !*** ./node_modules/capi/esm/deps_2/deno.land/std@0.127.0/async/tee.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "tee": function() { return /* binding */ tee; }
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/capi/node_modules/tslib/tslib.es6.js");
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
var _Queue_source, _Queue_queue;

class Queue {
    constructor(iterable) {
        _Queue_source.set(this, void 0);
        _Queue_queue.set(this, void 0);
        Object.defineProperty(this, "head", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "done", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _Queue_source, iterable[Symbol.asyncIterator](), "f");
        (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _Queue_queue, {
            value: undefined,
            next: undefined,
        }, "f");
        this.head = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _Queue_queue, "f");
        this.done = false;
    }
    async next() {
        const result = await (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _Queue_source, "f").next();
        if (!result.done) {
            const nextNode = {
                value: result.value,
                next: undefined,
            };
            (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _Queue_queue, "f").next = nextNode;
            (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _Queue_queue, nextNode, "f");
        }
        else {
            this.done = true;
        }
    }
}
_Queue_source = new WeakMap(), _Queue_queue = new WeakMap();
/**
 * Branches the given async iterable into the n branches.
 *
 * Example:
 *
 * ```ts
 *     import { tee } from "./tee.ts";
 *
 *     const gen = async function* gen() {
 *       yield 1;
 *       yield 2;
 *       yield 3;
 *     }
 *
 *     const [branch1, branch2] = tee(gen());
 *
 *     (async () => {
 *       for await (const n of branch1) {
 *         console.log(n); // => 1, 2, 3
 *       }
 *     })();
 *
 *     (async () => {
 *       for await (const n of branch2) {
 *         console.log(n); // => 1, 2, 3
 *       }
 *     })();
 * ```
 */
function tee(iterable, n = 2) {
    const queue = new Queue(iterable);
    async function* generator() {
        let buffer = queue.head;
        while (true) {
            if (buffer.next) {
                buffer = buffer.next;
                yield buffer.value;
            }
            else if (queue.done) {
                return;
            }
            else {
                await queue.next();
            }
        }
    }
    const branches = Array.from({ length: n }).map(() => generator());
    return branches;
}
//# sourceMappingURL=tee.js.map

/***/ }),

/***/ "./node_modules/capi/esm/deps_2/deno.land/std@0.127.0/encoding/hex.js":
/*!****************************************************************************!*\
  !*** ./node_modules/capi/esm/deps_2/deno.land/std@0.127.0/encoding/hex.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "decode": function() { return /* binding */ decode; },
/* harmony export */   "encode": function() { return /* binding */ encode; }
/* harmony export */ });
// Ported from Go
// https://github.com/golang/go/blob/go1.12.5/src/encoding/hex/hex.go
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
const hexTable = new TextEncoder().encode("0123456789abcdef");
function errInvalidByte(byte) {
    return new TypeError(`Invalid byte '${String.fromCharCode(byte)}'`);
}
function errLength() {
    return new RangeError("Odd length hex string");
}
/** Converts a hex character into its value. */
function fromHexChar(byte) {
    // '0' <= byte && byte <= '9'
    if (48 <= byte && byte <= 57)
        return byte - 48;
    // 'a' <= byte && byte <= 'f'
    if (97 <= byte && byte <= 102)
        return byte - 97 + 10;
    // 'A' <= byte && byte <= 'F'
    if (65 <= byte && byte <= 70)
        return byte - 65 + 10;
    throw errInvalidByte(byte);
}
/** Encodes `src` into `src.length * 2` bytes. */
function encode(src) {
    const dst = new Uint8Array(src.length * 2);
    for (let i = 0; i < dst.length; i++) {
        const v = src[i];
        dst[i * 2] = hexTable[v >> 4];
        dst[i * 2 + 1] = hexTable[v & 0x0f];
    }
    return dst;
}
/**
 * Decodes `src` into `src.length / 2` bytes.
 * If the input is malformed, an error will be thrown.
 */
function decode(src) {
    const dst = new Uint8Array(src.length / 2);
    for (let i = 0; i < dst.length; i++) {
        const a = fromHexChar(src[i * 2]);
        const b = fromHexChar(src[i * 2 + 1]);
        dst[i] = (a << 4) | b;
    }
    if (src.length % 2 == 1) {
        // Check for invalid char before reporting bad length,
        // since the invalid char (if present) is an earlier problem.
        fromHexChar(src[dst.length * 2]);
        throw errLength();
    }
    return dst;
}
//# sourceMappingURL=hex.js.map

/***/ }),

/***/ "./node_modules/capi/esm/deps_2/deno.land/std@0.154.0/encoding/base58.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/capi/esm/deps_2/deno.land/std@0.154.0/encoding/base58.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "decode": function() { return /* binding */ decode; },
/* harmony export */   "encode": function() { return /* binding */ encode; }
/* harmony export */ });
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// deno-fmt-ignore
const mapBase58 = {
    "1": 0, "2": 1, "3": 2, "4": 3, "5": 4, "6": 5, "7": 6, "8": 7, "9": 8, A: 9,
    B: 10, C: 11, D: 12, E: 13, F: 14, G: 15, H: 16, J: 17, K: 18, L: 19, M: 20,
    N: 21, P: 22, Q: 23, R: 24, S: 25, T: 26, U: 27, V: 28, W: 29, X: 30, Y: 31,
    Z: 32, a: 33, b: 34, c: 35, d: 36, e: 37, f: 38, g: 39, h: 40, i: 41, j: 42,
    k: 43, m: 44, n: 45, o: 46, p: 47, q: 48, r: 49, s: 50, t: 51, u: 52, v: 53,
    w: 54, x: 55, y: 56, z: 57
};
const base58alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz".split("");
/**
 * Encodes a given Uint8Array, ArrayBuffer or string into draft-mspotny-base58-03 RFC base58 representation:
 * https://tools.ietf.org/id/draft-msporny-base58-01.html#rfc.section.1
 *
 * @param {ArrayBuffer | string} data
 *
 * @returns {string} Encoded value
 */
function encode(data) {
    const uint8tData = typeof data === "string"
        ? new TextEncoder().encode(data)
        : data instanceof Uint8Array
            ? data
            : new Uint8Array(data);
    let length = 0;
    let zeroes = 0;
    // Counting leading zeroes
    let index = 0;
    while (uint8tData[index] === 0) {
        zeroes++;
        index++;
    }
    const notZeroUint8Data = uint8tData.slice(index);
    const size = Math.round((uint8tData.length * 138) / 100 + 1);
    const b58Encoding = [];
    notZeroUint8Data.forEach((byte) => {
        let i = 0;
        let carry = byte;
        for (let reverse_iterator = size - 1; (carry > 0 || i < length) && reverse_iterator !== -1; reverse_iterator--, i++) {
            carry += (b58Encoding[reverse_iterator] || 0) * 256;
            b58Encoding[reverse_iterator] = Math.round(carry % 58);
            carry = Math.floor(carry / 58);
        }
        length = i;
    });
    const strResult = Array.from({
        length: b58Encoding.length + zeroes,
    });
    if (zeroes > 0) {
        strResult.fill("1", 0, zeroes);
    }
    b58Encoding.forEach((byteValue) => strResult.push(base58alphabet[byteValue]));
    return strResult.join("");
}
/**
 * Decodes a given b58 string according to draft-mspotny-base58-03 RFC base58 representation:
 * https://tools.ietf.org/id/draft-msporny-base58-01.html#rfc.section.1
 *
 * @param {string} b58
 *
 * @returns {Uint8Array} Decoded value
 */
function decode(b58) {
    const splittedInput = b58.trim().split("");
    let length = 0;
    let ones = 0;
    // Counting leading ones
    let index = 0;
    while (splittedInput[index] === "1") {
        ones++;
        index++;
    }
    const notZeroData = splittedInput.slice(index);
    const size = Math.round((b58.length * 733) / 1000 + 1);
    const output = [];
    notZeroData.forEach((char, idx) => {
        let carry = mapBase58[char];
        let i = 0;
        if (carry === undefined) {
            throw new Error(`Invalid base58 char at index ${idx} with value ${char}`);
        }
        for (let reverse_iterator = size - 1; (carry > 0 || i < length) && reverse_iterator !== 0; --reverse_iterator, ++i) {
            carry += 58 * (output[reverse_iterator - 1] || 0);
            output[reverse_iterator - 1] = Math.round(carry % 256);
            carry = Math.floor(carry / 256);
        }
        length = i;
    });
    const validOutput = output.filter((item) => item ?? false);
    if (ones > 0) {
        const onesResult = Array.from({ length: ones }).fill(0, 0, ones);
        return new Uint8Array([...onesResult, ...validOutput]);
    }
    return new Uint8Array(validOutput);
}
//# sourceMappingURL=base58.js.map

/***/ }),

/***/ "./node_modules/capi/esm/deps_2/deno.land/std@0.158.0/fmt/colors.js":
/*!**************************************************************************!*\
  !*** ./node_modules/capi/esm/deps_2/deno.land/std@0.158.0/fmt/colors.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bgBlack": function() { return /* binding */ bgBlack; },
/* harmony export */   "bgBlue": function() { return /* binding */ bgBlue; },
/* harmony export */   "bgBrightBlack": function() { return /* binding */ bgBrightBlack; },
/* harmony export */   "bgBrightBlue": function() { return /* binding */ bgBrightBlue; },
/* harmony export */   "bgBrightCyan": function() { return /* binding */ bgBrightCyan; },
/* harmony export */   "bgBrightGreen": function() { return /* binding */ bgBrightGreen; },
/* harmony export */   "bgBrightMagenta": function() { return /* binding */ bgBrightMagenta; },
/* harmony export */   "bgBrightRed": function() { return /* binding */ bgBrightRed; },
/* harmony export */   "bgBrightWhite": function() { return /* binding */ bgBrightWhite; },
/* harmony export */   "bgBrightYellow": function() { return /* binding */ bgBrightYellow; },
/* harmony export */   "bgCyan": function() { return /* binding */ bgCyan; },
/* harmony export */   "bgGreen": function() { return /* binding */ bgGreen; },
/* harmony export */   "bgMagenta": function() { return /* binding */ bgMagenta; },
/* harmony export */   "bgRed": function() { return /* binding */ bgRed; },
/* harmony export */   "bgRgb24": function() { return /* binding */ bgRgb24; },
/* harmony export */   "bgRgb8": function() { return /* binding */ bgRgb8; },
/* harmony export */   "bgWhite": function() { return /* binding */ bgWhite; },
/* harmony export */   "bgYellow": function() { return /* binding */ bgYellow; },
/* harmony export */   "black": function() { return /* binding */ black; },
/* harmony export */   "blue": function() { return /* binding */ blue; },
/* harmony export */   "bold": function() { return /* binding */ bold; },
/* harmony export */   "brightBlack": function() { return /* binding */ brightBlack; },
/* harmony export */   "brightBlue": function() { return /* binding */ brightBlue; },
/* harmony export */   "brightCyan": function() { return /* binding */ brightCyan; },
/* harmony export */   "brightGreen": function() { return /* binding */ brightGreen; },
/* harmony export */   "brightMagenta": function() { return /* binding */ brightMagenta; },
/* harmony export */   "brightRed": function() { return /* binding */ brightRed; },
/* harmony export */   "brightWhite": function() { return /* binding */ brightWhite; },
/* harmony export */   "brightYellow": function() { return /* binding */ brightYellow; },
/* harmony export */   "cyan": function() { return /* binding */ cyan; },
/* harmony export */   "dim": function() { return /* binding */ dim; },
/* harmony export */   "getColorEnabled": function() { return /* binding */ getColorEnabled; },
/* harmony export */   "gray": function() { return /* binding */ gray; },
/* harmony export */   "green": function() { return /* binding */ green; },
/* harmony export */   "hidden": function() { return /* binding */ hidden; },
/* harmony export */   "inverse": function() { return /* binding */ inverse; },
/* harmony export */   "italic": function() { return /* binding */ italic; },
/* harmony export */   "magenta": function() { return /* binding */ magenta; },
/* harmony export */   "red": function() { return /* binding */ red; },
/* harmony export */   "reset": function() { return /* binding */ reset; },
/* harmony export */   "rgb24": function() { return /* binding */ rgb24; },
/* harmony export */   "rgb8": function() { return /* binding */ rgb8; },
/* harmony export */   "setColorEnabled": function() { return /* binding */ setColorEnabled; },
/* harmony export */   "strikethrough": function() { return /* binding */ strikethrough; },
/* harmony export */   "stripColor": function() { return /* binding */ stripColor; },
/* harmony export */   "underline": function() { return /* binding */ underline; },
/* harmony export */   "white": function() { return /* binding */ white; },
/* harmony export */   "yellow": function() { return /* binding */ yellow; }
/* harmony export */ });
/* harmony import */ var _dnt_shims_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../_dnt.shims.js */ "./node_modules/capi/esm/_dnt.shims.js");
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// A module to print ANSI terminal colors. Inspired by chalk, kleur, and colors
// on npm.
/**
 * String formatters and utilities for dealing with ANSI color codes.
 *
 * This module is browser compatible.
 *
 * ```ts
 * import { bgBlue, red, bold } from "https://deno.land/std@$STD_VERSION/fmt/colors.ts";
 * console.log(bgBlue(red(bold("Hello world!"))));
 * ```
 *
 * This module supports `NO_COLOR` environmental variable disabling any coloring
 * if `NO_COLOR` is set.
 *
 * @module
 */
// deno-lint-ignore no-explicit-any

const { Deno } = _dnt_shims_js__WEBPACK_IMPORTED_MODULE_0__.dntGlobalThis;
const noColor = typeof Deno?.noColor === "boolean"
    ? Deno.noColor
    : true;
let enabled = !noColor;
/**
 * Set changing text color to enabled or disabled
 * @param value
 */
function setColorEnabled(value) {
    if (noColor) {
        return;
    }
    enabled = value;
}
/** Get whether text color change is enabled or disabled. */
function getColorEnabled() {
    return enabled;
}
/**
 * Builds color code
 * @param open
 * @param close
 */
function code(open, close) {
    return {
        open: `\x1b[${open.join(";")}m`,
        close: `\x1b[${close}m`,
        regexp: new RegExp(`\\x1b\\[${close}m`, "g"),
    };
}
/**
 * Applies color and background based on color code and its associated text
 * @param str text to apply color settings to
 * @param code color code to apply
 */
function run(str, code) {
    return enabled
        ? `${code.open}${str.replace(code.regexp, code.open)}${code.close}`
        : str;
}
/**
 * Reset the text modified
 * @param str text to reset
 */
function reset(str) {
    return run(str, code([0], 0));
}
/**
 * Make the text bold.
 * @param str text to make bold
 */
function bold(str) {
    return run(str, code([1], 22));
}
/**
 * The text emits only a small amount of light.
 * @param str text to dim
 */
function dim(str) {
    return run(str, code([2], 22));
}
/**
 * Make the text italic.
 * @param str text to make italic
 */
function italic(str) {
    return run(str, code([3], 23));
}
/**
 * Make the text underline.
 * @param str text to underline
 */
function underline(str) {
    return run(str, code([4], 24));
}
/**
 * Invert background color and text color.
 * @param str text to invert its color
 */
function inverse(str) {
    return run(str, code([7], 27));
}
/**
 * Make the text hidden.
 * @param str text to hide
 */
function hidden(str) {
    return run(str, code([8], 28));
}
/**
 * Put horizontal line through the center of the text.
 * @param str text to strike through
 */
function strikethrough(str) {
    return run(str, code([9], 29));
}
/**
 * Set text color to black.
 * @param str text to make black
 */
function black(str) {
    return run(str, code([30], 39));
}
/**
 * Set text color to red.
 * @param str text to make red
 */
function red(str) {
    return run(str, code([31], 39));
}
/**
 * Set text color to green.
 * @param str text to make green
 */
function green(str) {
    return run(str, code([32], 39));
}
/**
 * Set text color to yellow.
 * @param str text to make yellow
 */
function yellow(str) {
    return run(str, code([33], 39));
}
/**
 * Set text color to blue.
 * @param str text to make blue
 */
function blue(str) {
    return run(str, code([34], 39));
}
/**
 * Set text color to magenta.
 * @param str text to make magenta
 */
function magenta(str) {
    return run(str, code([35], 39));
}
/**
 * Set text color to cyan.
 * @param str text to make cyan
 */
function cyan(str) {
    return run(str, code([36], 39));
}
/**
 * Set text color to white.
 * @param str text to make white
 */
function white(str) {
    return run(str, code([37], 39));
}
/**
 * Set text color to gray.
 * @param str text to make gray
 */
function gray(str) {
    return brightBlack(str);
}
/**
 * Set text color to bright black.
 * @param str text to make bright-black
 */
function brightBlack(str) {
    return run(str, code([90], 39));
}
/**
 * Set text color to bright red.
 * @param str text to make bright-red
 */
function brightRed(str) {
    return run(str, code([91], 39));
}
/**
 * Set text color to bright green.
 * @param str text to make bright-green
 */
function brightGreen(str) {
    return run(str, code([92], 39));
}
/**
 * Set text color to bright yellow.
 * @param str text to make bright-yellow
 */
function brightYellow(str) {
    return run(str, code([93], 39));
}
/**
 * Set text color to bright blue.
 * @param str text to make bright-blue
 */
function brightBlue(str) {
    return run(str, code([94], 39));
}
/**
 * Set text color to bright magenta.
 * @param str text to make bright-magenta
 */
function brightMagenta(str) {
    return run(str, code([95], 39));
}
/**
 * Set text color to bright cyan.
 * @param str text to make bright-cyan
 */
function brightCyan(str) {
    return run(str, code([96], 39));
}
/**
 * Set text color to bright white.
 * @param str text to make bright-white
 */
function brightWhite(str) {
    return run(str, code([97], 39));
}
/**
 * Set background color to black.
 * @param str text to make its background black
 */
function bgBlack(str) {
    return run(str, code([40], 49));
}
/**
 * Set background color to red.
 * @param str text to make its background red
 */
function bgRed(str) {
    return run(str, code([41], 49));
}
/**
 * Set background color to green.
 * @param str text to make its background green
 */
function bgGreen(str) {
    return run(str, code([42], 49));
}
/**
 * Set background color to yellow.
 * @param str text to make its background yellow
 */
function bgYellow(str) {
    return run(str, code([43], 49));
}
/**
 * Set background color to blue.
 * @param str text to make its background blue
 */
function bgBlue(str) {
    return run(str, code([44], 49));
}
/**
 *  Set background color to magenta.
 * @param str text to make its background magenta
 */
function bgMagenta(str) {
    return run(str, code([45], 49));
}
/**
 * Set background color to cyan.
 * @param str text to make its background cyan
 */
function bgCyan(str) {
    return run(str, code([46], 49));
}
/**
 * Set background color to white.
 * @param str text to make its background white
 */
function bgWhite(str) {
    return run(str, code([47], 49));
}
/**
 * Set background color to bright black.
 * @param str text to make its background bright-black
 */
function bgBrightBlack(str) {
    return run(str, code([100], 49));
}
/**
 * Set background color to bright red.
 * @param str text to make its background bright-red
 */
function bgBrightRed(str) {
    return run(str, code([101], 49));
}
/**
 * Set background color to bright green.
 * @param str text to make its background bright-green
 */
function bgBrightGreen(str) {
    return run(str, code([102], 49));
}
/**
 * Set background color to bright yellow.
 * @param str text to make its background bright-yellow
 */
function bgBrightYellow(str) {
    return run(str, code([103], 49));
}
/**
 * Set background color to bright blue.
 * @param str text to make its background bright-blue
 */
function bgBrightBlue(str) {
    return run(str, code([104], 49));
}
/**
 * Set background color to bright magenta.
 * @param str text to make its background bright-magenta
 */
function bgBrightMagenta(str) {
    return run(str, code([105], 49));
}
/**
 * Set background color to bright cyan.
 * @param str text to make its background bright-cyan
 */
function bgBrightCyan(str) {
    return run(str, code([106], 49));
}
/**
 * Set background color to bright white.
 * @param str text to make its background bright-white
 */
function bgBrightWhite(str) {
    return run(str, code([107], 49));
}
/* Special Color Sequences */
/**
 * Clam and truncate color codes
 * @param n
 * @param max number to truncate to
 * @param min number to truncate from
 */
function clampAndTruncate(n, max = 255, min = 0) {
    return Math.trunc(Math.max(Math.min(n, max), min));
}
/**
 * Set text color using paletted 8bit colors.
 * https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit
 * @param str text color to apply paletted 8bit colors to
 * @param color code
 */
function rgb8(str, color) {
    return run(str, code([38, 5, clampAndTruncate(color)], 39));
}
/**
 * Set background color using paletted 8bit colors.
 * https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit
 * @param str text color to apply paletted 8bit background colors to
 * @param color code
 */
function bgRgb8(str, color) {
    return run(str, code([48, 5, clampAndTruncate(color)], 49));
}
/**
 * Set text color using 24bit rgb.
 * `color` can be a number in range `0x000000` to `0xffffff` or
 * an `Rgb`.
 *
 * To produce the color magenta:
 *
 * ```ts
 *      import { rgb24 } from "./colors.ts";
 *      rgb24("foo", 0xff00ff);
 *      rgb24("foo", {r: 255, g: 0, b: 255});
 * ```
 * @param str text color to apply 24bit rgb to
 * @param color code
 */
function rgb24(str, color) {
    if (typeof color === "number") {
        return run(str, code([38, 2, (color >> 16) & 0xff, (color >> 8) & 0xff, color & 0xff], 39));
    }
    return run(str, code([
        38,
        2,
        clampAndTruncate(color.r),
        clampAndTruncate(color.g),
        clampAndTruncate(color.b),
    ], 39));
}
/**
 * Set background color using 24bit rgb.
 * `color` can be a number in range `0x000000` to `0xffffff` or
 * an `Rgb`.
 *
 * To produce the color magenta:
 *
 * ```ts
 *      import { bgRgb24 } from "./colors.ts";
 *      bgRgb24("foo", 0xff00ff);
 *      bgRgb24("foo", {r: 255, g: 0, b: 255});
 * ```
 * @param str text color to apply 24bit rgb to
 * @param color code
 */
function bgRgb24(str, color) {
    if (typeof color === "number") {
        return run(str, code([48, 2, (color >> 16) & 0xff, (color >> 8) & 0xff, color & 0xff], 49));
    }
    return run(str, code([
        48,
        2,
        clampAndTruncate(color.r),
        clampAndTruncate(color.g),
        clampAndTruncate(color.b),
    ], 49));
}
// https://github.com/chalk/ansi-regex/blob/02fa893d619d3da85411acc8fd4e2eea0e95a9d9/index.js
const ANSI_PATTERN = new RegExp([
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))",
].join("|"), "g");
/**
 * Remove ANSI escape codes from the string.
 * @param string to remove ANSI escape codes from
 */
function stripColor(string) {
    return string.replace(ANSI_PATTERN, "");
}
//# sourceMappingURL=colors.js.map

/***/ }),

/***/ "./node_modules/capi/esm/deps_2/deno.land/std@0.158.0/testing/_diff.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/capi/esm/deps_2/deno.land/std@0.158.0/testing/_diff.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DiffType": function() { return /* binding */ DiffType; },
/* harmony export */   "buildMessage": function() { return /* binding */ buildMessage; },
/* harmony export */   "diff": function() { return /* binding */ diff; },
/* harmony export */   "diffstr": function() { return /* binding */ diffstr; }
/* harmony export */ });
/* harmony import */ var _fmt_colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../fmt/colors.js */ "./node_modules/capi/esm/deps_2/deno.land/std@0.158.0/fmt/colors.js");
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.

var DiffType;
(function (DiffType) {
    DiffType["removed"] = "removed";
    DiffType["common"] = "common";
    DiffType["added"] = "added";
})(DiffType || (DiffType = {}));
const REMOVED = 1;
const COMMON = 2;
const ADDED = 3;
function createCommon(A, B, reverse) {
    const common = [];
    if (A.length === 0 || B.length === 0)
        return [];
    for (let i = 0; i < Math.min(A.length, B.length); i += 1) {
        if (A[reverse ? A.length - i - 1 : i] === B[reverse ? B.length - i - 1 : i]) {
            common.push(A[reverse ? A.length - i - 1 : i]);
        }
        else {
            return common;
        }
    }
    return common;
}
/**
 * Renders the differences between the actual and expected values
 * @param A Actual value
 * @param B Expected value
 */
function diff(A, B) {
    const prefixCommon = createCommon(A, B);
    const suffixCommon = createCommon(A.slice(prefixCommon.length), B.slice(prefixCommon.length), true).reverse();
    A = suffixCommon.length
        ? A.slice(prefixCommon.length, -suffixCommon.length)
        : A.slice(prefixCommon.length);
    B = suffixCommon.length
        ? B.slice(prefixCommon.length, -suffixCommon.length)
        : B.slice(prefixCommon.length);
    const swapped = B.length > A.length;
    [A, B] = swapped ? [B, A] : [A, B];
    const M = A.length;
    const N = B.length;
    if (!M && !N && !suffixCommon.length && !prefixCommon.length)
        return [];
    if (!N) {
        return [
            ...prefixCommon.map((c) => ({ type: DiffType.common, value: c })),
            ...A.map((a) => ({
                type: swapped ? DiffType.added : DiffType.removed,
                value: a,
            })),
            ...suffixCommon.map((c) => ({ type: DiffType.common, value: c })),
        ];
    }
    const offset = N;
    const delta = M - N;
    const size = M + N + 1;
    const fp = Array.from({ length: size }, () => ({ y: -1, id: -1 }));
    /**
     * INFO:
     * This buffer is used to save memory and improve performance.
     * The first half is used to save route and last half is used to save diff
     * type.
     * This is because, when I kept new uint8array area to save type,performance
     * worsened.
     */
    const routes = new Uint32Array((M * N + size + 1) * 2);
    const diffTypesPtrOffset = routes.length / 2;
    let ptr = 0;
    let p = -1;
    function backTrace(A, B, current, swapped) {
        const M = A.length;
        const N = B.length;
        const result = [];
        let a = M - 1;
        let b = N - 1;
        let j = routes[current.id];
        let type = routes[current.id + diffTypesPtrOffset];
        while (true) {
            if (!j && !type)
                break;
            const prev = j;
            if (type === REMOVED) {
                result.unshift({
                    type: swapped ? DiffType.removed : DiffType.added,
                    value: B[b],
                });
                b -= 1;
            }
            else if (type === ADDED) {
                result.unshift({
                    type: swapped ? DiffType.added : DiffType.removed,
                    value: A[a],
                });
                a -= 1;
            }
            else {
                result.unshift({ type: DiffType.common, value: A[a] });
                a -= 1;
                b -= 1;
            }
            j = routes[prev];
            type = routes[prev + diffTypesPtrOffset];
        }
        return result;
    }
    function createFP(slide, down, k, M) {
        if (slide && slide.y === -1 && down && down.y === -1) {
            return { y: 0, id: 0 };
        }
        if ((down && down.y === -1) ||
            k === M ||
            (slide && slide.y) > (down && down.y) + 1) {
            const prev = slide.id;
            ptr++;
            routes[ptr] = prev;
            routes[ptr + diffTypesPtrOffset] = ADDED;
            return { y: slide.y, id: ptr };
        }
        else {
            const prev = down.id;
            ptr++;
            routes[ptr] = prev;
            routes[ptr + diffTypesPtrOffset] = REMOVED;
            return { y: down.y + 1, id: ptr };
        }
    }
    function snake(k, slide, down, _offset, A, B) {
        const M = A.length;
        const N = B.length;
        if (k < -N || M < k)
            return { y: -1, id: -1 };
        const fp = createFP(slide, down, k, M);
        while (fp.y + k < M && fp.y < N && A[fp.y + k] === B[fp.y]) {
            const prev = fp.id;
            ptr++;
            fp.id = ptr;
            fp.y += 1;
            routes[ptr] = prev;
            routes[ptr + diffTypesPtrOffset] = COMMON;
        }
        return fp;
    }
    while (fp[delta + offset].y < N) {
        p = p + 1;
        for (let k = -p; k < delta; ++k) {
            fp[k + offset] = snake(k, fp[k - 1 + offset], fp[k + 1 + offset], offset, A, B);
        }
        for (let k = delta + p; k > delta; --k) {
            fp[k + offset] = snake(k, fp[k - 1 + offset], fp[k + 1 + offset], offset, A, B);
        }
        fp[delta + offset] = snake(delta, fp[delta - 1 + offset], fp[delta + 1 + offset], offset, A, B);
    }
    return [
        ...prefixCommon.map((c) => ({ type: DiffType.common, value: c })),
        ...backTrace(A, B, fp[delta + offset], swapped),
        ...suffixCommon.map((c) => ({ type: DiffType.common, value: c })),
    ];
}
/**
 * Renders the differences between the actual and expected strings
 * Partially inspired from https://github.com/kpdecker/jsdiff
 * @param A Actual string
 * @param B Expected string
 */
function diffstr(A, B) {
    function unescape(string) {
        // unescape invisible characters.
        // ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#escape_sequences
        return string
            .replaceAll("\b", "\\b")
            .replaceAll("\f", "\\f")
            .replaceAll("\t", "\\t")
            .replaceAll("\v", "\\v")
            .replaceAll(// does not remove line breaks
        /\r\n|\r|\n/g, (str) => str === "\r" ? "\\r" : str === "\n" ? "\\n\n" : "\\r\\n\r\n");
    }
    function tokenize(string, { wordDiff = false } = {}) {
        if (wordDiff) {
            // Split string on whitespace symbols
            const tokens = string.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/);
            // Extended Latin character set
            const words = /^[a-zA-Z\u{C0}-\u{FF}\u{D8}-\u{F6}\u{F8}-\u{2C6}\u{2C8}-\u{2D7}\u{2DE}-\u{2FF}\u{1E00}-\u{1EFF}]+$/u;
            // Join boundary splits that we do not consider to be boundaries and merge empty strings surrounded by word chars
            for (let i = 0; i < tokens.length - 1; i++) {
                if (!tokens[i + 1] && tokens[i + 2] && words.test(tokens[i]) &&
                    words.test(tokens[i + 2])) {
                    tokens[i] += tokens[i + 2];
                    tokens.splice(i + 1, 2);
                    i--;
                }
            }
            return tokens.filter((token) => token);
        }
        else {
            // Split string on new lines symbols
            const tokens = [], lines = string.split(/(\n|\r\n)/);
            // Ignore final empty token when text ends with a newline
            if (!lines[lines.length - 1]) {
                lines.pop();
            }
            // Merge the content and line separators into single tokens
            for (let i = 0; i < lines.length; i++) {
                if (i % 2) {
                    tokens[tokens.length - 1] += lines[i];
                }
                else {
                    tokens.push(lines[i]);
                }
            }
            return tokens;
        }
    }
    // Create details by filtering relevant word-diff for current line
    // and merge "space-diff" if surrounded by word-diff for cleaner displays
    function createDetails(line, tokens) {
        return tokens.filter(({ type }) => type === line.type || type === DiffType.common).map((result, i, t) => {
            if ((result.type === DiffType.common) && (t[i - 1]) &&
                (t[i - 1]?.type === t[i + 1]?.type) && /\s+/.test(result.value)) {
                result.type = t[i - 1].type;
            }
            return result;
        });
    }
    // Compute multi-line diff
    const diffResult = diff(tokenize(`${unescape(A)}\n`), tokenize(`${unescape(B)}\n`));
    const added = [], removed = [];
    for (const result of diffResult) {
        if (result.type === DiffType.added) {
            added.push(result);
        }
        if (result.type === DiffType.removed) {
            removed.push(result);
        }
    }
    // Compute word-diff
    const aLines = added.length < removed.length ? added : removed;
    const bLines = aLines === removed ? added : removed;
    for (const a of aLines) {
        let tokens = [], b;
        // Search another diff line with at least one common token
        while (bLines.length) {
            b = bLines.shift();
            tokens = diff(tokenize(a.value, { wordDiff: true }), tokenize(b?.value ?? "", { wordDiff: true }));
            if (tokens.some(({ type, value }) => type === DiffType.common && value.trim().length)) {
                break;
            }
        }
        // Register word-diff details
        a.details = createDetails(a, tokens);
        if (b) {
            b.details = createDetails(b, tokens);
        }
    }
    return diffResult;
}
/**
 * Colors the output of assertion diffs
 * @param diffType Difference type, either added or removed
 */
function createColor(diffType, { background = false } = {}) {
    // TODO(@littledivy): Remove this when we can detect
    // true color terminals.
    // https://github.com/denoland/deno_std/issues/2575
    background = false;
    switch (diffType) {
        case DiffType.added:
            return (s) => background ? (0,_fmt_colors_js__WEBPACK_IMPORTED_MODULE_0__.bgGreen)((0,_fmt_colors_js__WEBPACK_IMPORTED_MODULE_0__.white)(s)) : (0,_fmt_colors_js__WEBPACK_IMPORTED_MODULE_0__.green)((0,_fmt_colors_js__WEBPACK_IMPORTED_MODULE_0__.bold)(s));
        case DiffType.removed:
            return (s) => background ? (0,_fmt_colors_js__WEBPACK_IMPORTED_MODULE_0__.bgRed)((0,_fmt_colors_js__WEBPACK_IMPORTED_MODULE_0__.white)(s)) : (0,_fmt_colors_js__WEBPACK_IMPORTED_MODULE_0__.red)((0,_fmt_colors_js__WEBPACK_IMPORTED_MODULE_0__.bold)(s));
        default:
            return _fmt_colors_js__WEBPACK_IMPORTED_MODULE_0__.white;
    }
}
/**
 * Prefixes `+` or `-` in diff output
 * @param diffType Difference type, either added or removed
 */
function createSign(diffType) {
    switch (diffType) {
        case DiffType.added:
            return "+   ";
        case DiffType.removed:
            return "-   ";
        default:
            return "    ";
    }
}
function buildMessage(diffResult, { stringDiff = false } = {}) {
    const messages = [], diffMessages = [];
    messages.push("");
    messages.push("");
    messages.push(`    ${(0,_fmt_colors_js__WEBPACK_IMPORTED_MODULE_0__.gray)((0,_fmt_colors_js__WEBPACK_IMPORTED_MODULE_0__.bold)("[Diff]"))} ${(0,_fmt_colors_js__WEBPACK_IMPORTED_MODULE_0__.red)((0,_fmt_colors_js__WEBPACK_IMPORTED_MODULE_0__.bold)("Actual"))} / ${(0,_fmt_colors_js__WEBPACK_IMPORTED_MODULE_0__.green)((0,_fmt_colors_js__WEBPACK_IMPORTED_MODULE_0__.bold)("Expected"))}`);
    messages.push("");
    messages.push("");
    diffResult.forEach((result) => {
        const c = createColor(result.type);
        const line = result.details?.map((detail) => detail.type !== DiffType.common
            ? createColor(detail.type, { background: true })(detail.value)
            : detail.value).join("") ?? result.value;
        diffMessages.push(c(`${createSign(result.type)}${line}`));
    });
    messages.push(...(stringDiff ? [diffMessages.join("")] : diffMessages));
    messages.push("");
    return messages;
}
//# sourceMappingURL=_diff.js.map

/***/ }),

/***/ "./node_modules/capi/esm/deps_2/deno.land/std@0.158.0/testing/_format.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/capi/esm/deps_2/deno.land/std@0.158.0/testing/_format.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "format": function() { return /* binding */ format; }
/* harmony export */ });
/* harmony import */ var _dnt_shims_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../_dnt.shims.js */ "./node_modules/capi/esm/_dnt.shims.js");
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
/**
 * Converts the input into a string. Objects, Sets and Maps are sorted so as to
 * make tests less flaky
 * @param v Value to be formatted
 */

function format(v) {
    // deno-lint-ignore no-explicit-any
    const { Deno } = _dnt_shims_js__WEBPACK_IMPORTED_MODULE_0__.dntGlobalThis;
    return typeof Deno?.inspect === "function"
        ? Deno.inspect(v, {
            depth: Infinity,
            sorted: true,
            trailingComma: true,
            compact: false,
            iterableLimit: Infinity,
            // getters should be true in assertEquals.
            getters: true,
        })
        : `"${String(v).replace(/(?=["\\])/g, "\\")}"`;
}
//# sourceMappingURL=_format.js.map

/***/ }),

/***/ "./node_modules/capi/esm/deps_2/deno.land/std@0.158.0/testing/asserts.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/capi/esm/deps_2/deno.land/std@0.158.0/testing/asserts.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AssertionError": function() { return /* binding */ AssertionError; },
/* harmony export */   "assert": function() { return /* binding */ assert; },
/* harmony export */   "assertAlmostEquals": function() { return /* binding */ assertAlmostEquals; },
/* harmony export */   "assertArrayIncludes": function() { return /* binding */ assertArrayIncludes; },
/* harmony export */   "assertEquals": function() { return /* binding */ assertEquals; },
/* harmony export */   "assertExists": function() { return /* binding */ assertExists; },
/* harmony export */   "assertFalse": function() { return /* binding */ assertFalse; },
/* harmony export */   "assertInstanceOf": function() { return /* binding */ assertInstanceOf; },
/* harmony export */   "assertIsError": function() { return /* binding */ assertIsError; },
/* harmony export */   "assertMatch": function() { return /* binding */ assertMatch; },
/* harmony export */   "assertNotEquals": function() { return /* binding */ assertNotEquals; },
/* harmony export */   "assertNotInstanceOf": function() { return /* binding */ assertNotInstanceOf; },
/* harmony export */   "assertNotMatch": function() { return /* binding */ assertNotMatch; },
/* harmony export */   "assertNotStrictEquals": function() { return /* binding */ assertNotStrictEquals; },
/* harmony export */   "assertObjectMatch": function() { return /* binding */ assertObjectMatch; },
/* harmony export */   "assertRejects": function() { return /* binding */ assertRejects; },
/* harmony export */   "assertStrictEquals": function() { return /* binding */ assertStrictEquals; },
/* harmony export */   "assertStringIncludes": function() { return /* binding */ assertStringIncludes; },
/* harmony export */   "assertThrows": function() { return /* binding */ assertThrows; },
/* harmony export */   "equal": function() { return /* binding */ equal; },
/* harmony export */   "fail": function() { return /* binding */ fail; },
/* harmony export */   "unimplemented": function() { return /* binding */ unimplemented; },
/* harmony export */   "unreachable": function() { return /* binding */ unreachable; }
/* harmony export */ });
/* harmony import */ var _fmt_colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../fmt/colors.js */ "./node_modules/capi/esm/deps_2/deno.land/std@0.158.0/fmt/colors.js");
/* harmony import */ var _diff_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_diff.js */ "./node_modules/capi/esm/deps_2/deno.land/std@0.158.0/testing/_diff.js");
/* harmony import */ var _format_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_format.js */ "./node_modules/capi/esm/deps_2/deno.land/std@0.158.0/testing/_format.js");
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
/** A library of assertion functions.
 *
 * This module is browser compatible, but do not rely on good formatting of
 * values for AssertionError messages in browsers.
 *
 * @module
 */



const CAN_NOT_DISPLAY = "[Cannot display]";
class AssertionError extends Error {
    constructor(message) {
        super(message);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AssertionError"
        });
    }
}
function isKeyedCollection(x) {
    return [Symbol.iterator, "size"].every((k) => k in x);
}
/**
 * Deep equality comparison used in assertions
 * @param c actual value
 * @param d expected value
 */
function equal(c, d) {
    const seen = new Map();
    return (function compare(a, b) {
        // Have to render RegExp & Date for string comparison
        // unless it's mistreated as object
        if (a &&
            b &&
            ((a instanceof RegExp && b instanceof RegExp) ||
                (a instanceof URL && b instanceof URL))) {
            return String(a) === String(b);
        }
        if (a instanceof Date && b instanceof Date) {
            const aTime = a.getTime();
            const bTime = b.getTime();
            // Check for NaN equality manually since NaN is not
            // equal to itself.
            if (Number.isNaN(aTime) && Number.isNaN(bTime)) {
                return true;
            }
            return aTime === bTime;
        }
        if (typeof a === "number" && typeof b === "number") {
            return Number.isNaN(a) && Number.isNaN(b) || a === b;
        }
        if (Object.is(a, b)) {
            return true;
        }
        if (a && typeof a === "object" && b && typeof b === "object") {
            if (a && b && !constructorsEqual(a, b)) {
                return false;
            }
            if (a instanceof WeakMap || b instanceof WeakMap) {
                if (!(a instanceof WeakMap && b instanceof WeakMap))
                    return false;
                throw new TypeError("cannot compare WeakMap instances");
            }
            if (a instanceof WeakSet || b instanceof WeakSet) {
                if (!(a instanceof WeakSet && b instanceof WeakSet))
                    return false;
                throw new TypeError("cannot compare WeakSet instances");
            }
            if (seen.get(a) === b) {
                return true;
            }
            if (Object.keys(a || {}).length !== Object.keys(b || {}).length) {
                return false;
            }
            seen.set(a, b);
            if (isKeyedCollection(a) && isKeyedCollection(b)) {
                if (a.size !== b.size) {
                    return false;
                }
                let unmatchedEntries = a.size;
                for (const [aKey, aValue] of a.entries()) {
                    for (const [bKey, bValue] of b.entries()) {
                        /* Given that Map keys can be references, we need
                         * to ensure that they are also deeply equal */
                        if ((aKey === aValue && bKey === bValue && compare(aKey, bKey)) ||
                            (compare(aKey, bKey) && compare(aValue, bValue))) {
                            unmatchedEntries--;
                            break;
                        }
                    }
                }
                return unmatchedEntries === 0;
            }
            const merged = { ...a, ...b };
            for (const key of [
                ...Object.getOwnPropertyNames(merged),
                ...Object.getOwnPropertySymbols(merged),
            ]) {
                if (!compare(a && a[key], b && b[key])) {
                    return false;
                }
                if (((key in a) && (!(key in b))) || ((key in b) && (!(key in a)))) {
                    return false;
                }
            }
            if (a instanceof WeakRef || b instanceof WeakRef) {
                if (!(a instanceof WeakRef && b instanceof WeakRef))
                    return false;
                return compare(a.deref(), b.deref());
            }
            return true;
        }
        return false;
    })(c, d);
}
// deno-lint-ignore ban-types
function constructorsEqual(a, b) {
    return a.constructor === b.constructor ||
        a.constructor === Object && !b.constructor ||
        !a.constructor && b.constructor === Object;
}
/** Make an assertion, error will be thrown if `expr` does not have truthy value. */
function assert(expr, msg = "") {
    if (!expr) {
        throw new AssertionError(msg);
    }
}
function assertFalse(expr, msg = "") {
    if (expr) {
        throw new AssertionError(msg);
    }
}
/**
 * Make an assertion that `actual` and `expected` are equal, deeply. If not
 * deeply equal, then throw.
 *
 * Type parameter can be specified to ensure values under comparison have the same type.
 * For example:
 * ```ts
 * import { assertEquals } from "./asserts.ts";
 *
 * assertEquals<number>(1, 2)
 * ```
 */
function assertEquals(actual, expected, msg) {
    if (equal(actual, expected)) {
        return;
    }
    let message = "";
    const actualString = (0,_format_js__WEBPACK_IMPORTED_MODULE_2__.format)(actual);
    const expectedString = (0,_format_js__WEBPACK_IMPORTED_MODULE_2__.format)(expected);
    try {
        const stringDiff = (typeof actual === "string") &&
            (typeof expected === "string");
        const diffResult = stringDiff
            ? (0,_diff_js__WEBPACK_IMPORTED_MODULE_1__.diffstr)(actual, expected)
            : (0,_diff_js__WEBPACK_IMPORTED_MODULE_1__.diff)(actualString.split("\n"), expectedString.split("\n"));
        const diffMsg = (0,_diff_js__WEBPACK_IMPORTED_MODULE_1__.buildMessage)(diffResult, { stringDiff }).join("\n");
        message = `Values are not equal:\n${diffMsg}`;
    }
    catch {
        message = `\n${(0,_fmt_colors_js__WEBPACK_IMPORTED_MODULE_0__.red)(CAN_NOT_DISPLAY)} + \n\n`;
    }
    if (msg) {
        message = msg;
    }
    throw new AssertionError(message);
}
/**
 * Make an assertion that `actual` and `expected` are not equal, deeply.
 * If not then throw.
 *
 * Type parameter can be specified to ensure values under comparison have the same type.
 * For example:
 * ```ts
 * import { assertNotEquals } from "./asserts.ts";
 *
 * assertNotEquals<number>(1, 2)
 * ```
 */
function assertNotEquals(actual, expected, msg) {
    if (!equal(actual, expected)) {
        return;
    }
    let actualString;
    let expectedString;
    try {
        actualString = String(actual);
    }
    catch {
        actualString = "[Cannot display]";
    }
    try {
        expectedString = String(expected);
    }
    catch {
        expectedString = "[Cannot display]";
    }
    if (!msg) {
        msg = `actual: ${actualString} expected not to be: ${expectedString}`;
    }
    throw new AssertionError(msg);
}
/**
 * Make an assertion that `actual` and `expected` are strictly equal. If
 * not then throw.
 *
 * ```ts
 * import { assertStrictEquals } from "./asserts.ts";
 *
 * assertStrictEquals(1, 2)
 * ```
 */
function assertStrictEquals(actual, expected, msg) {
    if (Object.is(actual, expected)) {
        return;
    }
    let message;
    if (msg) {
        message = msg;
    }
    else {
        const actualString = (0,_format_js__WEBPACK_IMPORTED_MODULE_2__.format)(actual);
        const expectedString = (0,_format_js__WEBPACK_IMPORTED_MODULE_2__.format)(expected);
        if (actualString === expectedString) {
            const withOffset = actualString
                .split("\n")
                .map((l) => `    ${l}`)
                .join("\n");
            message =
                `Values have the same structure but are not reference-equal:\n\n${(0,_fmt_colors_js__WEBPACK_IMPORTED_MODULE_0__.red)(withOffset)}\n`;
        }
        else {
            try {
                const stringDiff = (typeof actual === "string") &&
                    (typeof expected === "string");
                const diffResult = stringDiff
                    ? (0,_diff_js__WEBPACK_IMPORTED_MODULE_1__.diffstr)(actual, expected)
                    : (0,_diff_js__WEBPACK_IMPORTED_MODULE_1__.diff)(actualString.split("\n"), expectedString.split("\n"));
                const diffMsg = (0,_diff_js__WEBPACK_IMPORTED_MODULE_1__.buildMessage)(diffResult, { stringDiff }).join("\n");
                message = `Values are not strictly equal:\n${diffMsg}`;
            }
            catch {
                message = `\n${(0,_fmt_colors_js__WEBPACK_IMPORTED_MODULE_0__.red)(CAN_NOT_DISPLAY)} + \n\n`;
            }
        }
    }
    throw new AssertionError(message);
}
/**
 * Make an assertion that `actual` and `expected` are not strictly equal.
 * If the values are strictly equal then throw.
 *
 * ```ts
 * import { assertNotStrictEquals } from "./asserts.ts";
 *
 * assertNotStrictEquals(1, 1)
 * ```
 */
function assertNotStrictEquals(actual, expected, msg) {
    if (!Object.is(actual, expected)) {
        return;
    }
    throw new AssertionError(msg ?? `Expected "actual" to be strictly unequal to: ${(0,_format_js__WEBPACK_IMPORTED_MODULE_2__.format)(actual)}\n`);
}
/**
 * Make an assertion that `actual` and `expected` are almost equal numbers through
 * a given tolerance. It can be used to take into account IEEE-754 double-precision
 * floating-point representation limitations.
 * If the values are not almost equal then throw.
 *
 * ```ts
 * import { assertAlmostEquals, assertThrows } from "./asserts.ts";
 *
 * assertAlmostEquals(0.1, 0.2);
 *
 * // Using a custom tolerance value
 * assertAlmostEquals(0.1 + 0.2, 0.3, 1e-16);
 * assertThrows(() => assertAlmostEquals(0.1 + 0.2, 0.3, 1e-17));
 * ```
 */
function assertAlmostEquals(actual, expected, tolerance = 1e-7, msg) {
    if (Object.is(actual, expected)) {
        return;
    }
    const delta = Math.abs(expected - actual);
    if (delta <= tolerance) {
        return;
    }
    const f = (n) => Number.isInteger(n) ? n : n.toExponential();
    throw new AssertionError(msg ??
        `actual: "${f(actual)}" expected to be close to "${f(expected)}": \
delta "${f(delta)}" is greater than "${f(tolerance)}"`);
}
/**
 * Make an assertion that `obj` is an instance of `type`.
 * If not then throw.
 */
function assertInstanceOf(actual, expectedType, msg = "") {
    if (!msg) {
        const expectedTypeStr = expectedType.name;
        let actualTypeStr = "";
        if (actual === null) {
            actualTypeStr = "null";
        }
        else if (actual === undefined) {
            actualTypeStr = "undefined";
        }
        else if (typeof actual === "object") {
            actualTypeStr = actual.constructor?.name ?? "Object";
        }
        else {
            actualTypeStr = typeof actual;
        }
        if (expectedTypeStr == actualTypeStr) {
            msg = `Expected object to be an instance of "${expectedTypeStr}".`;
        }
        else if (actualTypeStr == "function") {
            msg =
                `Expected object to be an instance of "${expectedTypeStr}" but was not an instanced object.`;
        }
        else {
            msg =
                `Expected object to be an instance of "${expectedTypeStr}" but was "${actualTypeStr}".`;
        }
    }
    assert(actual instanceof expectedType, msg);
}
/**
 * Make an assertion that `obj` is not an instance of `type`.
 * If so, then throw.
 */
function assertNotInstanceOf(actual, 
// deno-lint-ignore no-explicit-any
unexpectedType, msg = `Expected object to not be an instance of "${typeof unexpectedType}"`) {
    assertFalse(actual instanceof unexpectedType, msg);
}
/**
 * Make an assertion that actual is not null or undefined.
 * If not then throw.
 */
function assertExists(actual, msg) {
    if (actual === undefined || actual === null) {
        if (!msg) {
            msg = `actual: "${actual}" expected to not be null or undefined`;
        }
        throw new AssertionError(msg);
    }
}
/**
 * Make an assertion that actual includes expected. If not
 * then throw.
 */
function assertStringIncludes(actual, expected, msg) {
    if (!actual.includes(expected)) {
        if (!msg) {
            msg = `actual: "${actual}" expected to contain: "${expected}"`;
        }
        throw new AssertionError(msg);
    }
}
/**
 * Make an assertion that `actual` includes the `expected` values.
 * If not then an error will be thrown.
 *
 * Type parameter can be specified to ensure values under comparison have the same type.
 * For example:
 *
 * ```ts
 * import { assertArrayIncludes } from "./asserts.ts";
 *
 * assertArrayIncludes<number>([1, 2], [2])
 * ```
 */
function assertArrayIncludes(actual, expected, msg) {
    const missing = [];
    for (let i = 0; i < expected.length; i++) {
        let found = false;
        for (let j = 0; j < actual.length; j++) {
            if (equal(expected[i], actual[j])) {
                found = true;
                break;
            }
        }
        if (!found) {
            missing.push(expected[i]);
        }
    }
    if (missing.length === 0) {
        return;
    }
    if (!msg) {
        msg = `actual: "${(0,_format_js__WEBPACK_IMPORTED_MODULE_2__.format)(actual)}" expected to include: "${(0,_format_js__WEBPACK_IMPORTED_MODULE_2__.format)(expected)}"\nmissing: ${(0,_format_js__WEBPACK_IMPORTED_MODULE_2__.format)(missing)}`;
    }
    throw new AssertionError(msg);
}
/**
 * Make an assertion that `actual` match RegExp `expected`. If not
 * then throw.
 */
function assertMatch(actual, expected, msg) {
    if (!expected.test(actual)) {
        if (!msg) {
            msg = `actual: "${actual}" expected to match: "${expected}"`;
        }
        throw new AssertionError(msg);
    }
}
/**
 * Make an assertion that `actual` not match RegExp `expected`. If match
 * then throw.
 */
function assertNotMatch(actual, expected, msg) {
    if (expected.test(actual)) {
        if (!msg) {
            msg = `actual: "${actual}" expected to not match: "${expected}"`;
        }
        throw new AssertionError(msg);
    }
}
/**
 * Make an assertion that `actual` object is a subset of `expected` object, deeply.
 * If not, then throw.
 */
function assertObjectMatch(
// deno-lint-ignore no-explicit-any
actual, expected) {
    function filter(a, b) {
        const seen = new WeakMap();
        return fn(a, b);
        function fn(a, b) {
            // Prevent infinite loop with circular references with same filter
            if ((seen.has(a)) && (seen.get(a) === b)) {
                return a;
            }
            seen.set(a, b);
            // Filter keys and symbols which are present in both actual and expected
            const filtered = {};
            const entries = [
                ...Object.getOwnPropertyNames(a),
                ...Object.getOwnPropertySymbols(a),
            ]
                .filter((key) => key in b)
                .map((key) => [key, a[key]]);
            for (const [key, value] of entries) {
                // On array references, build a filtered array and filter nested objects inside
                if (Array.isArray(value)) {
                    const subset = b[key];
                    if (Array.isArray(subset)) {
                        filtered[key] = fn({ ...value }, { ...subset });
                        continue;
                    }
                } // On regexp references, keep value as it to avoid loosing pattern and flags
                else if (value instanceof RegExp) {
                    filtered[key] = value;
                    continue;
                } // On nested objects references, build a filtered object recursively
                else if (typeof value === "object") {
                    const subset = b[key];
                    if ((typeof subset === "object") && (subset)) {
                        // When both operands are maps, build a filtered map with common keys and filter nested objects inside
                        if ((value instanceof Map) && (subset instanceof Map)) {
                            filtered[key] = new Map([...value].filter(([k]) => subset.has(k)).map(([k, v]) => [k, typeof v === "object" ? fn(v, subset.get(k)) : v]));
                            continue;
                        }
                        // When both operands are set, build a filtered set with common values
                        if ((value instanceof Set) && (subset instanceof Set)) {
                            filtered[key] = new Set([...value].filter((v) => subset.has(v)));
                            continue;
                        }
                        filtered[key] = fn(value, subset);
                        continue;
                    }
                }
                filtered[key] = value;
            }
            return filtered;
        }
    }
    return assertEquals(
    // get the intersection of "actual" and "expected"
    // side effect: all the instances' constructor field is "Object" now.
    filter(actual, expected), 
    // set (nested) instances' constructor field to be "Object" without changing expected value.
    // see https://github.com/denoland/deno_std/pull/1419
    filter(expected, expected));
}
/**
 * Forcefully throws a failed assertion
 */
function fail(msg) {
    assert(false, `Failed assertion${msg ? `: ${msg}` : "."}`);
}
/**
 * Make an assertion that `error` is an `Error`.
 * If not then an error will be thrown.
 * An error class and a string that should be included in the
 * error message can also be asserted.
 */
function assertIsError(error, 
// deno-lint-ignore no-explicit-any
ErrorClass, msgIncludes, msg) {
    if (error instanceof Error === false) {
        throw new AssertionError(`Expected "error" to be an Error object.`);
    }
    if (ErrorClass && !(error instanceof ErrorClass)) {
        msg = `Expected error to be instance of "${ErrorClass.name}", but was "${typeof error === "object" ? error?.constructor?.name : "[not an object]"}"${msg ? `: ${msg}` : "."}`;
        throw new AssertionError(msg);
    }
    if (msgIncludes && (!(error instanceof Error) ||
        !(0,_fmt_colors_js__WEBPACK_IMPORTED_MODULE_0__.stripColor)(error.message).includes((0,_fmt_colors_js__WEBPACK_IMPORTED_MODULE_0__.stripColor)(msgIncludes)))) {
        msg = `Expected error message to include "${msgIncludes}", but got "${error instanceof Error ? error.message : "[not an Error]"}"${msg ? `: ${msg}` : "."}`;
        throw new AssertionError(msg);
    }
}
function assertThrows(fn, errorClassOrCallbackOrMsg, msgIncludesOrMsg, msg) {
    // deno-lint-ignore no-explicit-any
    let ErrorClass = undefined;
    let msgIncludes = undefined;
    let errorCallback = undefined;
    let err;
    if (typeof errorClassOrCallbackOrMsg !== "string") {
        if (errorClassOrCallbackOrMsg === undefined ||
            errorClassOrCallbackOrMsg.prototype instanceof Error ||
            errorClassOrCallbackOrMsg.prototype === Error.prototype) {
            // deno-lint-ignore no-explicit-any
            ErrorClass = errorClassOrCallbackOrMsg;
            msgIncludes = msgIncludesOrMsg;
        }
        else {
            errorCallback = errorClassOrCallbackOrMsg;
            msg = msgIncludesOrMsg;
        }
    }
    else {
        msg = errorClassOrCallbackOrMsg;
    }
    let doesThrow = false;
    const msgToAppendToError = msg ? `: ${msg}` : ".";
    try {
        fn();
    }
    catch (error) {
        if (ErrorClass || errorCallback) {
            if (error instanceof Error === false) {
                throw new AssertionError("A non-Error object was thrown.");
            }
            assertIsError(error, ErrorClass, msgIncludes, msg);
            if (typeof errorCallback === "function") {
                errorCallback(error);
            }
        }
        err = error;
        doesThrow = true;
    }
    if (!doesThrow) {
        msg = `Expected function to throw${msgToAppendToError}`;
        throw new AssertionError(msg);
    }
    return err;
}
async function assertRejects(fn, errorClassOrCallbackOrMsg, msgIncludesOrMsg, msg) {
    // deno-lint-ignore no-explicit-any
    let ErrorClass = undefined;
    let msgIncludes = undefined;
    let errorCallback = undefined;
    let err;
    if (typeof errorClassOrCallbackOrMsg !== "string") {
        if (errorClassOrCallbackOrMsg === undefined ||
            errorClassOrCallbackOrMsg.prototype instanceof Error ||
            errorClassOrCallbackOrMsg.prototype === Error.prototype) {
            // deno-lint-ignore no-explicit-any
            ErrorClass = errorClassOrCallbackOrMsg;
            msgIncludes = msgIncludesOrMsg;
        }
        else {
            errorCallback = errorClassOrCallbackOrMsg;
            msg = msgIncludesOrMsg;
        }
    }
    else {
        msg = errorClassOrCallbackOrMsg;
    }
    let doesThrow = false;
    let isPromiseReturned = false;
    const msgToAppendToError = msg ? `: ${msg}` : ".";
    try {
        const possiblePromise = fn();
        if (possiblePromise &&
            typeof possiblePromise === "object" &&
            typeof possiblePromise.then === "function") {
            isPromiseReturned = true;
            await possiblePromise;
        }
    }
    catch (error) {
        if (!isPromiseReturned) {
            throw new AssertionError(`Function throws when expected to reject${msgToAppendToError}`);
        }
        if (ErrorClass || errorCallback) {
            if (error instanceof Error === false) {
                throw new AssertionError("A non-Error object was rejected.");
            }
            assertIsError(error, ErrorClass, msgIncludes, msg);
            if (typeof errorCallback == "function") {
                errorCallback(error);
            }
        }
        err = error;
        doesThrow = true;
    }
    if (!doesThrow) {
        throw new AssertionError(`Expected function to reject${msgToAppendToError}`);
    }
    return err;
}
/** Use this to stub out methods that will throw when invoked. */
function unimplemented(msg) {
    throw new AssertionError(msg || "unimplemented");
}
/** Use this to assert unreachable code. */
function unreachable() {
    throw new AssertionError("unreachable");
}
//# sourceMappingURL=asserts.js.map

/***/ }),

/***/ "./node_modules/capi/esm/effect/atoms/$Extrinsic.js":
/*!**********************************************************!*\
  !*** ./node_modules/capi/esm/effect/atoms/$Extrinsic.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$extrinsic": function() { return /* binding */ $extrinsic; }
/* harmony export */ });
/* harmony import */ var _frame_metadata_mod_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../frame_metadata/mod.js */ "./node_modules/capi/esm/frame_metadata/mod.js");
/* harmony import */ var _sys_Atom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../sys/Atom.js */ "./node_modules/capi/esm/effect/sys/Atom.js");


const $extrinsic = (0,_sys_Atom_js__WEBPACK_IMPORTED_MODULE_1__.atomFactory)("ExtrinsicCodec", (deriveCodec, metadata, sign, prefix) => {
    return _frame_metadata_mod_js__WEBPACK_IMPORTED_MODULE_0__.$extrinsic({
        deriveCodec,
        metadata,
        sign: sign,
        prefix: prefix,
    });
});
//# sourceMappingURL=$Extrinsic.js.map

/***/ }),

/***/ "./node_modules/capi/esm/effect/atoms/$Key.js":
/*!****************************************************!*\
  !*** ./node_modules/capi/esm/effect/atoms/$Key.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$key": function() { return /* binding */ $key; }
/* harmony export */ });
/* harmony import */ var _frame_metadata_mod_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../frame_metadata/mod.js */ "./node_modules/capi/esm/frame_metadata/mod.js");
/* harmony import */ var _sys_Atom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../sys/Atom.js */ "./node_modules/capi/esm/effect/sys/Atom.js");


const $key = (0,_sys_Atom_js__WEBPACK_IMPORTED_MODULE_1__.atomFactory)("KeyCodec", (deriveCodec, pallet, storageEntry) => {
    return _frame_metadata_mod_js__WEBPACK_IMPORTED_MODULE_0__.$storageKey({
        deriveCodec,
        pallet,
        storageEntry,
    });
});
//# sourceMappingURL=$Key.js.map

/***/ }),

/***/ "./node_modules/capi/esm/effect/atoms/$StorageKey.js":
/*!***********************************************************!*\
  !*** ./node_modules/capi/esm/effect/atoms/$StorageKey.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$storageKey": function() { return /* binding */ $storageKey; }
/* harmony export */ });
/* harmony import */ var _frame_metadata_mod_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../frame_metadata/mod.js */ "./node_modules/capi/esm/frame_metadata/mod.js");
/* harmony import */ var _sys_Atom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../sys/Atom.js */ "./node_modules/capi/esm/effect/sys/Atom.js");


const $storageKey = (0,_sys_Atom_js__WEBPACK_IMPORTED_MODULE_1__.atomFactory)("$StorageKey", (deriveCodec, pallet, storageEntry) => {
    return _frame_metadata_mod_js__WEBPACK_IMPORTED_MODULE_0__.$storageKey({
        deriveCodec,
        pallet,
        storageEntry,
    });
});
//# sourceMappingURL=$StorageKey.js.map

/***/ }),

/***/ "./node_modules/capi/esm/effect/atoms/Codec.js":
/*!*****************************************************!*\
  !*** ./node_modules/capi/esm/effect/atoms/Codec.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "codec": function() { return /* binding */ codec; }
/* harmony export */ });
/* harmony import */ var _sys_Atom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../sys/Atom.js */ "./node_modules/capi/esm/effect/sys/Atom.js");

const codec = (0,_sys_Atom_js__WEBPACK_IMPORTED_MODULE_0__.atomFactory)("Codec", (deriveCodec, ty) => {
    return deriveCodec(ty);
});
//# sourceMappingURL=Codec.js.map

/***/ }),

/***/ "./node_modules/capi/esm/effect/atoms/Decoded.js":
/*!*******************************************************!*\
  !*** ./node_modules/capi/esm/effect/atoms/Decoded.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "decoded": function() { return /* binding */ decoded; }
/* harmony export */ });
/* harmony import */ var _util_mod_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/mod.js */ "./node_modules/capi/esm/util/mod.js");
/* harmony import */ var _sys_Atom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../sys/Atom.js */ "./node_modules/capi/esm/effect/sys/Atom.js");


function decoded(codec, encoded, key) {
    return (0,_sys_Atom_js__WEBPACK_IMPORTED_MODULE_1__.atom)("Decoded", [codec, encoded, key], 
    // TODO: create `Wrap` util â€“â€“ this is currently necessary as the decoded value is `unknown`,
    // whichâ€“â€“left top-levelâ€“â€“unifies with error types.
    (codec, encoded, key) => {
        return { [key]: codec.decode(_util_mod_js__WEBPACK_IMPORTED_MODULE_0__.hex.decode(encoded)) };
    });
}
//# sourceMappingURL=Decoded.js.map

/***/ }),

/***/ "./node_modules/capi/esm/effect/atoms/DeriveCodec.js":
/*!***********************************************************!*\
  !*** ./node_modules/capi/esm/effect/atoms/DeriveCodec.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "deriveCodec": function() { return /* binding */ deriveCodec; }
/* harmony export */ });
/* harmony import */ var _frame_metadata_mod_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../frame_metadata/mod.js */ "./node_modules/capi/esm/frame_metadata/mod.js");
/* harmony import */ var _sys_Atom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../sys/Atom.js */ "./node_modules/capi/esm/effect/sys/Atom.js");


const deriveCodec = (0,_sys_Atom_js__WEBPACK_IMPORTED_MODULE_1__.atomFactory)("DeriveCodec", (metadata) => {
    return _frame_metadata_mod_js__WEBPACK_IMPORTED_MODULE_0__.DeriveCodec(metadata.tys);
});
//# sourceMappingURL=DeriveCodec.js.map

/***/ }),

/***/ "./node_modules/capi/esm/effect/atoms/Metadata.js":
/*!********************************************************!*\
  !*** ./node_modules/capi/esm/effect/atoms/Metadata.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MetadataDecodeError": function() { return /* binding */ MetadataDecodeError; },
/* harmony export */   "entryMetadata": function() { return /* binding */ entryMetadata; },
/* harmony export */   "metadata": function() { return /* binding */ metadata; },
/* harmony export */   "palletMetadata": function() { return /* binding */ palletMetadata; },
/* harmony export */   "parseMetadata": function() { return /* binding */ parseMetadata; }
/* harmony export */ });
/* harmony import */ var _frame_metadata_mod_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../frame_metadata/mod.js */ "./node_modules/capi/esm/frame_metadata/mod.js");
/* harmony import */ var _util_mod_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/mod.js */ "./node_modules/capi/esm/util/mod.js");
/* harmony import */ var _sys_Atom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../sys/Atom.js */ "./node_modules/capi/esm/effect/sys/Atom.js");
/* harmony import */ var _RpcCall_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RpcCall.js */ "./node_modules/capi/esm/effect/atoms/RpcCall.js");




function metadata(config, ...[blockHash]) {
    const call = (0,_RpcCall_js__WEBPACK_IMPORTED_MODULE_3__.rpcCall)(config, "state_getMetadata", [blockHash]);
    return parseMetadata(call);
}
const parseMetadata = (0,_sys_Atom_js__WEBPACK_IMPORTED_MODULE_2__.atomFactory)("Metadata", (call) => {
    try {
        return _frame_metadata_mod_js__WEBPACK_IMPORTED_MODULE_0__.fromPrefixedHex(call.result);
    }
    catch (e) {
        return new MetadataDecodeError(e);
    }
});
const palletMetadata = (0,_sys_Atom_js__WEBPACK_IMPORTED_MODULE_2__.atomFactory)("PalletMetadata", (metadata, palletName) => {
    return _frame_metadata_mod_js__WEBPACK_IMPORTED_MODULE_0__.getPallet(metadata, palletName);
});
const entryMetadata = (0,_sys_Atom_js__WEBPACK_IMPORTED_MODULE_2__.atomFactory)("EntryMetadata", (palletMetadata, entryName) => {
    return _frame_metadata_mod_js__WEBPACK_IMPORTED_MODULE_0__.getEntry(palletMetadata, entryName);
});
class MetadataDecodeError extends _util_mod_js__WEBPACK_IMPORTED_MODULE_1__.ErrorCtor("MetadataDecode") {
    // TODO: replace with internal scale error & ensure appropriate trace info
    constructor(scaleError) {
        super();
        Object.defineProperty(this, "scaleError", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: scaleError
        });
    }
}
//# sourceMappingURL=Metadata.js.map

/***/ }),

/***/ "./node_modules/capi/esm/effect/atoms/RpcCall.js":
/*!*******************************************************!*\
  !*** ./node_modules/capi/esm/effect/atoms/RpcCall.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "rpcCall": function() { return /* binding */ rpcCall; }
/* harmony export */ });
/* harmony import */ var _sys_Atom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../sys/Atom.js */ "./node_modules/capi/esm/effect/sys/Atom.js");
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common.js */ "./node_modules/capi/esm/effect/atoms/common.js");
/* harmony import */ var _RpcClient_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RpcClient.js */ "./node_modules/capi/esm/effect/atoms/RpcClient.js");



function rpcCall(config, methodName, params) {
    return (0,_sys_Atom_js__WEBPACK_IMPORTED_MODULE_0__.atom)("RpcCall", [(0,_RpcClient_js__WEBPACK_IMPORTED_MODULE_2__.rpcClient)(config), methodName, ...params], async (client, methodName, ...params) => {
        // TODO: clean up typings
        const result = await client.call(methodName, params);
        if (result.error) {
            return new _common_js__WEBPACK_IMPORTED_MODULE_1__.RpcError({
                ...result.error,
                attempt: {
                    methodName,
                    params,
                },
            });
        }
        // TODO: should this effect implicitly index into `result`?
        return result;
    });
}
//# sourceMappingURL=RpcCall.js.map

/***/ }),

/***/ "./node_modules/capi/esm/effect/atoms/RpcClient.js":
/*!*********************************************************!*\
  !*** ./node_modules/capi/esm/effect/atoms/RpcClient.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "rpcClient": function() { return /* binding */ rpcClient; }
/* harmony export */ });
/* harmony import */ var _rpc_mod_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../rpc/mod.js */ "./node_modules/capi/esm/rpc/mod.js");
/* harmony import */ var _sys_Atom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../sys/Atom.js */ "./node_modules/capi/esm/effect/sys/Atom.js");


function rpcClient(config) {
    return (0,_sys_Atom_js__WEBPACK_IMPORTED_MODULE_1__.atom)("RpcClient", [config], (config) => {
        return _rpc_mod_js__WEBPACK_IMPORTED_MODULE_0__.stdClient(config);
    }, async (client) => {
        await client.close();
    });
}
//# sourceMappingURL=RpcClient.js.map

/***/ }),

/***/ "./node_modules/capi/esm/effect/atoms/RpcSubscription.js":
/*!***************************************************************!*\
  !*** ./node_modules/capi/esm/effect/atoms/RpcSubscription.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RpcSubscriptionError": function() { return /* binding */ RpcSubscriptionError; },
/* harmony export */   "rpcSubscription": function() { return /* binding */ rpcSubscription; }
/* harmony export */ });
/* harmony import */ var _util_mod_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/mod.js */ "./node_modules/capi/esm/util/mod.js");
/* harmony import */ var _sys_Atom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../sys/Atom.js */ "./node_modules/capi/esm/effect/sys/Atom.js");
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common.js */ "./node_modules/capi/esm/effect/atoms/common.js");
/* harmony import */ var _RpcClient_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RpcClient.js */ "./node_modules/capi/esm/effect/atoms/RpcClient.js");




function rpcSubscription(config, methodName, params, createListener, cleanup) {
    return (0,_sys_Atom_js__WEBPACK_IMPORTED_MODULE_1__.atom)("RpcSubscription", [(0,_RpcClient_js__WEBPACK_IMPORTED_MODULE_3__.rpcClient)(config), methodName, ...params], async function (client, methodName, ...params) {
        const result = await client.subscribe(methodName, params, createListener, cleanup
            ? (x) => {
                return this.run(cleanup(x.result));
            }
            : undefined);
        if (result?.error) {
            return new _common_js__WEBPACK_IMPORTED_MODULE_2__.RpcError({
                ...result.error,
                attempt: {
                    methodName,
                    params,
                },
            });
        }
        // TODO: clean up typings â€“â€“ should implicitly narrow to `undefined`
        return result;
    });
}
class RpcSubscriptionError extends _util_mod_js__WEBPACK_IMPORTED_MODULE_0__.ErrorCtor("RpcSubscription") {
    constructor(error) {
        super();
        Object.defineProperty(this, "error", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: error
        });
    }
}
//# sourceMappingURL=RpcSubscription.js.map

/***/ }),

/***/ "./node_modules/capi/esm/effect/atoms/Select.js":
/*!******************************************************!*\
  !*** ./node_modules/capi/esm/effect/atoms/Select.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "select": function() { return /* binding */ select; }
/* harmony export */ });
/* harmony import */ var _sys_mod_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../sys/mod.js */ "./node_modules/capi/esm/effect/sys/mod.js");

function select(val, field) {
    return _sys_mod_js__WEBPACK_IMPORTED_MODULE_0__.atom("Select", [val, field], (val, field) => {
        return val[field];
    });
}
//# sourceMappingURL=Select.js.map

/***/ }),

/***/ "./node_modules/capi/esm/effect/atoms/StorageKey.js":
/*!**********************************************************!*\
  !*** ./node_modules/capi/esm/effect/atoms/StorageKey.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "storageKey": function() { return /* binding */ storageKey; }
/* harmony export */ });
/* harmony import */ var _util_mod_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/mod.js */ "./node_modules/capi/esm/util/mod.js");
/* harmony import */ var _sys_Atom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../sys/Atom.js */ "./node_modules/capi/esm/effect/sys/Atom.js");


const storageKey = (0,_sys_Atom_js__WEBPACK_IMPORTED_MODULE_1__.atomFactory)("StorageKey", ($storageKey, ...keys) => {
    return _util_mod_js__WEBPACK_IMPORTED_MODULE_0__.hex.encode($storageKey.encode(keys));
});
//# sourceMappingURL=StorageKey.js.map

/***/ }),

/***/ "./node_modules/capi/esm/effect/atoms/Wrap.js":
/*!****************************************************!*\
  !*** ./node_modules/capi/esm/effect/atoms/Wrap.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "wrap": function() { return /* binding */ wrap; }
/* harmony export */ });
/* harmony import */ var _sys_mod_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../sys/mod.js */ "./node_modules/capi/esm/effect/sys/mod.js");

function wrap(target, key) {
    return (0,_sys_mod_js__WEBPACK_IMPORTED_MODULE_0__.atom)("Wrap", [target, key], (target, key) => {
        return { [key]: target };
    });
}
//# sourceMappingURL=Wrap.js.map

/***/ }),

/***/ "./node_modules/capi/esm/effect/atoms/common.js":
/*!******************************************************!*\
  !*** ./node_modules/capi/esm/effect/atoms/common.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RpcError": function() { return /* binding */ RpcError; }
/* harmony export */ });
/* harmony import */ var _util_mod_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/mod.js */ "./node_modules/capi/esm/util/mod.js");

class RpcError extends _util_mod_js__WEBPACK_IMPORTED_MODULE_0__.ErrorCtor("RpcCall") {
    constructor({ code, message, attempt }) {
        super(message);
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "attempt", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.code = code;
        this.attempt = attempt;
    }
}
//# sourceMappingURL=common.js.map

/***/ }),

/***/ "./node_modules/capi/esm/effect/atoms/mod.js":
/*!***************************************************!*\
  !*** ./node_modules/capi/esm/effect/atoms/mod.js ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$extrinsic": function() { return /* reexport safe */ _$Extrinsic_js__WEBPACK_IMPORTED_MODULE_0__.$extrinsic; },
/* harmony export */   "$key": function() { return /* reexport safe */ _$Key_js__WEBPACK_IMPORTED_MODULE_1__.$key; },
/* harmony export */   "$storageKey": function() { return /* reexport safe */ _$StorageKey_js__WEBPACK_IMPORTED_MODULE_2__.$storageKey; },
/* harmony export */   "MetadataDecodeError": function() { return /* reexport safe */ _Metadata_js__WEBPACK_IMPORTED_MODULE_6__.MetadataDecodeError; },
/* harmony export */   "RpcSubscriptionError": function() { return /* reexport safe */ _RpcSubscription_js__WEBPACK_IMPORTED_MODULE_9__.RpcSubscriptionError; },
/* harmony export */   "codec": function() { return /* reexport safe */ _Codec_js__WEBPACK_IMPORTED_MODULE_3__.codec; },
/* harmony export */   "decoded": function() { return /* reexport safe */ _Decoded_js__WEBPACK_IMPORTED_MODULE_4__.decoded; },
/* harmony export */   "deriveCodec": function() { return /* reexport safe */ _DeriveCodec_js__WEBPACK_IMPORTED_MODULE_5__.deriveCodec; },
/* harmony export */   "entryMetadata": function() { return /* reexport safe */ _Metadata_js__WEBPACK_IMPORTED_MODULE_6__.entryMetadata; },
/* harmony export */   "metadata": function() { return /* reexport safe */ _Metadata_js__WEBPACK_IMPORTED_MODULE_6__.metadata; },
/* harmony export */   "palletMetadata": function() { return /* reexport safe */ _Metadata_js__WEBPACK_IMPORTED_MODULE_6__.palletMetadata; },
/* harmony export */   "parseMetadata": function() { return /* reexport safe */ _Metadata_js__WEBPACK_IMPORTED_MODULE_6__.parseMetadata; },
/* harmony export */   "rpcCall": function() { return /* reexport safe */ _RpcCall_js__WEBPACK_IMPORTED_MODULE_7__.rpcCall; },
/* harmony export */   "rpcClient": function() { return /* reexport safe */ _RpcClient_js__WEBPACK_IMPORTED_MODULE_8__.rpcClient; },
/* harmony export */   "rpcSubscription": function() { return /* reexport safe */ _RpcSubscription_js__WEBPACK_IMPORTED_MODULE_9__.rpcSubscription; },
/* harmony export */   "select": function() { return /* reexport safe */ _Select_js__WEBPACK_IMPORTED_MODULE_10__.select; },
/* harmony export */   "storageKey": function() { return /* reexport safe */ _StorageKey_js__WEBPACK_IMPORTED_MODULE_11__.storageKey; },
/* harmony export */   "wrap": function() { return /* reexport safe */ _Wrap_js__WEBPACK_IMPORTED_MODULE_12__.wrap; }
/* harmony export */ });
/* harmony import */ var _$Extrinsic_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./$Extrinsic.js */ "./node_modules/capi/esm/effect/atoms/$Extrinsic.js");
/* harmony import */ var _$Key_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./$Key.js */ "./node_modules/capi/esm/effect/atoms/$Key.js");
/* harmony import */ var _$StorageKey_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./$StorageKey.js */ "./node_modules/capi/esm/effect/atoms/$StorageKey.js");
/* harmony import */ var _Codec_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Codec.js */ "./node_modules/capi/esm/effect/atoms/Codec.js");
/* harmony import */ var _Decoded_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Decoded.js */ "./node_modules/capi/esm/effect/atoms/Decoded.js");
/* harmony import */ var _DeriveCodec_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DeriveCodec.js */ "./node_modules/capi/esm/effect/atoms/DeriveCodec.js");
/* harmony import */ var _Metadata_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Metadata.js */ "./node_modules/capi/esm/effect/atoms/Metadata.js");
/* harmony import */ var _RpcCall_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./RpcCall.js */ "./node_modules/capi/esm/effect/atoms/RpcCall.js");
/* harmony import */ var _RpcClient_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./RpcClient.js */ "./node_modules/capi/esm/effect/atoms/RpcClient.js");
/* harmony import */ var _RpcSubscription_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./RpcSubscription.js */ "./node_modules/capi/esm/effect/atoms/RpcSubscription.js");
/* harmony import */ var _Select_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Select.js */ "./node_modules/capi/esm/effect/atoms/Select.js");
/* harmony import */ var _StorageKey_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./StorageKey.js */ "./node_modules/capi/esm/effect/atoms/StorageKey.js");
/* harmony import */ var _Wrap_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Wrap.js */ "./node_modules/capi/esm/effect/atoms/Wrap.js");













//# sourceMappingURL=mod.js.map

/***/ }),

/***/ "./node_modules/capi/esm/effect/mod.js":
/*!*********************************************!*\
  !*** ./node_modules/capi/esm/effect/mod.js ***!
  \*********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$extrinsic": function() { return /* reexport safe */ _atoms_mod_js__WEBPACK_IMPORTED_MODULE_0__.$extrinsic; },
/* harmony export */   "$key": function() { return /* reexport safe */ _atoms_mod_js__WEBPACK_IMPORTED_MODULE_0__.$key; },
/* harmony export */   "$storageKey": function() { return /* reexport safe */ _atoms_mod_js__WEBPACK_IMPORTED_MODULE_0__.$storageKey; },
/* harmony export */   "Atom": function() { return /* reexport safe */ _sys_mod_js__WEBPACK_IMPORTED_MODULE_2__.Atom; },
/* harmony export */   "Effect": function() { return /* reexport safe */ _sys_mod_js__WEBPACK_IMPORTED_MODULE_2__.Effect; },
/* harmony export */   "MetadataDecodeError": function() { return /* reexport safe */ _atoms_mod_js__WEBPACK_IMPORTED_MODULE_0__.MetadataDecodeError; },
/* harmony export */   "ReadingKeysOfNonMapError": function() { return /* reexport safe */ _std_mod_js__WEBPACK_IMPORTED_MODULE_1__.ReadingKeysOfNonMapError; },
/* harmony export */   "RpcSubscriptionError": function() { return /* reexport safe */ _atoms_mod_js__WEBPACK_IMPORTED_MODULE_0__.RpcSubscriptionError; },
/* harmony export */   "all": function() { return /* reexport safe */ _sys_mod_js__WEBPACK_IMPORTED_MODULE_2__.all; },
/* harmony export */   "anon": function() { return /* reexport safe */ _sys_mod_js__WEBPACK_IMPORTED_MODULE_2__.anon; },
/* harmony export */   "atom": function() { return /* reexport safe */ _sys_mod_js__WEBPACK_IMPORTED_MODULE_2__.atom; },
/* harmony export */   "atomFactory": function() { return /* reexport safe */ _sys_mod_js__WEBPACK_IMPORTED_MODULE_2__.atomFactory; },
/* harmony export */   "codec": function() { return /* reexport safe */ _atoms_mod_js__WEBPACK_IMPORTED_MODULE_0__.codec; },
/* harmony export */   "decoded": function() { return /* reexport safe */ _atoms_mod_js__WEBPACK_IMPORTED_MODULE_0__.decoded; },
/* harmony export */   "deriveCodec": function() { return /* reexport safe */ _atoms_mod_js__WEBPACK_IMPORTED_MODULE_0__.deriveCodec; },
/* harmony export */   "entryMetadata": function() { return /* reexport safe */ _atoms_mod_js__WEBPACK_IMPORTED_MODULE_0__.entryMetadata; },
/* harmony export */   "into": function() { return /* reexport safe */ _sys_mod_js__WEBPACK_IMPORTED_MODULE_2__.into; },
/* harmony export */   "metadata": function() { return /* reexport safe */ _atoms_mod_js__WEBPACK_IMPORTED_MODULE_0__.metadata; },
/* harmony export */   "palletMetadata": function() { return /* reexport safe */ _atoms_mod_js__WEBPACK_IMPORTED_MODULE_0__.palletMetadata; },
/* harmony export */   "parseMetadata": function() { return /* reexport safe */ _atoms_mod_js__WEBPACK_IMPORTED_MODULE_0__.parseMetadata; },
/* harmony export */   "readBlock": function() { return /* reexport safe */ _std_mod_js__WEBPACK_IMPORTED_MODULE_1__.readBlock; },
/* harmony export */   "readEntry": function() { return /* reexport safe */ _std_mod_js__WEBPACK_IMPORTED_MODULE_1__.readEntry; },
/* harmony export */   "readKeyPage": function() { return /* reexport safe */ _std_mod_js__WEBPACK_IMPORTED_MODULE_1__.readKeyPage; },
/* harmony export */   "rpcCall": function() { return /* reexport safe */ _atoms_mod_js__WEBPACK_IMPORTED_MODULE_0__.rpcCall; },
/* harmony export */   "rpcClient": function() { return /* reexport safe */ _atoms_mod_js__WEBPACK_IMPORTED_MODULE_0__.rpcClient; },
/* harmony export */   "rpcSubscription": function() { return /* reexport safe */ _atoms_mod_js__WEBPACK_IMPORTED_MODULE_0__.rpcSubscription; },
/* harmony export */   "run": function() { return /* reexport safe */ _sys_mod_js__WEBPACK_IMPORTED_MODULE_2__.run; },
/* harmony export */   "select": function() { return /* reexport safe */ _atoms_mod_js__WEBPACK_IMPORTED_MODULE_0__.select; },
/* harmony export */   "sendAndWatchExtrinsic": function() { return /* reexport safe */ _std_mod_js__WEBPACK_IMPORTED_MODULE_1__.sendAndWatchExtrinsic; },
/* harmony export */   "storageKey": function() { return /* reexport safe */ _atoms_mod_js__WEBPACK_IMPORTED_MODULE_0__.storageKey; },
/* harmony export */   "watchBlocks": function() { return /* reexport safe */ _std_mod_js__WEBPACK_IMPORTED_MODULE_1__.watchBlocks; },
/* harmony export */   "watchEntry": function() { return /* reexport safe */ _std_mod_js__WEBPACK_IMPORTED_MODULE_1__.watchEntry; },
/* harmony export */   "wrap": function() { return /* reexport safe */ _atoms_mod_js__WEBPACK_IMPORTED_MODULE_0__.wrap; }
/* harmony export */ });
/* harmony import */ var _atoms_mod_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./atoms/mod.js */ "./node_modules/capi/esm/effect/atoms/mod.js");
/* harmony import */ var _std_mod_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./std/mod.js */ "./node_modules/capi/esm/effect/std/mod.js");
/* harmony import */ var _sys_mod_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sys/mod.js */ "./node_modules/capi/esm/effect/sys/mod.js");



//# sourceMappingURL=mod.js.map

/***/ }),

/***/ "./node_modules/capi/esm/effect/std/mod.js":
/*!*************************************************!*\
  !*** ./node_modules/capi/esm/effect/std/mod.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ReadingKeysOfNonMapError": function() { return /* reexport safe */ _readKeyPage_js__WEBPACK_IMPORTED_MODULE_2__.ReadingKeysOfNonMapError; },
/* harmony export */   "readBlock": function() { return /* reexport safe */ _readBlock_js__WEBPACK_IMPORTED_MODULE_0__.readBlock; },
/* harmony export */   "readEntry": function() { return /* reexport safe */ _readEntry_js__WEBPACK_IMPORTED_MODULE_1__.readEntry; },
/* harmony export */   "readKeyPage": function() { return /* reexport safe */ _readKeyPage_js__WEBPACK_IMPORTED_MODULE_2__.readKeyPage; },
/* harmony export */   "sendAndWatchExtrinsic": function() { return /* reexport safe */ _submitAndWatchExtrinsic_js__WEBPACK_IMPORTED_MODULE_3__.sendAndWatchExtrinsic; },
/* harmony export */   "watchBlocks": function() { return /* reexport safe */ _watchBlocks_js__WEBPACK_IMPORTED_MODULE_4__.watchBlocks; },
/* harmony export */   "watchEntry": function() { return /* reexport safe */ _watchEntry_js__WEBPACK_IMPORTED_MODULE_5__.watchEntry; }
/* harmony export */ });
/* harmony import */ var _readBlock_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./readBlock.js */ "./node_modules/capi/esm/effect/std/readBlock.js");
/* harmony import */ var _readEntry_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./readEntry.js */ "./node_modules/capi/esm/effect/std/readEntry.js");
/* harmony import */ var _readKeyPage_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./readKeyPage.js */ "./node_modules/capi/esm/effect/std/readKeyPage.js");
/* harmony import */ var _submitAndWatchExtrinsic_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./submitAndWatchExtrinsic.js */ "./node_modules/capi/esm/effect/std/submitAndWatchExtrinsic.js");
/* harmony import */ var _watchBlocks_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./watchBlocks.js */ "./node_modules/capi/esm/effect/std/watchBlocks.js");
/* harmony import */ var _watchEntry_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./watchEntry.js */ "./node_modules/capi/esm/effect/std/watchEntry.js");






//# sourceMappingURL=mod.js.map

/***/ }),

/***/ "./node_modules/capi/esm/effect/std/readBlock.js":
/*!*******************************************************!*\
  !*** ./node_modules/capi/esm/effect/std/readBlock.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "readBlock": function() { return /* binding */ readBlock; }
/* harmony export */ });
/* harmony import */ var _util_mod_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/mod.js */ "./node_modules/capi/esm/util/mod.js");
/* harmony import */ var _atoms_mod_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../atoms/mod.js */ "./node_modules/capi/esm/effect/atoms/mod.js");
/* harmony import */ var _sys_mod_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../sys/mod.js */ "./node_modules/capi/esm/effect/sys/mod.js");



function readBlock(config, ...[blockHash]) {
    const metadata_ = _atoms_mod_js__WEBPACK_IMPORTED_MODULE_1__.metadata(config, blockHash);
    const $extrinsic = _atoms_mod_js__WEBPACK_IMPORTED_MODULE_1__.$extrinsic(_atoms_mod_js__WEBPACK_IMPORTED_MODULE_1__.deriveCodec(metadata_), metadata_);
    const call = _atoms_mod_js__WEBPACK_IMPORTED_MODULE_1__.rpcCall(config, "chain_getBlock", [blockHash]);
    const decoded = _sys_mod_js__WEBPACK_IMPORTED_MODULE_2__.anon([$extrinsic, call], ($extrinsic, call) => {
        const { block: { extrinsics, header }, justifications } = call.result;
        return {
            justifications,
            block: {
                header,
                extrinsics: extrinsics.map((extrinsic) => {
                    return $extrinsic.decode(_util_mod_js__WEBPACK_IMPORTED_MODULE_0__.hex.decode(extrinsic));
                }),
            },
        };
    });
    return _atoms_mod_js__WEBPACK_IMPORTED_MODULE_1__.wrap(decoded, "block");
}
//# sourceMappingURL=readBlock.js.map

/***/ }),

/***/ "./node_modules/capi/esm/effect/std/readEntry.js":
/*!*******************************************************!*\
  !*** ./node_modules/capi/esm/effect/std/readEntry.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "readEntry": function() { return /* binding */ readEntry; }
/* harmony export */ });
/* harmony import */ var _atoms_mod_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../atoms/mod.js */ "./node_modules/capi/esm/effect/atoms/mod.js");

function readEntry(config, palletName, entryName, keys, ...[blockHash]) {
    const metadata_ = _atoms_mod_js__WEBPACK_IMPORTED_MODULE_0__.metadata(config, blockHash);
    const deriveCodec_ = _atoms_mod_js__WEBPACK_IMPORTED_MODULE_0__.deriveCodec(metadata_);
    const palletMetadata_ = _atoms_mod_js__WEBPACK_IMPORTED_MODULE_0__.palletMetadata(metadata_, palletName);
    const entryMetadata_ = _atoms_mod_js__WEBPACK_IMPORTED_MODULE_0__.entryMetadata(palletMetadata_, entryName);
    const $storageKey = _atoms_mod_js__WEBPACK_IMPORTED_MODULE_0__.$storageKey(deriveCodec_, palletMetadata_, entryMetadata_);
    const storageKey = _atoms_mod_js__WEBPACK_IMPORTED_MODULE_0__.storageKey($storageKey, ...keys);
    const storageCall = _atoms_mod_js__WEBPACK_IMPORTED_MODULE_0__.rpcCall(config, "state_getStorage", [storageKey, blockHash]);
    const entryValueTypeI = _atoms_mod_js__WEBPACK_IMPORTED_MODULE_0__.select(entryMetadata_, "value");
    const $entry = _atoms_mod_js__WEBPACK_IMPORTED_MODULE_0__.codec(deriveCodec_, entryValueTypeI);
    const resultHex = _atoms_mod_js__WEBPACK_IMPORTED_MODULE_0__.select(storageCall, "result");
    return _atoms_mod_js__WEBPACK_IMPORTED_MODULE_0__.decoded($entry, resultHex, "value");
}
//# sourceMappingURL=readEntry.js.map

/***/ }),

/***/ "./node_modules/capi/esm/effect/std/readKeyPage.js":
/*!*********************************************************!*\
  !*** ./node_modules/capi/esm/effect/std/readKeyPage.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ReadingKeysOfNonMapError": function() { return /* binding */ ReadingKeysOfNonMapError; },
/* harmony export */   "readKeyPage": function() { return /* binding */ readKeyPage; }
/* harmony export */ });
/* harmony import */ var _util_mod_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/mod.js */ "./node_modules/capi/esm/util/mod.js");
/* harmony import */ var _atoms_mod_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../atoms/mod.js */ "./node_modules/capi/esm/effect/atoms/mod.js");
/* harmony import */ var _sys_mod_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../sys/mod.js */ "./node_modules/capi/esm/effect/sys/mod.js");



function readKeyPage(config, palletName, entryName, count, ...[start, blockHash]) {
    const metadata = _atoms_mod_js__WEBPACK_IMPORTED_MODULE_1__.metadata(config, blockHash);
    const deriveCodec = _atoms_mod_js__WEBPACK_IMPORTED_MODULE_1__.deriveCodec(metadata);
    const palletMetadata = _atoms_mod_js__WEBPACK_IMPORTED_MODULE_1__.palletMetadata(metadata, palletName);
    const entryMetadata = _sys_mod_js__WEBPACK_IMPORTED_MODULE_2__.anon([_atoms_mod_js__WEBPACK_IMPORTED_MODULE_1__.entryMetadata(palletMetadata, entryName)], (entryMetadata) => {
        if (entryMetadata.type !== "Map") {
            return new ReadingKeysOfNonMapError();
        }
        return entryMetadata;
    });
    const $storageKey = _atoms_mod_js__WEBPACK_IMPORTED_MODULE_1__.$storageKey(deriveCodec, palletMetadata, entryMetadata);
    const startKey = start ? _atoms_mod_js__WEBPACK_IMPORTED_MODULE_1__.storageKey($storageKey, start) : undefined;
    const storageKey = _atoms_mod_js__WEBPACK_IMPORTED_MODULE_1__.storageKey($storageKey);
    const call = _atoms_mod_js__WEBPACK_IMPORTED_MODULE_1__.rpcCall(config, "state_getKeysPaged", [storageKey, count, startKey, blockHash]);
    const $key = _atoms_mod_js__WEBPACK_IMPORTED_MODULE_1__.$key(deriveCodec, palletMetadata, entryMetadata);
    const keysEncoded = _atoms_mod_js__WEBPACK_IMPORTED_MODULE_1__.select(call, "result");
    const keysDecoded = _sys_mod_js__WEBPACK_IMPORTED_MODULE_2__.anon([$key, keysEncoded], ($key, keysEncoded) => {
        return keysEncoded.map((keyEncoded) => {
            return $key.decode(_util_mod_js__WEBPACK_IMPORTED_MODULE_0__.hex.decode(keyEncoded));
        });
    });
    return _atoms_mod_js__WEBPACK_IMPORTED_MODULE_1__.wrap(keysDecoded, "keys");
}
class ReadingKeysOfNonMapError extends _util_mod_js__WEBPACK_IMPORTED_MODULE_0__.ErrorCtor("ReadingKeysOfNonMap") {
}
//# sourceMappingURL=readKeyPage.js.map

/***/ }),

/***/ "./node_modules/capi/esm/effect/std/submitAndWatchExtrinsic.js":
/*!*********************************************************************!*\
  !*** ./node_modules/capi/esm/effect/std/submitAndWatchExtrinsic.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sendAndWatchExtrinsic": function() { return /* binding */ sendAndWatchExtrinsic; }
/* harmony export */ });
/* harmony import */ var _deps_std_testing_asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../deps/std/testing/asserts.js */ "./node_modules/capi/esm/deps/std/testing/asserts.js");
/* harmony import */ var _ss58_mod_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../ss58/mod.js */ "./node_modules/capi/esm/ss58/mod.js");
/* harmony import */ var _util_mod_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/mod.js */ "./node_modules/capi/esm/util/mod.js");
/* harmony import */ var _atoms_mod_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../atoms/mod.js */ "./node_modules/capi/esm/effect/atoms/mod.js");
/* harmony import */ var _sys_mod_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../sys/mod.js */ "./node_modules/capi/esm/effect/sys/mod.js");





function sendAndWatchExtrinsic(props) {
    const metadata = _atoms_mod_js__WEBPACK_IMPORTED_MODULE_3__.metadata(props.config);
    const deriveCodec = _atoms_mod_js__WEBPACK_IMPORTED_MODULE_3__.deriveCodec(metadata);
    const $extrinsic = _atoms_mod_js__WEBPACK_IMPORTED_MODULE_3__.$extrinsic(deriveCodec, metadata, props.sign, props.config.addressPrefix);
    const runtimeVersion = _atoms_mod_js__WEBPACK_IMPORTED_MODULE_3__.rpcCall(props.config, "state_getRuntimeVersion", []);
    const senderSs58 = _sys_mod_js__WEBPACK_IMPORTED_MODULE_4__.anon([props.sender], (sender) => {
        return (() => {
            switch (sender.type) {
                case "Id": {
                    return _ss58_mod_js__WEBPACK_IMPORTED_MODULE_1__.encode(props.config.addressPrefix, sender.value);
                }
                // TODO: other types
                default: {
                    (0,_deps_std_testing_asserts_js__WEBPACK_IMPORTED_MODULE_0__.unimplemented)();
                }
            }
        })();
    });
    const accountNextIndex = _atoms_mod_js__WEBPACK_IMPORTED_MODULE_3__.rpcCall(props.config, "system_accountNextIndex", [senderSs58]);
    const genesisHash = _sys_mod_js__WEBPACK_IMPORTED_MODULE_4__.anon([_atoms_mod_js__WEBPACK_IMPORTED_MODULE_3__.rpcCall(props.config, "chain_getBlockHash", [0])], ({ result }) => {
        return _util_mod_js__WEBPACK_IMPORTED_MODULE_2__.hex.decode(result);
    });
    const checkpointHash = props.checkpoint
        ? _sys_mod_js__WEBPACK_IMPORTED_MODULE_4__.anon([props.checkpoint], (v) => {
            return _util_mod_js__WEBPACK_IMPORTED_MODULE_2__.hex.decode(v);
        })
        : genesisHash;
    const extrinsicHex = _sys_mod_js__WEBPACK_IMPORTED_MODULE_4__.anon([
        $extrinsic,
        props.sender,
        props.methodName,
        props.palletName,
        runtimeVersion,
        accountNextIndex,
        genesisHash,
        props.args,
        checkpointHash,
        props.tip,
        props.mortality,
    ], async ($extrinsic, sender, methodName, palletName, { result: { specVersion, transactionVersion } }, { result: nonce }, genesisHash, args, checkpoint, tip, mortality) => {
        const extrinsicBytes = await $extrinsic.encodeAsync({
            protocolVersion: 4,
            palletName,
            methodName,
            args,
            signature: {
                address: sender,
                extra: [
                    mortality
                        ? {
                            type: "Mortal",
                            value: mortality,
                        }
                        : { type: "Immortal" },
                    nonce,
                    tip || 0,
                ],
                additional: [specVersion, transactionVersion, checkpoint, genesisHash],
            },
        });
        return _util_mod_js__WEBPACK_IMPORTED_MODULE_2__.hex.encode(extrinsicBytes);
    });
    return _atoms_mod_js__WEBPACK_IMPORTED_MODULE_3__.rpcSubscription(props.config, "author_submitAndWatchExtrinsic", [extrinsicHex], props.createWatchHandler, (ok) => {
        return _atoms_mod_js__WEBPACK_IMPORTED_MODULE_3__.rpcCall(props.config, "author_unwatchExtrinsic", [ok.result]);
    });
}
//# sourceMappingURL=submitAndWatchExtrinsic.js.map

/***/ }),

/***/ "./node_modules/capi/esm/effect/std/watchBlocks.js":
/*!*********************************************************!*\
  !*** ./node_modules/capi/esm/effect/std/watchBlocks.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "watchBlocks": function() { return /* binding */ watchBlocks; }
/* harmony export */ });
/* harmony import */ var _util_mod_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/mod.js */ "./node_modules/capi/esm/util/mod.js");
/* harmony import */ var _atoms_mod_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../atoms/mod.js */ "./node_modules/capi/esm/effect/atoms/mod.js");
/* harmony import */ var _readBlock_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./readBlock.js */ "./node_modules/capi/esm/effect/std/readBlock.js");



function watchBlocks(config, createWatchHandler) {
    return _atoms_mod_js__WEBPACK_IMPORTED_MODULE_1__.rpcSubscription(config, "chain_subscribeNewHeads", [], (stop) => {
        const watchHandler = createWatchHandler(stop);
        return async (result) => {
            const blockNum = result.params.result.number;
            const blockHash = _atoms_mod_js__WEBPACK_IMPORTED_MODULE_1__.rpcCall(config, "chain_getBlockHash", [blockNum])
                .select("result");
            const block = _util_mod_js__WEBPACK_IMPORTED_MODULE_0__.throwIfError(
            // STOP THIS MADNESS
            await (0,_readBlock_js__WEBPACK_IMPORTED_MODULE_2__.readBlock)(config, blockHash).run());
            watchHandler(block.block);
        };
    }, (ok) => {
        return _atoms_mod_js__WEBPACK_IMPORTED_MODULE_1__.rpcCall(config, "chain_unsubscribeNewHead", [ok.result]);
    });
}
//# sourceMappingURL=watchBlocks.js.map

/***/ }),

/***/ "./node_modules/capi/esm/effect/std/watchEntry.js":
/*!********************************************************!*\
  !*** ./node_modules/capi/esm/effect/std/watchEntry.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "watchEntry": function() { return /* binding */ watchEntry; }
/* harmony export */ });
/* harmony import */ var _util_mod_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/mod.js */ "./node_modules/capi/esm/util/mod.js");
/* harmony import */ var _atoms_mod_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../atoms/mod.js */ "./node_modules/capi/esm/effect/atoms/mod.js");
/* harmony import */ var _sys_mod_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../sys/mod.js */ "./node_modules/capi/esm/effect/sys/mod.js");



function watchEntry(config, palletName, entryName, keys, createWatchHandler) {
    const metadata_ = _atoms_mod_js__WEBPACK_IMPORTED_MODULE_1__.metadata(config);
    const deriveCodec_ = _atoms_mod_js__WEBPACK_IMPORTED_MODULE_1__.deriveCodec(metadata_);
    const palletMetadata_ = _atoms_mod_js__WEBPACK_IMPORTED_MODULE_1__.palletMetadata(metadata_, palletName);
    const entryMetadata_ = _atoms_mod_js__WEBPACK_IMPORTED_MODULE_1__.entryMetadata(palletMetadata_, entryName);
    const $storageKey = _atoms_mod_js__WEBPACK_IMPORTED_MODULE_1__.$storageKey(deriveCodec_, palletMetadata_, entryMetadata_);
    const entryValueTypeI = _atoms_mod_js__WEBPACK_IMPORTED_MODULE_1__.select(entryMetadata_, "value");
    const $entry = _atoms_mod_js__WEBPACK_IMPORTED_MODULE_1__.codec(deriveCodec_, entryValueTypeI);
    const storageKeys = keys.length === 0
        ? _sys_mod_js__WEBPACK_IMPORTED_MODULE_2__.anon([_atoms_mod_js__WEBPACK_IMPORTED_MODULE_1__.storageKey($storageKey)], (v) => [v])
        : _sys_mod_js__WEBPACK_IMPORTED_MODULE_2__.anon([_atoms_mod_js__WEBPACK_IMPORTED_MODULE_1__.storageKey($storageKey, keys)], (v) => [v]);
    return _sys_mod_js__WEBPACK_IMPORTED_MODULE_2__.into([$entry], ($entryCodec) => {
        const watchInit = _util_mod_js__WEBPACK_IMPORTED_MODULE_0__.mapCreateWatchHandler(createWatchHandler, (message) => {
            return message.params.result.changes.map(([key, val]) => {
                return [key, val ? $entryCodec.decode(_util_mod_js__WEBPACK_IMPORTED_MODULE_0__.hex.decode(val)) : undefined];
            });
        });
        return _atoms_mod_js__WEBPACK_IMPORTED_MODULE_1__.rpcSubscription(config, "state_subscribeStorage", [storageKeys], watchInit, (ok) => {
            return _atoms_mod_js__WEBPACK_IMPORTED_MODULE_1__.rpcCall(config, "state_unsubscribeStorage", [ok.result]);
        });
    });
}
//# sourceMappingURL=watchEntry.js.map

/***/ }),

/***/ "./node_modules/capi/esm/effect/sys/Atom.js":
/*!**************************************************!*\
  !*** ./node_modules/capi/esm/effect/sys/Atom.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Atom": function() { return /* binding */ Atom; },
/* harmony export */   "all": function() { return /* binding */ all; },
/* harmony export */   "anon": function() { return /* binding */ anon; },
/* harmony export */   "atom": function() { return /* binding */ atom; },
/* harmony export */   "atomFactory": function() { return /* binding */ atomFactory; },
/* harmony export */   "into": function() { return /* binding */ into; }
/* harmony export */ });
/* harmony import */ var _atoms_Select_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../atoms/Select.js */ "./node_modules/capi/esm/effect/atoms/Select.js");
/* harmony import */ var _Effect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Effect.js */ "./node_modules/capi/esm/effect/sys/Effect.js");
/* harmony import */ var _key_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./key.js */ "./node_modules/capi/esm/effect/sys/key.js");
/* harmony import */ var _run_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./run.js */ "./node_modules/capi/esm/effect/sys/run.js");




function atom(fqn, args, impl, exit) {
    return new Atom(fqn, args, impl, exit);
}
class Atom extends _Effect_js__WEBPACK_IMPORTED_MODULE_1__.Effect {
    constructor(fqn, args, impl, exit) {
        super(fqn);
        Object.defineProperty(this, "args", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: args
        });
        Object.defineProperty(this, "impl", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: impl
        });
        Object.defineProperty(this, "exit", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: exit
        });
    }
    select(field) {
        return (0,_atoms_Select_js__WEBPACK_IMPORTED_MODULE_0__.select)(this, field);
    }
    run() {
        return (0,_run_js__WEBPACK_IMPORTED_MODULE_3__.run)(this);
    }
}
function atomFactory(fqn, impl, exit) {
    return (...args) => {
        return new Atom(fqn, args, impl, exit);
    };
}
function anon(args, impl, exit) {
    return new Atom((0,_key_js__WEBPACK_IMPORTED_MODULE_2__.key)(impl), args, impl, exit);
}
function into(args, into) {
    return new Atom("Map", args, async function (...args) {
        const next = await into.bind(this)(...args);
        if (next instanceof Error) {
            return next;
        }
        return await this.run(next);
    });
}
function all(...effects) {
    return new Atom("All", effects, (...resolved) => {
        return resolved;
    });
}
//# sourceMappingURL=Atom.js.map

/***/ }),

/***/ "./node_modules/capi/esm/effect/sys/Effect.js":
/*!****************************************************!*\
  !*** ./node_modules/capi/esm/effect/sys/Effect.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Effect": function() { return /* binding */ Effect; }
/* harmony export */ });
class Effect {
    constructor(fqn) {
        Object.defineProperty(this, "fqn", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: fqn
        });
    }
}
//# sourceMappingURL=Effect.js.map

/***/ }),

/***/ "./node_modules/capi/esm/effect/sys/key.js":
/*!*************************************************!*\
  !*** ./node_modules/capi/esm/effect/sys/key.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "key": function() { return /* binding */ key; }
/* harmony export */ });
/* harmony import */ var _Atom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Atom.js */ "./node_modules/capi/esm/effect/sys/Atom.js");

let i = 0; // TODO: make fqn optional
const refKeys = new Map();
function key(val) {
    let refKey = refKeys.get(val);
    if (refKey) {
        return refKey;
    }
    if (val instanceof _Atom_js__WEBPACK_IMPORTED_MODULE_0__.Atom) {
        refKey = `${val.fqn}(${val.args.map(key)})`;
        refKeys.set(val, refKey);
        return refKey;
    }
    refKey = `_${i++}`;
    refKeys.set(val, refKey);
    return refKey;
}
//# sourceMappingURL=key.js.map

/***/ }),

/***/ "./node_modules/capi/esm/effect/sys/mod.js":
/*!*************************************************!*\
  !*** ./node_modules/capi/esm/effect/sys/mod.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Atom": function() { return /* reexport safe */ _Atom_js__WEBPACK_IMPORTED_MODULE_0__.Atom; },
/* harmony export */   "Effect": function() { return /* reexport safe */ _Effect_js__WEBPACK_IMPORTED_MODULE_1__.Effect; },
/* harmony export */   "all": function() { return /* reexport safe */ _Atom_js__WEBPACK_IMPORTED_MODULE_0__.all; },
/* harmony export */   "anon": function() { return /* reexport safe */ _Atom_js__WEBPACK_IMPORTED_MODULE_0__.anon; },
/* harmony export */   "atom": function() { return /* reexport safe */ _Atom_js__WEBPACK_IMPORTED_MODULE_0__.atom; },
/* harmony export */   "atomFactory": function() { return /* reexport safe */ _Atom_js__WEBPACK_IMPORTED_MODULE_0__.atomFactory; },
/* harmony export */   "into": function() { return /* reexport safe */ _Atom_js__WEBPACK_IMPORTED_MODULE_0__.into; },
/* harmony export */   "run": function() { return /* reexport safe */ _run_js__WEBPACK_IMPORTED_MODULE_2__.run; }
/* harmony export */ });
/* harmony import */ var _Atom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Atom.js */ "./node_modules/capi/esm/effect/sys/Atom.js");
/* harmony import */ var _Effect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Effect.js */ "./node_modules/capi/esm/effect/sys/Effect.js");
/* harmony import */ var _run_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./run.js */ "./node_modules/capi/esm/effect/sys/run.js");



//# sourceMappingURL=mod.js.map

/***/ }),

/***/ "./node_modules/capi/esm/effect/sys/run.js":
/*!*************************************************!*\
  !*** ./node_modules/capi/esm/effect/sys/run.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "run": function() { return /* binding */ run; }
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/capi/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _Atom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Atom.js */ "./node_modules/capi/esm/effect/sys/Atom.js");
/* harmony import */ var _key_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./key.js */ "./node_modules/capi/esm/effect/sys/key.js");
var _Runtime_cache, _a;



const { run } = (new (_a = class Runtime {
        constructor() {
            _Runtime_cache.set(this, new Map()); // TODO: set max size / use LRU
            Object.defineProperty(this, "run", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: async (root) => {
                    const dependents = new Map();
                    const cleanup = new Map();
                    const cleanupPending = [];
                    try {
                        const rootResult = await this.visit(root, dependents, cleanup);
                        for (const [k, v] of dependents) {
                            const c = cleanup.get(k);
                            if (c) {
                                cleanupPending.push((async () => {
                                    await Promise.all(v);
                                    await c();
                                })());
                            }
                        }
                        await Promise.all(cleanupPending);
                        return rootResult;
                    }
                    catch (e) {
                        return e;
                    }
                }
            });
            Object.defineProperty(this, "visit", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: (val, dependents, cleanup) => {
                    const k = (0,_key_js__WEBPACK_IMPORTED_MODULE_1__.key)(val);
                    if ((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__classPrivateFieldGet)(this, _Runtime_cache, "f").has(k)) {
                        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__classPrivateFieldGet)(this, _Runtime_cache, "f").get(k);
                    }
                    if (val instanceof _Atom_js__WEBPACK_IMPORTED_MODULE_0__.Atom) {
                        return (async () => {
                            const args = val.args;
                            const argsPending = Promise.all(args.map((arg) => {
                                return this.visit(arg, dependents, cleanup);
                            }));
                            const pending = argsPending.then((argsResolved) => {
                                return val.impl.bind(this)(...argsResolved);
                            });
                            (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__classPrivateFieldGet)(this, _Runtime_cache, "f").set(k, pending);
                            args.forEach((arg) => {
                                if (arg instanceof _Atom_js__WEBPACK_IMPORTED_MODULE_0__.Atom) {
                                    this.addDependent(dependents, pending, arg);
                                }
                            });
                            const resolved = await pending;
                            if (resolved instanceof Error) {
                                throw resolved;
                            }
                            if (val.exit) {
                                const applied = () => val.exit(resolved);
                                cleanup.set(val, applied);
                                (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__classPrivateFieldGet)(this, _Runtime_cache, "f").delete(k);
                            }
                            return resolved;
                        })();
                    }
                    return val;
                }
            });
            Object.defineProperty(this, "addDependent", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: (dependents, dependency, dependent) => {
                    let e = dependents.get(dependent);
                    if (e) {
                        e.push(dependency);
                    }
                    else {
                        e = [dependency];
                        dependents.set(dependent, e);
                    }
                }
            });
        }
    },
    _Runtime_cache = new WeakMap(),
    _a)());
//# sourceMappingURL=run.js.map

/***/ }),

/***/ "./node_modules/capi/esm/frame_metadata/Codec.js":
/*!*******************************************************!*\
  !*** ./node_modules/capi/esm/frame_metadata/Codec.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$null": function() { return /* binding */ $null; },
/* harmony export */   "ChainError": function() { return /* binding */ ChainError; },
/* harmony export */   "DeriveCodec": function() { return /* binding */ DeriveCodec; }
/* harmony export */ });
/* harmony import */ var _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../deps/scale.js */ "./node_modules/capi/esm/deps/scale.js");
/* harmony import */ var _Era_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Era.js */ "./node_modules/capi/esm/frame_metadata/Era.js");
/* harmony import */ var _TyVisitor_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TyVisitor.js */ "./node_modules/capi/esm/frame_metadata/TyVisitor.js");



/**
 * All derived codecs for ZSTs will use this exact codec,
 * so `derivedCodec === $null` is true iff the type is a ZST.
 */
const $null = _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.dummy(null);
// TODO: tuple/array element skip optimization
function DeriveCodec(tys) {
    const visitor = new _TyVisitor_js__WEBPACK_IMPORTED_MODULE_2__.TyVisitor(tys, {
        unitStruct() {
            return $null;
        },
        wrapperStruct(_ty, inner) {
            return this.visit(inner);
        },
        tupleStruct(_ty, members) {
            return _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.tuple(...members.map((x) => this.visit(x)));
        },
        objectStruct(ty) {
            return _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.object(...ty.fields.map((x) => [x.name, this.visit(x.ty)]));
        },
        option(_ty, some) {
            return _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.option(this.visit(some));
        },
        result(_ty, ok, err) {
            return _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.result(this.visit(ok), _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.instance(ChainError, ["value", this.visit(err)]));
        },
        never() {
            return _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.never;
        },
        stringUnion(ty) {
            const members = {};
            for (const { index, name } of ty.members) {
                members[index] = name;
            }
            return _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.stringUnion(members);
        },
        taggedUnion(ty) {
            const members = {};
            for (const { fields, name: type, index } of ty.members) {
                let member;
                if (fields.length === 0) {
                    member = [type];
                }
                else if (fields[0].name === undefined) {
                    // Tuple variant
                    const $value = fields.length === 1
                        ? this.visit(fields[0].ty)
                        : _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.tuple(...fields.map((f) => this.visit(f.ty)));
                    member = [type, ["value", $value]];
                }
                else {
                    // Object variant
                    const memberFields = fields.map((field, i) => {
                        return [
                            field.name || i,
                            _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.deferred(() => {
                                return this.visit(field.ty);
                            }),
                        ];
                    });
                    member = [type, ...memberFields];
                }
                members[index] = member;
            }
            return _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.taggedUnion("type", members);
        },
        uint8Array() {
            return _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.uint8Array;
        },
        array(ty) {
            return _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.array(this.visit(ty.typeParam));
        },
        sizedUint8Array(ty) {
            return _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.sizedUint8Array(ty.len);
        },
        sizedArray(ty) {
            return _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.sizedArray(this.visit(ty.typeParam), ty.len);
        },
        primitive(ty) {
            if (ty.kind === "char")
                return _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.str;
            return _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__[ty.kind];
        },
        compact(ty) {
            const inner = this.visit(ty.typeParam);
            return compactCodecVisitor.visit(inner);
        },
        bitSequence() {
            return _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.bitSequence;
        },
        map(_ty, key, val) {
            return _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.map(this.visit(key), this.visit(val));
        },
        set(_ty, val) {
            return _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.set(this.visit(val));
        },
        era() {
            return _Era_js__WEBPACK_IMPORTED_MODULE_1__.$era;
        },
        lenPrefixedWrapper(_ty, inner) {
            return _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.lenPrefixed(this.visit(inner));
        },
        circular(ty) {
            return _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.deferred(() => this.cache[ty.id]);
        },
    });
    return (ty) => visitor.visit(ty);
}
class ChainError extends Error {
    constructor(value) {
        super();
        Object.defineProperty(this, "value", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: value
        });
    }
}
const compactCodecVisitor = new _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.CodecVisitor()
    .add($null, () => $null)
    .add(_deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.u8, () => _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.compactU8)
    .add(_deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.u16, () => _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.compactU16)
    .add(_deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.u32, () => _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.compactU32)
    .add(_deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.u64, () => _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.compactU64)
    .add(_deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.u128, () => _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.compactU128)
    .add(_deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.u256, () => _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.compactU256);
//# sourceMappingURL=Codec.js.map

/***/ }),

/***/ "./node_modules/capi/esm/frame_metadata/Contract.js":
/*!**********************************************************!*\
  !*** ./node_modules/capi/esm/frame_metadata/Contract.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ContractMetadata": function() { return /* binding */ ContractMetadata; }
/* harmony export */ });
/* harmony import */ var _deps_std_testing_asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../deps/std/testing/asserts.js */ "./node_modules/capi/esm/deps/std/testing/asserts.js");

var ContractMetadata;
(function (ContractMetadata) {
    // TODO: stricter typings? Not the most necessary atm.
    function fromRawTy({ type: { def, params, path }, id }) {
        return {
            id,
            path,
            params: params ? normalizeFields(params) : [],
            // TODO: grab this from appropriate loc
            docs: [],
            ...(() => {
                if (def.primitive) {
                    return {
                        type: "Primitive",
                        kind: def.primitive,
                    };
                }
                else if (def.composite) {
                    return {
                        type: "Struct",
                        fields: normalizeFields(def.composite.fields),
                    };
                }
                else if (def.variant) {
                    return {
                        type: "Union",
                        members: def.variant.variants.map((variant) => {
                            const { fields, ...rest } = variant;
                            const member = {
                                fields: fields ? normalizeFields(fields) : [],
                                ...rest,
                            };
                            return member;
                        }),
                    };
                }
                else if (def.tuple) {
                    return {
                        type: "Tuple",
                        fields: def.tuple,
                    };
                }
                else if (def.array) {
                    return {
                        type: "SizedArray",
                        len: def.array.len,
                        typeParam: def.array.type,
                    };
                }
                else if (def.sequence) {
                    return {
                        type: "Sequence",
                        typeParam: def.sequence.type,
                    };
                }
                else if (def.compact) {
                    return {
                        type: "Compact",
                        typeParam: def.compact.typeParam,
                    };
                }
                else if (def.bitSequence) {
                    return {
                        type: "BitSequence",
                        bitOrderType: def.bitSequence.bitOrderType,
                        bitStoreType: def.bitSequence.bitStoreType,
                    };
                }
                (0,_deps_std_testing_asserts_js__WEBPACK_IMPORTED_MODULE_0__.unreachable)();
            })(),
        };
    }
    ContractMetadata.fromRawTy = fromRawTy;
    function normalizeFields(fields) {
        return fields.map(({ type: ty, ...rest }) => {
            return { ty, ...rest };
        });
    }
    function normalize({ V3: { types, ...v3Rest }, ...topLevelRest }) {
        return {
            ...topLevelRest,
            V3: {
                ...v3Rest,
                types: types.map(fromRawTy),
            },
        };
    }
    ContractMetadata.normalize = normalize;
    function tys(contractMetadata) {
        return normalize(contractMetadata).V3.types;
    }
    ContractMetadata.tys = tys;
})(ContractMetadata || (ContractMetadata = {}));
//# sourceMappingURL=Contract.js.map

/***/ }),

/***/ "./node_modules/capi/esm/frame_metadata/Era.js":
/*!*****************************************************!*\
  !*** ./node_modules/capi/esm/frame_metadata/Era.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$era": function() { return /* binding */ $era; },
/* harmony export */   "immortalEra": function() { return /* binding */ immortalEra; },
/* harmony export */   "mortalEra": function() { return /* binding */ mortalEra; }
/* harmony export */ });
/* harmony import */ var _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../deps/scale.js */ "./node_modules/capi/esm/deps/scale.js");

function immortalEra() {
    return { type: "Immortal" };
}
function mortalEra(period, current) {
    const adjustedPeriod = minN(maxN(nextPowerOfTwo(period), 4n), 1n << 16n);
    const phase = current % adjustedPeriod;
    const quantizeFactor = maxN(adjustedPeriod >> 12n, 1n);
    const quantizedPhase = phase / quantizeFactor * quantizeFactor;
    return { type: "Mortal", period: adjustedPeriod, phase: quantizedPhase };
}
const $era = _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.createCodec({
    name: "era",
    _metadata: null,
    _staticSize: 2,
    _encode(buffer, value) {
        if (value.type === "Immortal") {
            buffer.array[buffer.index++] = 0;
        }
        else {
            const quantizeFactor = maxN(value.period >> 12n, 1n);
            const encoded = minN(maxN(trailingZeroes(value.period) - 1n, 1n), 15n)
                | ((value.phase / quantizeFactor) << 4n);
            _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.u16._encode(buffer, Number(encoded));
        }
    },
    _decode(buffer) {
        if (buffer.array[buffer.index] === 0) {
            buffer.index++;
            return { type: "Immortal" };
        }
        else {
            const encoded = BigInt(_deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.u16._decode(buffer));
            const period = 2n << (encoded % (1n << 4n));
            const quantizeFactor = maxN(period >> 12n, 1n);
            const phase = (encoded >> 4n) * quantizeFactor;
            if (period >= 4n && phase <= period) {
                return { type: "Mortal", period, phase };
            }
            else {
                throw new Error("Invalid period and phase");
            }
        }
    },
});
function maxN(a, b) {
    return a > b ? a : b;
}
function minN(a, b) {
    return a > b ? a : b;
}
function trailingZeroes(n) {
    let i = 0n;
    while (!(n & 1n)) {
        i++;
        n >>= 1n;
    }
    return i;
}
function nextPowerOfTwo(n) {
    n--;
    let p = 1n;
    while (n > 0n) {
        p <<= 1n;
        n >>= 1n;
    }
    return p;
}
//# sourceMappingURL=Era.js.map

/***/ }),

/***/ "./node_modules/capi/esm/frame_metadata/Extrinsic.js":
/*!***********************************************************!*\
  !*** ./node_modules/capi/esm/frame_metadata/Extrinsic.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$extrinsic": function() { return /* binding */ $extrinsic; }
/* harmony export */ });
/* harmony import */ var _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../deps/scale.js */ "./node_modules/capi/esm/deps/scale.js");
/* harmony import */ var _deps_std_testing_asserts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../deps/std/testing/asserts.js */ "./node_modules/capi/esm/deps/std/testing/asserts.js");
/* harmony import */ var _hashers_mod_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../hashers/mod.js */ "./node_modules/capi/esm/hashers/mod.js");
/* harmony import */ var _ss58_mod_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ss58/mod.js */ "./node_modules/capi/esm/ss58/mod.js");
/* harmony import */ var _util_mod_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/mod.js */ "./node_modules/capi/esm/util/mod.js");
/* harmony import */ var _Codec_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Codec.js */ "./node_modules/capi/esm/frame_metadata/Codec.js");






function $extrinsic(props) {
    const { metadata, deriveCodec } = props;
    const { signedExtensions } = metadata.extrinsic;
    const $sig = deriveCodec(findExtrinsicTypeParam("Signature"));
    const $sigPromise = _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.promise($sig);
    const $address = deriveCodec(findExtrinsicTypeParam("Address"));
    const callTy = findExtrinsicTypeParam("Call");
    (0,_deps_std_testing_asserts_js__WEBPACK_IMPORTED_MODULE_1__.assert)(callTy?.type === "Union");
    const $call = deriveCodec(callTy);
    const [$extra, extraPjsInfo] = getExtensionInfo(pjsExtraKeyMap, "ty");
    const [$additional, additionalPjsInfo] = getExtensionInfo(pjsAdditionalKeyMap, "additionalSigned");
    const pjsInfo = [...extraPjsInfo, ...additionalPjsInfo];
    const toSignSize = $call._staticSize + $extra._staticSize + $additional._staticSize;
    const totalSize = 1 + $address._staticSize + $sig._staticSize + toSignSize;
    const $baseExtrinsic = _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.createCodec({
        _metadata: null,
        _staticSize: totalSize,
        _encode(buffer, extrinsic) {
            const firstByte = (+!!extrinsic.signature << 7) | extrinsic.protocolVersion;
            buffer.array[buffer.index++] = firstByte;
            const call = {
                type: extrinsic.palletName,
                value: {
                    type: extrinsic.methodName,
                    ...extrinsic.args,
                },
            };
            const { signature } = extrinsic;
            if (signature) {
                $address._encode(buffer, signature.address);
                if ("additional" in signature) {
                    const toSignBuffer = new _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.EncodeBuffer(buffer.stealAlloc(toSignSize));
                    $call._encode(toSignBuffer, call);
                    const callEnd = toSignBuffer.finishedSize + toSignBuffer.index;
                    if ("signPayload" in props.sign) {
                        const exts = [...signature.extra, ...signature.additional];
                        const extEnds = [];
                        for (let i = 0; i < pjsInfo.length; i++) {
                            pjsInfo[i].codec._encode(toSignBuffer, exts[i]);
                            extEnds.push(toSignBuffer.finishedSize + toSignBuffer.index);
                        }
                        const extraEnd = extEnds[extraPjsInfo.length - 1] ?? callEnd;
                        const toSignEncoded = toSignBuffer.finish();
                        const callEncoded = toSignEncoded.subarray(0, callEnd);
                        const extraEncoded = toSignEncoded.subarray(callEnd, extraEnd);
                        if (signature.address.type !== "Id") {
                            throw new Error("polkadot signer: address types other than Id are not supported");
                        }
                        const payload = {
                            address: _ss58_mod_js__WEBPACK_IMPORTED_MODULE_3__.encode(props.prefix, signature.address.value),
                            method: _util_mod_js__WEBPACK_IMPORTED_MODULE_4__.hex.encodePrefixed(callEncoded),
                            signedExtensions: signedExtensions.map((x) => x.ident),
                            version: extrinsic.protocolVersion,
                        };
                        let last = callEnd;
                        for (let i = 0; i < pjsInfo.length; i++) {
                            const { key } = pjsInfo[i];
                            if (!key)
                                throw new Error("polkadot signer: unknown extension");
                            payload[key] = typeof exts[i] === "number"
                                ? exts[i]
                                : _util_mod_js__WEBPACK_IMPORTED_MODULE_4__.hex.encodePrefixed(toSignEncoded.subarray(last, extEnds[i]));
                            last = extEnds[i];
                        }
                        const signer = props.sign;
                        buffer.writeAsync(0, async (buffer) => {
                            const { signature } = await signer.signPayload(payload);
                            buffer.insertArray(_util_mod_js__WEBPACK_IMPORTED_MODULE_4__.hex.decode(signature));
                        });
                        buffer.insertArray(extraEncoded);
                        buffer.insertArray(callEncoded);
                    }
                    else {
                        $extra._encode(toSignBuffer, signature.extra);
                        const extraEnd = toSignBuffer.finishedSize + toSignBuffer.index;
                        $additional._encode(toSignBuffer, signature.additional);
                        const toSignEncoded = toSignBuffer.finish();
                        const callEncoded = toSignEncoded.subarray(0, callEnd);
                        const extraEncoded = toSignEncoded.subarray(callEnd, extraEnd);
                        const toSign = toSignEncoded.length > 256
                            ? _hashers_mod_js__WEBPACK_IMPORTED_MODULE_2__.Blake2_256.hash(toSignEncoded)
                            : toSignEncoded;
                        const sig = props.sign(toSign);
                        if (sig instanceof Promise) {
                            $sigPromise._encode(buffer, sig);
                        }
                        else {
                            $sig._encode(buffer, sig);
                        }
                        buffer.insertArray(extraEncoded);
                        buffer.insertArray(callEncoded);
                    }
                }
                else {
                    $sig._encode(buffer, signature.sig);
                    $extra._encode(buffer, signature.extra);
                    $call._encode(buffer, call);
                }
            }
            else {
                $call._encode(buffer, call);
            }
        },
        _decode(buffer) {
            const firstByte = buffer.array[buffer.index++];
            const hasSignature = firstByte & (1 << 7);
            const protocolVersion = firstByte & ~(1 << 7);
            let signature;
            if (hasSignature) {
                const address = $address._decode(buffer);
                const sig = $sig._decode(buffer);
                const extra = $extra._decode(buffer);
                signature = { address, sig, extra };
            }
            const call = $call._decode(buffer);
            const { type: palletName, value: { type: methodName, ...args } } = call;
            return { protocolVersion, signature, palletName, methodName, args };
        },
    });
    return _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.lenPrefixed($baseExtrinsic);
    function findExtrinsicTypeParam(name) {
        return metadata.extrinsic.ty.params.find((x) => x.name === name)?.ty;
    }
    function getExtensionInfo(keyMap, key) {
        const pjsInfo = signedExtensions
            .map((e) => ({ key: keyMap[e.ident], codec: deriveCodec(e[key]) }))
            .filter((x) => x.codec !== _Codec_js__WEBPACK_IMPORTED_MODULE_5__.$null);
        return [_deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.tuple(...pjsInfo.map((x) => x.codec)), pjsInfo];
    }
}
const pjsExtraKeyMap = {
    CheckEra: "era",
    CheckMortality: "era",
    ChargeTransactionPayment: "tip",
    CheckNonce: "nonce",
};
const pjsAdditionalKeyMap = {
    CheckEra: "blockHash",
    CheckMortality: "blockHash",
    CheckSpecVersion: "specVersion",
    CheckTxVersion: "transactionVersion",
    CheckVersion: "specVersion",
    CheckGenesis: "genesisHash",
};
//# sourceMappingURL=Extrinsic.js.map

/***/ }),

/***/ "./node_modules/capi/esm/frame_metadata/Key.js":
/*!*****************************************************!*\
  !*** ./node_modules/capi/esm/frame_metadata/Key.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$storageKey": function() { return /* binding */ $storageKey; },
/* harmony export */   "DecodeNonTransparentKeyError": function() { return /* binding */ DecodeNonTransparentKeyError; },
/* harmony export */   "InvalidArgErr": function() { return /* binding */ InvalidArgErr; },
/* harmony export */   "StorageEntryMissingHasher": function() { return /* binding */ StorageEntryMissingHasher; }
/* harmony export */ });
/* harmony import */ var _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../deps/scale.js */ "./node_modules/capi/esm/deps/scale.js");
/* harmony import */ var _hashers_mod_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../hashers/mod.js */ "./node_modules/capi/esm/hashers/mod.js");


function $storageKey(props) {
    let keyCodecs;
    if (props.storageEntry.type === "Map") {
        const codec = props.deriveCodec(props.storageEntry.key);
        if (props.storageEntry.hashers.length === 1) {
            keyCodecs = [codec];
        }
        else {
            if (codec._metadata?.[0] !== _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.tuple) {
                throw new Error("Expected key codec to be a tuple since there are multiple hashers");
            }
            keyCodecs = codec._metadata.slice(1);
        }
    }
    else {
        keyCodecs = [];
    }
    const palletHash = _hashers_mod_js__WEBPACK_IMPORTED_MODULE_1__.Twox128.hash(new TextEncoder().encode(props.pallet.name));
    const entryHash = _hashers_mod_js__WEBPACK_IMPORTED_MODULE_1__.Twox128.hash(new TextEncoder().encode(props.storageEntry.name));
    const $keys = [...Array(keyCodecs.length + 1).keys()].reduce((keys, i) => {
        keys[i] = _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.tuple(...keyCodecs.slice(0, i).map(($key, i) => _hashers_mod_js__WEBPACK_IMPORTED_MODULE_1__[props.storageEntry.hashers[i]].$hash($key)));
        return keys;
    }, {});
    return _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.createCodec({
        _metadata: [$storageKey, props],
        _staticSize: $keys[Object.values($keys).length - 1]._staticSize,
        _encode(buffer, key) {
            buffer.insertArray(palletHash);
            buffer.insertArray(entryHash);
            if (key.length === 0)
                return;
            $keys[key.length]._encode(buffer, key);
        },
        _decode(buffer) {
            // Ignore initial hashes
            buffer.index += 32;
            return $keys[Object.values($keys).length - 1]._decode(buffer);
        },
    });
}
class StorageEntryMissingHasher extends Error {
}
class InvalidArgErr extends Error {
}
class DecodeNonTransparentKeyError extends Error {
}
//# sourceMappingURL=Key.js.map

/***/ }),

/***/ "./node_modules/capi/esm/frame_metadata/Metadata.js":
/*!**********************************************************!*\
  !*** ./node_modules/capi/esm/frame_metadata/Metadata.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$constant": function() { return /* binding */ $constant; },
/* harmony export */   "$extrinsicDef": function() { return /* binding */ $extrinsicDef; },
/* harmony export */   "$metadata": function() { return /* binding */ $metadata; },
/* harmony export */   "$pallet": function() { return /* binding */ $pallet; },
/* harmony export */   "$signedExtensionMetadata": function() { return /* binding */ $signedExtensionMetadata; },
/* harmony export */   "$storage": function() { return /* binding */ $storage; },
/* harmony export */   "$storageEntry": function() { return /* binding */ $storageEntry; },
/* harmony export */   "$storageEntryModifier": function() { return /* binding */ $storageEntryModifier; },
/* harmony export */   "$storageEntryType": function() { return /* binding */ $storageEntryType; },
/* harmony export */   "EntryNotFoundError": function() { return /* binding */ EntryNotFoundError; },
/* harmony export */   "PalletNotFoundError": function() { return /* binding */ PalletNotFoundError; },
/* harmony export */   "fromPrefixedHex": function() { return /* binding */ fromPrefixedHex; },
/* harmony export */   "getEntry": function() { return /* binding */ getEntry; },
/* harmony export */   "getPallet": function() { return /* binding */ getPallet; },
/* harmony export */   "getPalletAndEntry": function() { return /* binding */ getPalletAndEntry; },
/* harmony export */   "magicNumber": function() { return /* binding */ magicNumber; }
/* harmony export */ });
/* harmony import */ var _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../deps/scale.js */ "./node_modules/capi/esm/deps/scale.js");
/* harmony import */ var _util_mod_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/mod.js */ "./node_modules/capi/esm/util/mod.js");
/* harmony import */ var _scale_info_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scale_info.js */ "./node_modules/capi/esm/frame_metadata/scale_info.js");



const $hasherKind = _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.stringUnion([
    "Blake2_128",
    "Blake2_256",
    "Blake2_128Concat",
    "Twox128",
    "Twox256",
    "Twox64Concat",
    "Identity",
]);
const $storageEntryModifier = _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.stringUnion([
    "Optional",
    "Default",
]);
const $storageEntryType = _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.taggedUnion("type", [
    ["Plain", ["value", _scale_info_js__WEBPACK_IMPORTED_MODULE_2__.$tyId]],
    [
        "Map",
        ["hashers", _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.array($hasherKind)],
        ["key", _scale_info_js__WEBPACK_IMPORTED_MODULE_2__.$tyId],
        ["value", _scale_info_js__WEBPACK_IMPORTED_MODULE_2__.$tyId],
    ],
]);
const $storageEntry = _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.spread(_deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.spread(_deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.object(["name", _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.str], ["modifier", $storageEntryModifier]), $storageEntryType), _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.object(["default", _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.array(_deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.u8)], ["docs", _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.array(_deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.str)]));
const $storage = _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.object(["prefix", _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.str], ["entries", _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.array($storageEntry)]);
const $constant = _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.object(["name", _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.str], ["ty", _scale_info_js__WEBPACK_IMPORTED_MODULE_2__.$tyId], ["value", _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.uint8Array], ["docs", _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.array(_deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.str)]);
const $pallet = _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.object(["name", _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.str], ["storage", _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.option($storage)], ["calls", _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.option(_scale_info_js__WEBPACK_IMPORTED_MODULE_2__.$tyId)], ["event", _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.option(_scale_info_js__WEBPACK_IMPORTED_MODULE_2__.$tyId)], ["constants", _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.array($constant)], ["error", _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.option(_scale_info_js__WEBPACK_IMPORTED_MODULE_2__.$tyId)], ["i", _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.u8]);
const $signedExtensionMetadata = _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.object(["ident", _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.str], ["ty", _scale_info_js__WEBPACK_IMPORTED_MODULE_2__.$tyId], ["additionalSigned", _scale_info_js__WEBPACK_IMPORTED_MODULE_2__.$tyId]);
const $extrinsicDef = _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.object(["ty", _scale_info_js__WEBPACK_IMPORTED_MODULE_2__.$tyId], ["version", _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.u8], ["signedExtensions", _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.array($signedExtensionMetadata)]);
// https://docs.substrate.io/v3/runtime/metadata/#encoded-metadata-format
const magicNumber = 1635018093;
const $metadata = _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.object(["magicNumber", _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.constantPattern(magicNumber, _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.u32)], ["version", _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.constantPattern(14, _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.u8)], ["tys", _scale_info_js__WEBPACK_IMPORTED_MODULE_2__.$tys], ["pallets", _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.array($pallet)], ["extrinsic", $extrinsicDef]);
function fromPrefixedHex(scaleEncoded) {
    return $metadata.decode(_util_mod_js__WEBPACK_IMPORTED_MODULE_1__.hex.decode(scaleEncoded));
}
function getPallet(metadata, name) {
    return metadata.pallets.find((pallet) => pallet.name === name) || new PalletNotFoundError();
}
class PalletNotFoundError extends _util_mod_js__WEBPACK_IMPORTED_MODULE_1__.ErrorCtor("PalletNotFound") {
}
function getEntry(pallet, name) {
    return pallet.storage?.entries.find((entry) => entry.name === name) || new EntryNotFoundError();
}
class EntryNotFoundError extends _util_mod_js__WEBPACK_IMPORTED_MODULE_1__.ErrorCtor("EntryNotFound") {
}
function getPalletAndEntry(metadata, palletName, entryName) {
    const pallet = getPallet(metadata, palletName);
    if (pallet instanceof Error) {
        return pallet;
    }
    const entry = getEntry(pallet, entryName);
    if (entry instanceof Error) {
        return entry;
    }
    return [pallet, entry];
}
//# sourceMappingURL=Metadata.js.map

/***/ }),

/***/ "./node_modules/capi/esm/frame_metadata/TyVisitor.js":
/*!***********************************************************!*\
  !*** ./node_modules/capi/esm/frame_metadata/TyVisitor.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TyVisitor": function() { return /* binding */ TyVisitor; }
/* harmony export */ });
class TyVisitor {
    constructor(tys, methods) {
        Object.defineProperty(this, "tys", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: tys
        });
        Object.defineProperty(this, "cache", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.assign(this, methods);
    }
    visit(ty) {
        if (typeof ty === "number") {
            ty = this.tys[ty];
        }
        const i = ty.id;
        if (this.cache[i] != null) {
            return this.cache[i];
        }
        if (this.cache[i] === null) {
            return this.circular(ty);
        }
        this.cache[i] = null; // circularity detection
        const value = this._visit(ty);
        this.cache[i] = value;
        return value;
    }
    _visit(ty) {
        if (ty.type === "Struct") {
            if (this.map && ty.path[0] === "BTreeMap") {
                return this.map(ty, ty.params[0].ty, ty.params[1].ty);
            }
            else if (this.set && ty.path[0] === "BTreeSet") {
                return this.set(ty, ty.params[0].ty);
            }
            else if (ty.path.at(-1) === "WrapperOpaque" || ty.path.at(-1) === "WrapperKeepOpaque") {
                return this.lenPrefixedWrapper(ty, ty.params[0].ty);
            }
            else if (ty.fields.length === 0) {
                return this.unitStruct(ty);
            }
            else if (ty.fields[0].name === undefined) {
                if (ty.fields.length === 1) {
                    return this.wrapperStruct(ty, ty.fields[0].ty);
                }
                else {
                    return this.tupleStruct(ty, ty.fields.map((x) => x.ty));
                }
            }
            else {
                return this.objectStruct(ty);
            }
        }
        else if (ty.type === "Tuple") {
            if (ty.fields.length === 0) {
                return this.unitStruct(ty);
            }
            else if (ty.fields.length === 1) {
                return this.wrapperStruct(ty, ty.fields[0]);
            }
            else {
                return this.tupleStruct(ty, ty.fields);
            }
        }
        else if (ty.type === "Union") {
            // TODO: revisit Option and Result
            if (ty.path[0] === "Option") {
                return this.option(ty, ty.params[0].ty);
            }
            else if (ty.path[0] === "Result") {
                return this.result(ty, ty.params[0].ty, ty.params[1].ty);
            }
            else if (this.era && ty.path.at(-1) === "Era") {
                return this.era(ty);
            }
            else if (ty.members.length === 0) {
                return this.never(ty);
            }
            else if (ty.members.every((x) => x.fields.length === 0)) {
                return this.stringUnion(ty);
            }
            else {
                return this.taggedUnion(ty);
            }
        }
        else if (ty.type === "Sequence") {
            if (this.uint8Array && _isU8(ty.typeParam)) {
                return this.uint8Array(ty);
            }
            else {
                return this.array(ty);
            }
        }
        else if (ty.type === "SizedArray") {
            if (this.sizedUint8Array && _isU8(ty.typeParam)) {
                return this.sizedUint8Array(ty);
            }
            else {
                return this.sizedArray(ty);
            }
        }
        else if (ty.type === "Primitive") {
            return this.primitive(ty);
        }
        else if (ty.type === "Compact") {
            return this.compact(ty);
        }
        else if (ty.type === "BitSequence") {
            return this.bitSequence(ty);
        }
        else {
            throw new Error("unreachable");
        }
    }
}
function _isU8(ty) {
    return ty.type === "Primitive" && ty.kind === "u8";
}
//# sourceMappingURL=TyVisitor.js.map

/***/ }),

/***/ "./node_modules/capi/esm/frame_metadata/mod.js":
/*!*****************************************************!*\
  !*** ./node_modules/capi/esm/frame_metadata/mod.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$constant": function() { return /* reexport safe */ _Metadata_js__WEBPACK_IMPORTED_MODULE_5__.$constant; },
/* harmony export */   "$era": function() { return /* reexport safe */ _Era_js__WEBPACK_IMPORTED_MODULE_2__.$era; },
/* harmony export */   "$extrinsic": function() { return /* reexport safe */ _Extrinsic_js__WEBPACK_IMPORTED_MODULE_3__.$extrinsic; },
/* harmony export */   "$extrinsicDef": function() { return /* reexport safe */ _Metadata_js__WEBPACK_IMPORTED_MODULE_5__.$extrinsicDef; },
/* harmony export */   "$field": function() { return /* reexport safe */ _scale_info_js__WEBPACK_IMPORTED_MODULE_6__.$field; },
/* harmony export */   "$metadata": function() { return /* reexport safe */ _Metadata_js__WEBPACK_IMPORTED_MODULE_5__.$metadata; },
/* harmony export */   "$null": function() { return /* reexport safe */ _Codec_js__WEBPACK_IMPORTED_MODULE_0__.$null; },
/* harmony export */   "$pallet": function() { return /* reexport safe */ _Metadata_js__WEBPACK_IMPORTED_MODULE_5__.$pallet; },
/* harmony export */   "$param": function() { return /* reexport safe */ _scale_info_js__WEBPACK_IMPORTED_MODULE_6__.$param; },
/* harmony export */   "$signedExtensionMetadata": function() { return /* reexport safe */ _Metadata_js__WEBPACK_IMPORTED_MODULE_5__.$signedExtensionMetadata; },
/* harmony export */   "$storage": function() { return /* reexport safe */ _Metadata_js__WEBPACK_IMPORTED_MODULE_5__.$storage; },
/* harmony export */   "$storageEntry": function() { return /* reexport safe */ _Metadata_js__WEBPACK_IMPORTED_MODULE_5__.$storageEntry; },
/* harmony export */   "$storageEntryModifier": function() { return /* reexport safe */ _Metadata_js__WEBPACK_IMPORTED_MODULE_5__.$storageEntryModifier; },
/* harmony export */   "$storageEntryType": function() { return /* reexport safe */ _Metadata_js__WEBPACK_IMPORTED_MODULE_5__.$storageEntryType; },
/* harmony export */   "$storageKey": function() { return /* reexport safe */ _Key_js__WEBPACK_IMPORTED_MODULE_4__.$storageKey; },
/* harmony export */   "$ty": function() { return /* reexport safe */ _scale_info_js__WEBPACK_IMPORTED_MODULE_6__.$ty; },
/* harmony export */   "$tyDef": function() { return /* reexport safe */ _scale_info_js__WEBPACK_IMPORTED_MODULE_6__.$tyDef; },
/* harmony export */   "$tyId": function() { return /* reexport safe */ _scale_info_js__WEBPACK_IMPORTED_MODULE_6__.$tyId; },
/* harmony export */   "$tys": function() { return /* reexport safe */ _scale_info_js__WEBPACK_IMPORTED_MODULE_6__.$tys; },
/* harmony export */   "ChainError": function() { return /* reexport safe */ _Codec_js__WEBPACK_IMPORTED_MODULE_0__.ChainError; },
/* harmony export */   "ContractMetadata": function() { return /* reexport safe */ _Contract_js__WEBPACK_IMPORTED_MODULE_1__.ContractMetadata; },
/* harmony export */   "DecodeNonTransparentKeyError": function() { return /* reexport safe */ _Key_js__WEBPACK_IMPORTED_MODULE_4__.DecodeNonTransparentKeyError; },
/* harmony export */   "DeriveCodec": function() { return /* reexport safe */ _Codec_js__WEBPACK_IMPORTED_MODULE_0__.DeriveCodec; },
/* harmony export */   "EntryNotFoundError": function() { return /* reexport safe */ _Metadata_js__WEBPACK_IMPORTED_MODULE_5__.EntryNotFoundError; },
/* harmony export */   "InvalidArgErr": function() { return /* reexport safe */ _Key_js__WEBPACK_IMPORTED_MODULE_4__.InvalidArgErr; },
/* harmony export */   "PalletNotFoundError": function() { return /* reexport safe */ _Metadata_js__WEBPACK_IMPORTED_MODULE_5__.PalletNotFoundError; },
/* harmony export */   "StorageEntryMissingHasher": function() { return /* reexport safe */ _Key_js__WEBPACK_IMPORTED_MODULE_4__.StorageEntryMissingHasher; },
/* harmony export */   "TyDecodeCtx": function() { return /* reexport safe */ _scale_info_js__WEBPACK_IMPORTED_MODULE_6__.TyDecodeCtx; },
/* harmony export */   "TyVisitor": function() { return /* reexport safe */ _TyVisitor_js__WEBPACK_IMPORTED_MODULE_7__.TyVisitor; },
/* harmony export */   "fromPrefixedHex": function() { return /* reexport safe */ _Metadata_js__WEBPACK_IMPORTED_MODULE_5__.fromPrefixedHex; },
/* harmony export */   "getEntry": function() { return /* reexport safe */ _Metadata_js__WEBPACK_IMPORTED_MODULE_5__.getEntry; },
/* harmony export */   "getPallet": function() { return /* reexport safe */ _Metadata_js__WEBPACK_IMPORTED_MODULE_5__.getPallet; },
/* harmony export */   "getPalletAndEntry": function() { return /* reexport safe */ _Metadata_js__WEBPACK_IMPORTED_MODULE_5__.getPalletAndEntry; },
/* harmony export */   "immortalEra": function() { return /* reexport safe */ _Era_js__WEBPACK_IMPORTED_MODULE_2__.immortalEra; },
/* harmony export */   "magicNumber": function() { return /* reexport safe */ _Metadata_js__WEBPACK_IMPORTED_MODULE_5__.magicNumber; },
/* harmony export */   "mortalEra": function() { return /* reexport safe */ _Era_js__WEBPACK_IMPORTED_MODULE_2__.mortalEra; }
/* harmony export */ });
/* harmony import */ var _Codec_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Codec.js */ "./node_modules/capi/esm/frame_metadata/Codec.js");
/* harmony import */ var _Contract_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Contract.js */ "./node_modules/capi/esm/frame_metadata/Contract.js");
/* harmony import */ var _Era_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Era.js */ "./node_modules/capi/esm/frame_metadata/Era.js");
/* harmony import */ var _Extrinsic_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Extrinsic.js */ "./node_modules/capi/esm/frame_metadata/Extrinsic.js");
/* harmony import */ var _Key_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Key.js */ "./node_modules/capi/esm/frame_metadata/Key.js");
/* harmony import */ var _Metadata_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Metadata.js */ "./node_modules/capi/esm/frame_metadata/Metadata.js");
/* harmony import */ var _scale_info_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./scale_info.js */ "./node_modules/capi/esm/frame_metadata/scale_info.js");
/* harmony import */ var _TyVisitor_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./TyVisitor.js */ "./node_modules/capi/esm/frame_metadata/TyVisitor.js");








//# sourceMappingURL=mod.js.map

/***/ }),

/***/ "./node_modules/capi/esm/frame_metadata/scale_info.js":
/*!************************************************************!*\
  !*** ./node_modules/capi/esm/frame_metadata/scale_info.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$field": function() { return /* binding */ $field; },
/* harmony export */   "$param": function() { return /* binding */ $param; },
/* harmony export */   "$ty": function() { return /* binding */ $ty; },
/* harmony export */   "$tyDef": function() { return /* binding */ $tyDef; },
/* harmony export */   "$tyId": function() { return /* binding */ $tyId; },
/* harmony export */   "$tys": function() { return /* binding */ $tys; },
/* harmony export */   "TyDecodeCtx": function() { return /* binding */ TyDecodeCtx; }
/* harmony export */ });
/* harmony import */ var _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../deps/scale.js */ "./node_modules/capi/esm/deps/scale.js");

class TyDecodeCtx {
    constructor() {
        Object.defineProperty(this, "tys", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
    }
}
const $tys = _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.createCodec({
    name: "tys",
    _metadata: null,
    _staticSize: _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.compactU32._staticSize,
    _encode(buffer, value) {
        _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.array($ty)._encode(buffer, value);
    },
    _decode(buffer) {
        const length = _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.compactU32._decode(buffer);
        const ctx = buffer.context.get(TyDecodeCtx);
        const tys = ctx.tys = Array.from({ length }, (_, id) => ({ id }));
        for (let i = 0; i < length; i++) {
            Object.assign(tys[i], $ty._decode(buffer));
        }
        return tys;
    },
});
const $tyId = _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.createCodec({
    name: "tyId",
    _metadata: null,
    _staticSize: _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.compactU32._staticSize,
    _encode(buffer, value) {
        _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.compactU32._encode(buffer, value.id);
    },
    _decode(buffer) {
        const ctx = buffer.context.get(TyDecodeCtx);
        const id = _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.compactU32._decode(buffer);
        return ctx.tys?.[id] ?? { id };
    },
});
const $field = _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.object(["name", _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.option(_deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.str)], ["ty", $tyId], ["typeName", _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.option(_deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.str)], ["docs", _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.array(_deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.str)]);
const $primitiveKind = _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.stringUnion([
    "bool",
    "char",
    "str",
    "u8",
    "u16",
    "u32",
    "u64",
    "u128",
    "u256",
    "i8",
    "i16",
    "i32",
    "i64",
    "i128",
    "i256",
]);
const $tyDef = _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.taggedUnion("type", [
    [
        "Struct",
        ["fields", _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.array($field)],
    ],
    [
        "Union",
        [
            "members",
            _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.array(_deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.object(["name", _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.str], ["fields", _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.array($field)], ["index", _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.u8], ["docs", _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.array(_deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.str)])),
        ],
    ],
    [
        "Sequence",
        ["typeParam", $tyId],
    ],
    [
        "SizedArray",
        ["len", _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.u32],
        ["typeParam", $tyId],
    ],
    [
        "Tuple",
        ["fields", _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.array($tyId)],
    ],
    [
        "Primitive",
        ["kind", $primitiveKind],
    ],
    [
        "Compact",
        ["typeParam", $tyId],
    ],
    [
        "BitSequence",
        ["bitOrderType", $tyId],
        ["bitStoreType", $tyId],
    ],
]);
const $param = _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.object(["name", _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.str], ["ty", _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.option($tyId)]);
const $ty = _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.spread(_deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.spread(_deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.object(["id", _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.compactU32], ["path", _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.array(_deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.str)], ["params", _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.array($param)]), $tyDef), _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.object(["docs", _deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.array(_deps_scale_js__WEBPACK_IMPORTED_MODULE_0__.str)]));
//# sourceMappingURL=scale_info.js.map

/***/ }),

/***/ "./node_modules/capi/esm/hashers/mod.js":
/*!**********************************************!*\
  !*** ./node_modules/capi/esm/hashers/mod.js ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Blake2Hasher": function() { return /* binding */ Blake2Hasher; },
/* harmony export */   "Blake2_128": function() { return /* binding */ Blake2_128; },
/* harmony export */   "Blake2_128Concat": function() { return /* binding */ Blake2_128Concat; },
/* harmony export */   "Blake2_256": function() { return /* binding */ Blake2_256; },
/* harmony export */   "Hasher": function() { return /* binding */ Hasher; },
/* harmony export */   "Identity": function() { return /* binding */ Identity; },
/* harmony export */   "IdentityHasher": function() { return /* binding */ IdentityHasher; },
/* harmony export */   "Twox128": function() { return /* binding */ Twox128; },
/* harmony export */   "Twox256": function() { return /* binding */ Twox256; },
/* harmony export */   "Twox64Concat": function() { return /* binding */ Twox64Concat; },
/* harmony export */   "TwoxHasher": function() { return /* binding */ TwoxHasher; }
/* harmony export */ });
/* harmony import */ var _deps_blake2b_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../deps/blake2b.js */ "./node_modules/capi/esm/deps/blake2b.js");
/* harmony import */ var _deps_scale_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../deps/scale.js */ "./node_modules/capi/esm/deps/scale.js");
/* harmony import */ var _frame_metadata_Key_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../frame_metadata/Key.js */ "./node_modules/capi/esm/frame_metadata/Key.js");
/* harmony import */ var _xxhash_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./xxhash.js */ "./node_modules/capi/esm/hashers/xxhash.js");





class Hasher {
    $hash($inner) {
        return _deps_scale_js__WEBPACK_IMPORTED_MODULE_1__.createCodec({
            _metadata: null,
            _staticSize: this.digestLength + $inner._staticSize,
            _encode: (buffer, value) => {
                const hashArray = buffer.array.subarray(buffer.index, buffer.index += this.digestLength);
                const cursor = this.concat
                    ? buffer.createCursor($inner._staticSize)
                    : new _deps_scale_js__WEBPACK_IMPORTED_MODULE_1__.EncodeBuffer(buffer.stealAlloc($inner._staticSize));
                $inner._encode(cursor, value);
                buffer.waitForBuffer(cursor, () => {
                    if (this.concat)
                        cursor.close();
                    else
                        cursor._commitWritten();
                    const hashing = this.create();
                    updateHashing(hashing, cursor);
                    hashing.digestInto(hashArray);
                });
            },
            _decode: (buffer) => {
                if (!this.concat)
                    throw new _frame_metadata_Key_js__WEBPACK_IMPORTED_MODULE_2__.DecodeNonTransparentKeyError();
                buffer.index += this.digestLength;
                return $inner._decode(buffer);
            },
        });
    }
    hash(data) {
        const output = new Uint8Array(this.digestLength + (this.concat ? data.length : 0));
        const hashing = this.create();
        hashing.update(data);
        hashing.digestInto(output);
        if (this.concat) {
            output.set(data, this.digestLength);
        }
        return output;
    }
}
class Blake2Hasher extends Hasher {
    constructor(size, concat) {
        super();
        Object.defineProperty(this, "concat", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: concat
        });
        Object.defineProperty(this, "digestLength", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.digestLength = size / 8;
    }
    create() {
        return _deps_blake2b_js__WEBPACK_IMPORTED_MODULE_0__.blake2b.create({ dkLen: this.digestLength });
    }
}
class IdentityHasher extends Hasher {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "digestLength", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "concat", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
    }
    create() {
        return {
            update() { },
            digestInto() { },
        };
    }
    $hash($inner) {
        return $inner;
    }
    hash(data) {
        return data.slice();
    }
}
class TwoxHasher extends Hasher {
    constructor(size, concat) {
        super();
        Object.defineProperty(this, "concat", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: concat
        });
        Object.defineProperty(this, "digestLength", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "rounds", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.digestLength = size / 8;
        this.rounds = size / 64;
    }
    create() {
        return new _xxhash_js__WEBPACK_IMPORTED_MODULE_3__.Xxhash(this.rounds);
    }
}
const Blake2_128 = new Blake2Hasher(128, false);
const Blake2_128Concat = new Blake2Hasher(128, true);
const Blake2_256 = new Blake2Hasher(256, false);
const Identity = new IdentityHasher();
const Twox128 = new TwoxHasher(128, false);
const Twox256 = new TwoxHasher(256, false);
const Twox64Concat = new TwoxHasher(64, true);
function updateHashing(hashing, data) {
    for (const array of data.finishedArrays) {
        if (array instanceof _deps_scale_js__WEBPACK_IMPORTED_MODULE_1__.EncodeBuffer) {
            updateHashing(hashing, array);
        }
        else {
            hashing.update(array);
        }
    }
}
//# sourceMappingURL=mod.js.map

/***/ }),

/***/ "./node_modules/capi/esm/hashers/xxhash.js":
/*!*************************************************!*\
  !*** ./node_modules/capi/esm/hashers/xxhash.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Xxhash": function() { return /* binding */ Xxhash; }
/* harmony export */ });
/*
  Copyright 2022 Parity Technologies
  SPDX-License-Identifier: Apache-2.0
  Adapted from https://github.com/polkadot-js/common/blob/40d6a388/packages/util-crypto/src/xxhash/xxhash64.ts

  Copyright 2017-2022 @polkadot/util-crypto authors & contributors
  SPDX-License-Identifier: Apache-2.0
  Adapted from https://github.com/pierrec/js-xxhash/blob/0504e76f3d31a21ae8528a7f590c7289c9e431d2/lib/xxhash64.js

  xxHash64 implementation in pure Javascript
  Copyright (C) 2016, Pierre Curto

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/
const P64_1 = 11400714785074694791n;
const P64_2 = 14029467366897019727n;
const P64_3 = 1609587929392839161n;
const P64_4 = 9650029242287828579n;
const P64_5 = 2870177450012600261n;
// mask for a u64, all bits set
const U64 = 0xffffffffffffffffn;
function rotl(a, b) {
    const c = a & U64;
    return ((c << b) | (c >> (64n - b))) & U64;
}
class Xxhash {
    constructor(rounds) {
        Object.defineProperty(this, "rounds", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: rounds
        });
        Object.defineProperty(this, "buf", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Uint8Array(32)
        });
        Object.defineProperty(this, "view", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new DataView(this.buf.buffer)
        });
        Object.defineProperty(this, "bufI", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "written", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "vs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.vs = new BigUint64Array(rounds * 4);
        for (let i = 0, seed = 0n; i < this.vs.length; seed++) {
            this.vs[i++] = seed + P64_1 + P64_2;
            this.vs[i++] = seed + P64_2;
            this.vs[i++] = seed;
            this.vs[i++] = seed - P64_1;
        }
    }
    _updateVs(view, p) {
        const a = view.getBigUint64(p, true);
        const b = view.getBigUint64(p + 8, true);
        const c = view.getBigUint64(p + 16, true);
        const d = view.getBigUint64(p + 24, true);
        for (let i = 0; i < this.vs.length;) {
            this.vs[i] = P64_1 * rotl(this.vs[i++] + P64_2 * a, 31n);
            this.vs[i] = P64_1 * rotl(this.vs[i++] + P64_2 * b, 31n);
            this.vs[i] = P64_1 * rotl(this.vs[i++] + P64_2 * c, 31n);
            this.vs[i] = P64_1 * rotl(this.vs[i++] + P64_2 * d, 31n);
        }
    }
    update(input) {
        this.written += input.length;
        let i = 0;
        if (this.bufI) {
            i = Math.min(input.length, 32 - this.bufI);
            this.buf.set(input.subarray(0, i), this.bufI);
            this.bufI += i;
            if (this.bufI < 32)
                return;
            this._updateVs(this.view, 0);
        }
        if (i <= input.length - 32) {
            const view = new DataView(input.buffer, input.byteOffset, input.byteLength);
            do {
                this._updateVs(view, i);
                i += 32;
            } while (i + 32 <= input.length);
        }
        this.buf.set(input.subarray(i));
        this.bufI = input.length - i;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.rounds * 8));
    }
    digestInto(digest) {
        const digestView = new DataView(digest.buffer, digest.byteOffset, digest.byteLength);
        for (let i = 0; i < this.rounds; i++) {
            const v0 = this.vs[i * 4];
            const v1 = this.vs[i * 4 + 1];
            const v2 = this.vs[i * 4 + 2];
            const v3 = this.vs[i * 4 + 3];
            let h64 = 0n;
            if (this.written >= 32) {
                h64 = U64 & (rotl(v0, 1n) + rotl(v1, 7n) + rotl(v2, 12n) + rotl(v3, 18n));
                h64 = U64 & ((h64 ^ (P64_1 * rotl(v0 * P64_2, 31n))) * P64_1 + P64_4);
                h64 = U64 & ((h64 ^ (P64_1 * rotl(v1 * P64_2, 31n))) * P64_1 + P64_4);
                h64 = U64 & ((h64 ^ (P64_1 * rotl(v2 * P64_2, 31n))) * P64_1 + P64_4);
                h64 = U64 & ((h64 ^ (P64_1 * rotl(v3 * P64_2, 31n))) * P64_1 + P64_4);
            }
            else {
                h64 = BigInt(i) + P64_5;
            }
            h64 = U64 & (BigInt(this.written) + h64);
            let p = 0;
            while (p + 8 <= this.bufI) {
                const n = this.view.getBigUint64(p, true);
                h64 = U64 & (P64_4 + P64_1 * rotl(h64 ^ (P64_1 * rotl(P64_2 * n, 31n)), 27n));
                p += 8;
            }
            if (p + 4 <= this.bufI) {
                const n = BigInt(this.view.getUint32(p, true));
                h64 = U64 & (P64_3 + P64_2 * rotl(h64 ^ (P64_1 * n), 23n));
                p += 4;
            }
            while (p < this.bufI) {
                const n = BigInt(this.buf[p++]);
                h64 = U64 & (P64_1 * rotl(h64 ^ (P64_5 * n), 11n));
            }
            h64 = U64 & (P64_2 * (h64 ^ (h64 >> 33n)));
            h64 = U64 & (P64_3 * (h64 ^ (h64 >> 29n)));
            h64 = U64 & (h64 ^ (h64 >> 32n));
            digestView.setBigUint64(i * 8, h64, true);
        }
        return digest;
    }
}
//# sourceMappingURL=xxhash.js.map

/***/ }),

/***/ "./node_modules/capi/esm/known/configs.js":
/*!************************************************!*\
  !*** ./node_modules/capi/esm/known/configs.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "acala": function() { return /* binding */ acala; },
/* harmony export */   "kusama": function() { return /* binding */ kusama; },
/* harmony export */   "moonbeam": function() { return /* binding */ moonbeam; },
/* harmony export */   "polkadot": function() { return /* binding */ polkadot; },
/* harmony export */   "rococo": function() { return /* binding */ rococo; },
/* harmony export */   "statemint": function() { return /* binding */ statemint; },
/* harmony export */   "subsocial": function() { return /* binding */ subsocial; },
/* harmony export */   "westend": function() { return /* binding */ westend; }
/* harmony export */ });
/* harmony import */ var _config_mod_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config/mod.js */ "./node_modules/capi/esm/config/mod.js");
// TODO: ultimately delete this file upon introduction of RPC-method-specific codegen

// @see https://github.com/paritytech/capi/issues/127
const Config_ = (_config_mod_js__WEBPACK_IMPORTED_MODULE_0__.Config);
const polkadot = new Config_(() => "wss://rpc.polkadot.io", 0);
const kusama = new Config_(() => "wss://kusama-rpc.polkadot.io", 2);
const acala = new Config_(() => "wss://acala-polkadot.api.onfinality.io/public-ws", 10);
const rococo = new Config_(() => "wss://rococo-contracts-rpc.polkadot.io", undefined);
const moonbeam = new Config_(() => "wss://wss.api.moonbeam.network", 1284);
const statemint = new Config_(() => "wss://statemint-rpc.polkadot.io", undefined);
const subsocial = new Config_(() => "wss://para.subsocial.network", 28);
const westend = new Config_(() => "wss://westend-rpc.polkadot.io", 42);
//# sourceMappingURL=configs.js.map

/***/ }),

/***/ "./node_modules/capi/esm/known/mod.js":
/*!********************************************!*\
  !*** ./node_modules/capi/esm/known/mod.js ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "acala": function() { return /* reexport safe */ _configs_js__WEBPACK_IMPORTED_MODULE_0__.acala; },
/* harmony export */   "kusama": function() { return /* reexport safe */ _configs_js__WEBPACK_IMPORTED_MODULE_0__.kusama; },
/* harmony export */   "moonbeam": function() { return /* reexport safe */ _configs_js__WEBPACK_IMPORTED_MODULE_0__.moonbeam; },
/* harmony export */   "polkadot": function() { return /* reexport safe */ _configs_js__WEBPACK_IMPORTED_MODULE_0__.polkadot; },
/* harmony export */   "rococo": function() { return /* reexport safe */ _configs_js__WEBPACK_IMPORTED_MODULE_0__.rococo; },
/* harmony export */   "rpc": function() { return /* reexport module object */ _rpc_js__WEBPACK_IMPORTED_MODULE_1__; },
/* harmony export */   "statemint": function() { return /* reexport safe */ _configs_js__WEBPACK_IMPORTED_MODULE_0__.statemint; },
/* harmony export */   "subsocial": function() { return /* reexport safe */ _configs_js__WEBPACK_IMPORTED_MODULE_0__.subsocial; },
/* harmony export */   "types": function() { return /* reexport module object */ _types_mod_js__WEBPACK_IMPORTED_MODULE_2__; },
/* harmony export */   "westend": function() { return /* reexport safe */ _configs_js__WEBPACK_IMPORTED_MODULE_0__.westend; }
/* harmony export */ });
/* harmony import */ var _configs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./configs.js */ "./node_modules/capi/esm/known/configs.js");
/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rpc.js */ "./node_modules/capi/esm/known/rpc.js");
/* harmony import */ var _types_mod_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types/mod.js */ "./node_modules/capi/esm/known/types/mod.js");



//# sourceMappingURL=mod.js.map

/***/ }),

/***/ "./node_modules/capi/esm/known/rpc.js":
/*!********************************************!*\
  !*** ./node_modules/capi/esm/known/rpc.js ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=rpc.js.map

/***/ }),

/***/ "./node_modules/capi/esm/known/types/author.js":
/*!*****************************************************!*\
  !*** ./node_modules/capi/esm/known/types/author.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=author.js.map

/***/ }),

/***/ "./node_modules/capi/esm/known/types/beefy.js":
/*!****************************************************!*\
  !*** ./node_modules/capi/esm/known/types/beefy.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// TODO: clean this up!

//# sourceMappingURL=beefy.js.map

/***/ }),

/***/ "./node_modules/capi/esm/known/types/chain_head/unstable/follow.js":
/*!*************************************************************************!*\
  !*** ./node_modules/capi/esm/known/types/chain_head/unstable/follow.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=follow.js.map

/***/ }),

/***/ "./node_modules/capi/esm/known/types/common.js":
/*!*****************************************************!*\
  !*** ./node_modules/capi/esm/known/types/common.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=common.js.map

/***/ }),

/***/ "./node_modules/capi/esm/known/types/mod.js":
/*!**************************************************!*\
  !*** ./node_modules/capi/esm/known/types/mod.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "beefy": function() { return /* reexport module object */ _beefy_js__WEBPACK_IMPORTED_MODULE_1__; }
/* harmony export */ });
/* harmony import */ var _author_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./author.js */ "./node_modules/capi/esm/known/types/author.js");
/* harmony import */ var _beefy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./beefy.js */ "./node_modules/capi/esm/known/types/beefy.js");
/* harmony import */ var _chain_head_unstable_follow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chain_head/unstable/follow.js */ "./node_modules/capi/esm/known/types/chain_head/unstable/follow.js");
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./common.js */ "./node_modules/capi/esm/known/types/common.js");
/* harmony import */ var _state_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./state.js */ "./node_modules/capi/esm/known/types/state.js");
/* harmony import */ var _system_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./system.js */ "./node_modules/capi/esm/known/types/system.js");
/* harmony import */ var _todo_organize_these_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./todo_organize_these.js */ "./node_modules/capi/esm/known/types/todo_organize_these.js");







//# sourceMappingURL=mod.js.map

/***/ }),

/***/ "./node_modules/capi/esm/known/types/state.js":
/*!****************************************************!*\
  !*** ./node_modules/capi/esm/known/types/state.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=state.js.map

/***/ }),

/***/ "./node_modules/capi/esm/known/types/system.js":
/*!*****************************************************!*\
  !*** ./node_modules/capi/esm/known/types/system.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=system.js.map

/***/ }),

/***/ "./node_modules/capi/esm/known/types/todo_organize_these.js":
/*!******************************************************************!*\
  !*** ./node_modules/capi/esm/known/types/todo_organize_these.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=todo_organize_these.js.map

/***/ }),

/***/ "./node_modules/capi/esm/mod.js":
/*!**************************************!*\
  !*** ./node_modules/capi/esm/mod.js ***!
  \**************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$": function() { return /* reexport module object */ _deps_scale_js__WEBPACK_IMPORTED_MODULE_1__; },
/* harmony export */   "$era": function() { return /* reexport safe */ _frame_metadata_mod_js__WEBPACK_IMPORTED_MODULE_3__.$era; },
/* harmony export */   "$extrinsic": function() { return /* reexport safe */ _effect_mod_js__WEBPACK_IMPORTED_MODULE_2__.$extrinsic; },
/* harmony export */   "$key": function() { return /* reexport safe */ _effect_mod_js__WEBPACK_IMPORTED_MODULE_2__.$key; },
/* harmony export */   "$null": function() { return /* reexport safe */ _frame_metadata_mod_js__WEBPACK_IMPORTED_MODULE_3__.$null; },
/* harmony export */   "$storageKey": function() { return /* reexport safe */ _effect_mod_js__WEBPACK_IMPORTED_MODULE_2__.$storageKey; },
/* harmony export */   "Atom": function() { return /* reexport safe */ _effect_mod_js__WEBPACK_IMPORTED_MODULE_2__.Atom; },
/* harmony export */   "BitSequence": function() { return /* reexport safe */ _deps_scale_js__WEBPACK_IMPORTED_MODULE_1__.BitSequence; },
/* harmony export */   "ChainError": function() { return /* reexport safe */ _frame_metadata_mod_js__WEBPACK_IMPORTED_MODULE_3__.ChainError; },
/* harmony export */   "Config": function() { return /* reexport safe */ _config_mod_js__WEBPACK_IMPORTED_MODULE_0__.Config; },
/* harmony export */   "Effect": function() { return /* reexport safe */ _effect_mod_js__WEBPACK_IMPORTED_MODULE_2__.Effect; },
/* harmony export */   "M": function() { return /* reexport module object */ _frame_metadata_mod_js__WEBPACK_IMPORTED_MODULE_3__; },
/* harmony export */   "MetadataDecodeError": function() { return /* reexport safe */ _effect_mod_js__WEBPACK_IMPORTED_MODULE_2__.MetadataDecodeError; },
/* harmony export */   "ReadingKeysOfNonMapError": function() { return /* reexport safe */ _effect_mod_js__WEBPACK_IMPORTED_MODULE_2__.ReadingKeysOfNonMapError; },
/* harmony export */   "RpcSubscriptionError": function() { return /* reexport safe */ _effect_mod_js__WEBPACK_IMPORTED_MODULE_2__.RpcSubscriptionError; },
/* harmony export */   "all": function() { return /* reexport safe */ _effect_mod_js__WEBPACK_IMPORTED_MODULE_2__.all; },
/* harmony export */   "anon": function() { return /* reexport safe */ _effect_mod_js__WEBPACK_IMPORTED_MODULE_2__.anon; },
/* harmony export */   "atom": function() { return /* reexport safe */ _effect_mod_js__WEBPACK_IMPORTED_MODULE_2__.atom; },
/* harmony export */   "atomFactory": function() { return /* reexport safe */ _effect_mod_js__WEBPACK_IMPORTED_MODULE_2__.atomFactory; },
/* harmony export */   "codec": function() { return /* reexport safe */ _effect_mod_js__WEBPACK_IMPORTED_MODULE_2__.codec; },
/* harmony export */   "decoded": function() { return /* reexport safe */ _effect_mod_js__WEBPACK_IMPORTED_MODULE_2__.decoded; },
/* harmony export */   "deriveCodec": function() { return /* reexport safe */ _effect_mod_js__WEBPACK_IMPORTED_MODULE_2__.deriveCodec; },
/* harmony export */   "entryMetadata": function() { return /* reexport safe */ _effect_mod_js__WEBPACK_IMPORTED_MODULE_2__.entryMetadata; },
/* harmony export */   "hex": function() { return /* reexport safe */ _util_mod_js__WEBPACK_IMPORTED_MODULE_5__.hex; },
/* harmony export */   "into": function() { return /* reexport safe */ _effect_mod_js__WEBPACK_IMPORTED_MODULE_2__.into; },
/* harmony export */   "kusama": function() { return /* reexport safe */ _known_mod_js__WEBPACK_IMPORTED_MODULE_4__.kusama; },
/* harmony export */   "mapCreateWatchHandler": function() { return /* reexport safe */ _util_mod_js__WEBPACK_IMPORTED_MODULE_5__.mapCreateWatchHandler; },
/* harmony export */   "metadata": function() { return /* reexport safe */ _effect_mod_js__WEBPACK_IMPORTED_MODULE_2__.metadata; },
/* harmony export */   "moonbeam": function() { return /* reexport safe */ _known_mod_js__WEBPACK_IMPORTED_MODULE_4__.moonbeam; },
/* harmony export */   "palletMetadata": function() { return /* reexport safe */ _effect_mod_js__WEBPACK_IMPORTED_MODULE_2__.palletMetadata; },
/* harmony export */   "parseMetadata": function() { return /* reexport safe */ _effect_mod_js__WEBPACK_IMPORTED_MODULE_2__.parseMetadata; },
/* harmony export */   "polkadot": function() { return /* reexport safe */ _known_mod_js__WEBPACK_IMPORTED_MODULE_4__.polkadot; },
/* harmony export */   "readBlock": function() { return /* reexport safe */ _effect_mod_js__WEBPACK_IMPORTED_MODULE_2__.readBlock; },
/* harmony export */   "readEntry": function() { return /* reexport safe */ _effect_mod_js__WEBPACK_IMPORTED_MODULE_2__.readEntry; },
/* harmony export */   "readKeyPage": function() { return /* reexport safe */ _effect_mod_js__WEBPACK_IMPORTED_MODULE_2__.readKeyPage; },
/* harmony export */   "rococo": function() { return /* reexport safe */ _known_mod_js__WEBPACK_IMPORTED_MODULE_4__.rococo; },
/* harmony export */   "rpcCall": function() { return /* reexport safe */ _effect_mod_js__WEBPACK_IMPORTED_MODULE_2__.rpcCall; },
/* harmony export */   "rpcClient": function() { return /* reexport safe */ _effect_mod_js__WEBPACK_IMPORTED_MODULE_2__.rpcClient; },
/* harmony export */   "rpcSubscription": function() { return /* reexport safe */ _effect_mod_js__WEBPACK_IMPORTED_MODULE_2__.rpcSubscription; },
/* harmony export */   "run": function() { return /* reexport safe */ _effect_mod_js__WEBPACK_IMPORTED_MODULE_2__.run; },
/* harmony export */   "select": function() { return /* reexport safe */ _effect_mod_js__WEBPACK_IMPORTED_MODULE_2__.select; },
/* harmony export */   "sendAndWatchExtrinsic": function() { return /* reexport safe */ _effect_mod_js__WEBPACK_IMPORTED_MODULE_2__.sendAndWatchExtrinsic; },
/* harmony export */   "storageKey": function() { return /* reexport safe */ _effect_mod_js__WEBPACK_IMPORTED_MODULE_2__.storageKey; },
/* harmony export */   "watchBlocks": function() { return /* reexport safe */ _effect_mod_js__WEBPACK_IMPORTED_MODULE_2__.watchBlocks; },
/* harmony export */   "watchEntry": function() { return /* reexport safe */ _effect_mod_js__WEBPACK_IMPORTED_MODULE_2__.watchEntry; },
/* harmony export */   "watchIter": function() { return /* reexport safe */ _util_mod_js__WEBPACK_IMPORTED_MODULE_5__.watchIter; },
/* harmony export */   "westend": function() { return /* reexport safe */ _known_mod_js__WEBPACK_IMPORTED_MODULE_4__.westend; },
/* harmony export */   "wrap": function() { return /* reexport safe */ _effect_mod_js__WEBPACK_IMPORTED_MODULE_2__.wrap; }
/* harmony export */ });
/* harmony import */ var _config_mod_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config/mod.js */ "./node_modules/capi/esm/config/mod.js");
/* harmony import */ var _deps_scale_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./deps/scale.js */ "./node_modules/capi/esm/deps/scale.js");
/* harmony import */ var _effect_mod_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./effect/mod.js */ "./node_modules/capi/esm/effect/mod.js");
/* harmony import */ var _frame_metadata_mod_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./frame_metadata/mod.js */ "./node_modules/capi/esm/frame_metadata/mod.js");
/* harmony import */ var _known_mod_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./known/mod.js */ "./node_modules/capi/esm/known/mod.js");
/* harmony import */ var _util_mod_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./util/mod.js */ "./node_modules/capi/esm/util/mod.js");






 // TODO: get rid of this!

//# sourceMappingURL=mod.js.map

/***/ }),

/***/ "./node_modules/capi/esm/rpc/Base.js":
/*!*******************************************!*\
  !*** ./node_modules/capi/esm/rpc/Base.js ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Client": function() { return /* binding */ Client; }
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/capi/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _deps_std_async_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../deps/std/async.js */ "./node_modules/capi/esm/deps/std/async.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ "./node_modules/capi/esm/rpc/util.js");
var _Client_nextId, _Client_listenerCbs;



class Client {
    /**
     * Construct a new RPC client
     *
     * @param hooks the error handling and message hooks with which you'd like the instance to operate
     */
    constructor(provider, hooks) {
        Object.defineProperty(this, "provider", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: provider
        });
        Object.defineProperty(this, "hooks", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: hooks
        });
        _Client_nextId.set(this, 0);
        _Client_listenerCbs.set(this, new Map());
        /**
         * Send a message to the RPC server
         *
         * @param egressMessage the message you wish to send to the RPC server
         */
        Object.defineProperty(this, "send", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (egressMessage) => {
                this.hooks?.send?.(egressMessage);
                this.provider.send(egressMessage);
            }
        });
        Object.defineProperty(this, "close", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: () => {
                this.hooks?.close?.();
                return this.provider.close();
            }
        });
        /** @returns a new ID, unique to the client instance */
        Object.defineProperty(this, "uid", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: () => {
                var _a, _b;
                return ((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__classPrivateFieldSet)(this, _Client_nextId, (_b = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__classPrivateFieldGet)(this, _Client_nextId, "f"), _a = _b++, _b), "f"), _a).toString();
            }
        });
        /**
         * Attach a listener to handle ingress messages
         *
         * @param createListenerCb the factory for the callback to be triggered upon arrival of ingress messages
         */
        Object.defineProperty(this, "listen", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (createListenerCb) => {
                const stopListening = () => {
                    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__classPrivateFieldGet)(this, _Client_listenerCbs, "f").delete(listenerCb);
                };
                const listenerCb = createListenerCb(stopListening);
                (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__classPrivateFieldGet)(this, _Client_listenerCbs, "f").set(listenerCb, true);
            }
        });
        // TODO: do we want to parameterize `RpcClient` with a `RawMessage` type?
        /** @internal */
        Object.defineProperty(this, "onMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (message) => {
                const parsed = this.provider.parseIngressMessage(message);
                if (parsed instanceof Error) {
                    this.hooks?.error?.(parsed);
                }
                else {
                    this.hooks?.receive?.(parsed);
                    for (const listener of (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__classPrivateFieldGet)(this, _Client_listenerCbs, "f").keys()) {
                        listener(parsed);
                    }
                }
            }
        });
        /** @internal */
        Object.defineProperty(this, "onError", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (error) => {
                this.hooks?.error?.(error);
            }
        });
        /**
         * Call an RPC method and return a promise resolving to an ingress message with an ID that matches the egress message
         *
         * @param methodName the name of the method you wish to call
         * @param params the params with which to call the method
         * @returns an ingress message corresponding to the given method (or a message-agnostic error)
         */
        Object.defineProperty(this, "call", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (methodName, params) => {
                const init = {
                    jsonrpc: "2.0",
                    id: this.uid(),
                    method: methodName,
                    params,
                };
                const isCorrespondingRes = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.IsCorrespondingRes)(init);
                const ingressMessagePending = (0,_deps_std_async_js__WEBPACK_IMPORTED_MODULE_0__.deferred)();
                this.listen((stopListening) => {
                    return (res) => {
                        if (isCorrespondingRes(res)) {
                            stopListening();
                            ingressMessagePending.resolve(res);
                        }
                    };
                });
                this.send(init);
                return ingressMessagePending;
            }
        });
        /**
         * Initialize an RPC subscription
         *
         * @param methodName the method name of the subscription you wish to init
         * @param params the params with which to init the subscription
         * @param createListenerCb the factory of the callback to which notifications should be supplied
         */
        Object.defineProperty(this, "subscribe", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (methodName, params, createListenerCb, cleanup = () => Promise.resolve()) => {
                const initRes = await this.call(methodName, params);
                if (initRes.error) {
                    // TODO: fix typings
                    return initRes;
                }
                const cleanupApplied = () => cleanup(initRes);
                const terminalPending = (0,_deps_std_async_js__WEBPACK_IMPORTED_MODULE_0__.deferred)();
                this.listen((stop) => {
                    const listenerCb = createListenerCb(async () => {
                        stop();
                        await cleanupApplied();
                        terminalPending.resolve();
                    });
                    return (res) => {
                        if (res.params?.subscription && res.params.subscription === initRes.result) {
                            listenerCb(res);
                        }
                        else {
                            // TODO: associate errors with subscriptions & exit
                        }
                    };
                });
                return await terminalPending;
            }
        });
    }
}
_Client_nextId = new WeakMap(), _Client_listenerCbs = new WeakMap();
//# sourceMappingURL=Base.js.map

/***/ }),

/***/ "./node_modules/capi/esm/rpc/common.js":
/*!*********************************************!*\
  !*** ./node_modules/capi/esm/rpc/common.js ***!
  \*********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ParseRawIngressMessageError": function() { return /* binding */ ParseRawIngressMessageError; }
/* harmony export */ });
/* harmony import */ var _util_mod_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/mod.js */ "./node_modules/capi/esm/util/mod.js");

class ParseRawIngressMessageError extends (0,_util_mod_js__WEBPACK_IMPORTED_MODULE_0__.ErrorCtor)("ParseRawIngressMessage") {
}
//# sourceMappingURL=common.js.map

/***/ }),

/***/ "./node_modules/capi/esm/rpc/messages.js":
/*!***********************************************!*\
  !*** ./node_modules/capi/esm/rpc/messages.js ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=messages.js.map

/***/ }),

/***/ "./node_modules/capi/esm/rpc/mod.js":
/*!******************************************!*\
  !*** ./node_modules/capi/esm/rpc/mod.js ***!
  \******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Client": function() { return /* reexport safe */ _Base_js__WEBPACK_IMPORTED_MODULE_0__.Client; },
/* harmony export */   "FailedToAddChainError": function() { return /* reexport safe */ _providers_smoldot_js__WEBPACK_IMPORTED_MODULE_4__.FailedToAddChainError; },
/* harmony export */   "FailedToDisconnectError": function() { return /* reexport safe */ _providers_proxy_js__WEBPACK_IMPORTED_MODULE_3__.FailedToDisconnectError; },
/* harmony export */   "FailedToOpenConnectionError": function() { return /* reexport safe */ _providers_proxy_js__WEBPACK_IMPORTED_MODULE_3__.FailedToOpenConnectionError; },
/* harmony export */   "FailedToRemoveChainError": function() { return /* reexport safe */ _providers_smoldot_js__WEBPACK_IMPORTED_MODULE_4__.FailedToRemoveChainError; },
/* harmony export */   "FailedToStartSmoldotError": function() { return /* reexport safe */ _providers_smoldot_js__WEBPACK_IMPORTED_MODULE_4__.FailedToStartSmoldotError; },
/* harmony export */   "IsCorrespondingRes": function() { return /* reexport safe */ _util_js__WEBPACK_IMPORTED_MODULE_6__.IsCorrespondingRes; },
/* harmony export */   "ParseRawIngressMessageError": function() { return /* reexport safe */ _common_js__WEBPACK_IMPORTED_MODULE_1__.ParseRawIngressMessageError; },
/* harmony export */   "ProxyClient": function() { return /* reexport safe */ _providers_proxy_js__WEBPACK_IMPORTED_MODULE_3__.ProxyClient; },
/* harmony export */   "SmoldotClient": function() { return /* reexport safe */ _providers_smoldot_js__WEBPACK_IMPORTED_MODULE_4__.SmoldotClient; },
/* harmony export */   "SmoldotInternalError": function() { return /* reexport safe */ _providers_smoldot_js__WEBPACK_IMPORTED_MODULE_4__.SmoldotInternalError; },
/* harmony export */   "proxyClient": function() { return /* reexport safe */ _providers_proxy_js__WEBPACK_IMPORTED_MODULE_3__.proxyClient; },
/* harmony export */   "smoldotClient": function() { return /* reexport safe */ _providers_smoldot_js__WEBPACK_IMPORTED_MODULE_4__.smoldotClient; },
/* harmony export */   "stdClient": function() { return /* reexport safe */ _providers_std_js__WEBPACK_IMPORTED_MODULE_5__.stdClient; }
/* harmony export */ });
/* harmony import */ var _Base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.js */ "./node_modules/capi/esm/rpc/Base.js");
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common.js */ "./node_modules/capi/esm/rpc/common.js");
/* harmony import */ var _messages_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./messages.js */ "./node_modules/capi/esm/rpc/messages.js");
/* harmony import */ var _providers_proxy_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./providers/proxy.js */ "./node_modules/capi/esm/rpc/providers/proxy.js");
/* harmony import */ var _providers_smoldot_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./providers/smoldot.js */ "./node_modules/capi/esm/rpc/providers/smoldot.js");
/* harmony import */ var _providers_std_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./providers/std.js */ "./node_modules/capi/esm/rpc/providers/std.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./util.js */ "./node_modules/capi/esm/rpc/util.js");







//# sourceMappingURL=mod.js.map

/***/ }),

/***/ "./node_modules/capi/esm/rpc/providers/proxy.js":
/*!******************************************************!*\
  !*** ./node_modules/capi/esm/rpc/providers/proxy.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FailedToDisconnectError": function() { return /* binding */ FailedToDisconnectError; },
/* harmony export */   "FailedToOpenConnectionError": function() { return /* binding */ FailedToOpenConnectionError; },
/* harmony export */   "ProxyClient": function() { return /* binding */ ProxyClient; },
/* harmony export */   "proxyClient": function() { return /* binding */ proxyClient; }
/* harmony export */ });
/* harmony import */ var _deps_std_async_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../deps/std/async.js */ "./node_modules/capi/esm/deps/std/async.js");
/* harmony import */ var _util_mod_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/mod.js */ "./node_modules/capi/esm/util/mod.js");
/* harmony import */ var _Base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Base.js */ "./node_modules/capi/esm/rpc/Base.js");
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common.js */ "./node_modules/capi/esm/rpc/common.js");




async function proxyClient(config, hooks) {
    const ws = new WebSocket(await config.discoveryValue);
    const client = new ProxyClient(ws, hooks);
    ws.addEventListener("error", client.onError);
    ws.addEventListener("message", client.onMessage);
    const pending = (0,_deps_std_async_js__WEBPACK_IMPORTED_MODULE_0__.deferred)();
    if (ws.readyState === WebSocket.CONNECTING) {
        const onOpenError = (e) => {
            console.log({ log: e });
            clearListeners();
            pending.resolve(new FailedToOpenConnectionError());
        };
        const onOpen = () => {
            clearListeners();
            pending.resolve(client);
        };
        const clearListeners = () => {
            ws.removeEventListener("error", onOpenError);
            ws.removeEventListener("open", onOpen);
        };
        ws.addEventListener("error", onOpenError);
        ws.addEventListener("open", onOpen);
    }
    else {
        pending.resolve(client);
    }
    return await pending;
}
class ProxyClient extends _Base_js__WEBPACK_IMPORTED_MODULE_2__.Client {
    constructor(ws, hooks) {
        super({
            parseIngressMessage: (e) => {
                if (typeof e !== "object"
                    || e === null
                    || !("data" in e)
                    || typeof e.data !== "string") {
                    return new _common_js__WEBPACK_IMPORTED_MODULE_3__.ParseRawIngressMessageError();
                }
                return JSON.parse(e.data);
            },
            send: (egressMessage) => {
                ws.send(JSON.stringify(egressMessage));
            },
            close: async () => {
                const pending = (0,_deps_std_async_js__WEBPACK_IMPORTED_MODULE_0__.deferred)();
                const onClose = () => {
                    ws.removeEventListener("error", this.onError);
                    ws.removeEventListener("message", this.onMessage);
                    ws.removeEventListener("close", onClose);
                    pending.resolve();
                };
                ws.addEventListener("close", onClose);
                ws.close();
                try {
                    await (0,_deps_std_async_js__WEBPACK_IMPORTED_MODULE_0__.deadline)(pending, 250);
                }
                catch (_e) {
                    pending.resolve(new FailedToDisconnectError());
                }
                return pending;
            },
        }, hooks);
    }
}
class FailedToOpenConnectionError extends (0,_util_mod_js__WEBPACK_IMPORTED_MODULE_1__.ErrorCtor)("FailedToOpenConnection") {
}
class FailedToDisconnectError extends (0,_util_mod_js__WEBPACK_IMPORTED_MODULE_1__.ErrorCtor)("FailedToDisconnect") {
}
//# sourceMappingURL=proxy.js.map

/***/ }),

/***/ "./node_modules/capi/esm/rpc/providers/smoldot.js":
/*!********************************************************!*\
  !*** ./node_modules/capi/esm/rpc/providers/smoldot.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FailedToAddChainError": function() { return /* binding */ FailedToAddChainError; },
/* harmony export */   "FailedToRemoveChainError": function() { return /* binding */ FailedToRemoveChainError; },
/* harmony export */   "FailedToStartSmoldotError": function() { return /* binding */ FailedToStartSmoldotError; },
/* harmony export */   "SmoldotClient": function() { return /* binding */ SmoldotClient; },
/* harmony export */   "SmoldotInternalError": function() { return /* binding */ SmoldotInternalError; },
/* harmony export */   "smoldotClient": function() { return /* binding */ smoldotClient; }
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "./node_modules/capi/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _util_mod_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/mod.js */ "./node_modules/capi/esm/util/mod.js");
/* harmony import */ var _Base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Base.js */ "./node_modules/capi/esm/rpc/Base.js");
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common.js */ "./node_modules/capi/esm/rpc/common.js");
var _SmoldotClient_chain;




async function smoldotClient(config, hooks) {
    const smoldotInstance = await ensureInstance();
    if (smoldotInstance instanceof Error) {
        return smoldotInstance;
    }
    const onMessageContainer = {};
    try {
        // TODO: wire up `onError`
        const chain = await smoldotInstance.addChain({
            chainSpec: await config.discoveryValue,
            jsonRpcCallback: (response) => {
                onMessageContainer.onMessage?.(response);
            },
        });
        return new SmoldotClient(onMessageContainer, chain.remove, hooks);
    }
    catch (e) {
        return new FailedToAddChainError(e);
    }
}
class SmoldotClient extends _Base_js__WEBPACK_IMPORTED_MODULE_1__.Client {
    constructor(onMessageContainer, remove, hooks) {
        super({
            parseIngressMessage: (rawIngressMessage) => {
                try {
                    return JSON.parse(rawIngressMessage);
                }
                catch (_e) {
                    return new _common_js__WEBPACK_IMPORTED_MODULE_2__.ParseRawIngressMessageError();
                }
            },
            send: (egressMessage) => {
                (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__classPrivateFieldGet)(this, _SmoldotClient_chain, "f")?.sendJsonRpc(JSON.stringify(egressMessage));
            },
            close: () => {
                return Promise.resolve((() => {
                    try {
                        this.remove();
                        return;
                    }
                    catch (e) {
                        return new FailedToRemoveChainError(e);
                    }
                })());
            },
        }, hooks);
        Object.defineProperty(this, "remove", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: remove
        });
        _SmoldotClient_chain.set(this, void 0);
        onMessageContainer.onMessage = this.onMessage;
    }
}
_SmoldotClient_chain = new WeakMap();
const _state = {};
async function ensureInstance() {
    if (!_state.smoldotInstance) {
        try {
            const smoldot = await __webpack_require__.e(/*! import() */ "vendors-node_modules_capi_esm_deps_smoldot_js").then(__webpack_require__.bind(__webpack_require__, /*! ../../deps/smoldot.js */ "./node_modules/capi/esm/deps/smoldot.js"));
            _state.smoldotInstance = smoldot.start();
        }
        catch (_e) {
            return new FailedToStartSmoldotError();
        }
    }
    return _state.smoldotInstance;
}
class FailedToStartSmoldotError extends (0,_util_mod_js__WEBPACK_IMPORTED_MODULE_0__.ErrorCtor)("FailedToStartSmoldot") {
}
class FailedToAddChainError extends (0,_util_mod_js__WEBPACK_IMPORTED_MODULE_0__.ErrorCtor)("FailedToAddChain") {
    constructor(inner) {
        super();
        Object.defineProperty(this, "inner", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: inner
        });
    }
}
class SmoldotInternalError extends (0,_util_mod_js__WEBPACK_IMPORTED_MODULE_0__.ErrorCtor)("SmoldotInternal") {
}
// TODO: specify narrow `AlreadyDestroyedError` & `CrashError` from Smoldot
class FailedToRemoveChainError extends (0,_util_mod_js__WEBPACK_IMPORTED_MODULE_0__.ErrorCtor)("FailedToRemoveChain") {
    constructor(inner) {
        super();
        Object.defineProperty(this, "inner", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: inner
        });
    }
}
//# sourceMappingURL=smoldot.js.map

/***/ }),

/***/ "./node_modules/capi/esm/rpc/providers/std.js":
/*!****************************************************!*\
  !*** ./node_modules/capi/esm/rpc/providers/std.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "stdClient": function() { return /* binding */ stdClient; }
/* harmony export */ });
/* harmony import */ var _deps_std_testing_asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../deps/std/testing/asserts.js */ "./node_modules/capi/esm/deps/std/testing/asserts.js");
/* harmony import */ var _proxy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./proxy.js */ "./node_modules/capi/esm/rpc/providers/proxy.js");
/* harmony import */ var _smoldot_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./smoldot.js */ "./node_modules/capi/esm/rpc/providers/smoldot.js");



async function stdClient(config) {
    const discoveryValue = await config.discoveryValue;
    if (typeof discoveryValue === "string") {
        // TODO: improve check / move selection elsewhere
        if (discoveryValue.startsWith("ws")) {
            return (0,_proxy_js__WEBPACK_IMPORTED_MODULE_1__.proxyClient)(config);
        }
        else {
            return (0,_smoldot_js__WEBPACK_IMPORTED_MODULE_2__.smoldotClient)(config);
        }
    }
    return (0,_deps_std_testing_asserts_js__WEBPACK_IMPORTED_MODULE_0__.unimplemented)();
}
//# sourceMappingURL=std.js.map

/***/ }),

/***/ "./node_modules/capi/esm/rpc/util.js":
/*!*******************************************!*\
  !*** ./node_modules/capi/esm/rpc/util.js ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IsCorrespondingRes": function() { return /* binding */ IsCorrespondingRes; }
/* harmony export */ });
function IsCorrespondingRes(init) {
    return (inQuestion) => {
        return inQuestion?.id === init.id;
    };
}
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/capi/esm/ss58/mod.js":
/*!*******************************************!*\
  !*** ./node_modules/capi/esm/ss58/mod.js ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InvalidAddressChecksumError": function() { return /* binding */ InvalidAddressChecksumError; },
/* harmony export */   "InvalidAddressLengthError": function() { return /* binding */ InvalidAddressLengthError; },
/* harmony export */   "InvalidNetworkPrefixError": function() { return /* binding */ InvalidNetworkPrefixError; },
/* harmony export */   "InvalidPublicKeyLengthError": function() { return /* binding */ InvalidPublicKeyLengthError; },
/* harmony export */   "decode": function() { return /* binding */ decode; },
/* harmony export */   "decodeRaw": function() { return /* binding */ decodeRaw; },
/* harmony export */   "encode": function() { return /* binding */ encode; },
/* harmony export */   "encodeRaw": function() { return /* binding */ encodeRaw; }
/* harmony export */ });
/* harmony import */ var _deps_blake2b_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../deps/blake2b.js */ "./node_modules/capi/esm/deps/blake2b.js");
/* harmony import */ var _deps_std_encoding_base58_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../deps/std/encoding/base58.js */ "./node_modules/capi/esm/deps/std/encoding/base58.js");
/* harmony import */ var _util_mod_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/mod.js */ "./node_modules/capi/esm/util/mod.js");



// SS58PRE string (0x53533538505245 hex) encoded as Uint8Array
const SS58PRE = Uint8Array.of(83, 83, 53, 56, 80, 82, 69);
const CHECKSUM_LENGTH = 2;
const VALID_ADDRESS_LENGTHS = {
    35: true,
    36: true,
    37: true,
    38: true,
};
const VALID_PUBLIC_KEY_LENGTHS = {
    32: true,
    33: true,
};
class InvalidPublicKeyLengthError extends _util_mod_js__WEBPACK_IMPORTED_MODULE_2__.ErrorCtor("InvalidPublicKeyLengthError") {
}
class InvalidNetworkPrefixError extends _util_mod_js__WEBPACK_IMPORTED_MODULE_2__.ErrorCtor("InvalidNetworkPrefixError") {
}
class InvalidAddressLengthError extends _util_mod_js__WEBPACK_IMPORTED_MODULE_2__.ErrorCtor("InvalidAddressError") {
}
class InvalidAddressChecksumError extends _util_mod_js__WEBPACK_IMPORTED_MODULE_2__.ErrorCtor("InvalidAddressChecksumError") {
}
const encode = (prefix, pubKey, validNetworkPrefixes) => _deps_std_encoding_base58_js__WEBPACK_IMPORTED_MODULE_1__.encode(encodeRaw(prefix, pubKey, validNetworkPrefixes));
const encodeRaw = (prefix, pubKey, validNetworkPrefixes) => {
    const isValidPublicKeyLength = !!VALID_PUBLIC_KEY_LENGTHS[pubKey.length];
    if (!isValidPublicKeyLength) {
        throw new InvalidPublicKeyLengthError();
    }
    const isValidNetworkPrefix = !validNetworkPrefixes || validNetworkPrefixes.includes(prefix);
    if (!isValidNetworkPrefix) {
        throw new InvalidNetworkPrefixError();
    }
    const prefixBytes = prefix < 64
        ? Uint8Array.of(prefix)
        : Uint8Array.of(((prefix & 252) >> 2) | 64, (prefix >> 8) | ((prefix & 3) << 6));
    const hasher = _deps_blake2b_js__WEBPACK_IMPORTED_MODULE_0__.blake2b.create({
        dkLen: 512 / 8,
    });
    hasher.update(SS58PRE);
    hasher.update(prefixBytes);
    hasher.update(pubKey);
    const digest = hasher.digest();
    const checksum = digest.subarray(0, CHECKSUM_LENGTH);
    const address = new Uint8Array(prefixBytes.length + pubKey.length + CHECKSUM_LENGTH);
    address.set(prefixBytes, 0);
    address.set(pubKey, prefixBytes.length);
    address.set(checksum, prefixBytes.length + pubKey.length);
    return address;
};
const decode = (address) => decodeRaw(_deps_std_encoding_base58_js__WEBPACK_IMPORTED_MODULE_1__.decode(address));
const decodeRaw = (address) => {
    const isValidAddressLength = !!VALID_ADDRESS_LENGTHS[address.length];
    if (!isValidAddressLength) {
        throw new InvalidAddressLengthError();
    }
    const prefixLength = address[0] & 64 ? 2 : 1;
    const prefix = prefixLength === 1
        ? address[0]
        : ((address[0] & 63) << 2) | (address[1] >> 6)
            | ((address[1] & 63) << 8);
    const hasher = _deps_blake2b_js__WEBPACK_IMPORTED_MODULE_0__.blake2b.create({
        dkLen: 512 / 8,
    });
    hasher.update(SS58PRE);
    hasher.update(address.subarray(0, address.length - CHECKSUM_LENGTH));
    const digest = hasher.digest();
    const checksum = address.subarray(address.length - CHECKSUM_LENGTH);
    if (digest[0] !== checksum[0] || digest[1] !== checksum[1]) {
        throw new InvalidAddressChecksumError();
    }
    const pubKey = address.subarray(prefixLength, address.length - CHECKSUM_LENGTH);
    return [prefix, pubKey];
};
//# sourceMappingURL=mod.js.map

/***/ }),

/***/ "./node_modules/capi/esm/util/branded.js":
/*!***********************************************!*\
  !*** ./node_modules/capi/esm/util/branded.js ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AccountIdStringBrand": function() { return /* binding */ AccountIdStringBrand; },
/* harmony export */   "H256StringBrand": function() { return /* binding */ H256StringBrand; },
/* harmony export */   "HashHexStringBrand": function() { return /* binding */ HashHexStringBrand; },
/* harmony export */   "HexStringBrand": function() { return /* binding */ HexStringBrand; },
/* harmony export */   "HexU64StringBrand": function() { return /* binding */ HexU64StringBrand; },
/* harmony export */   "MultiAddressStringBrand": function() { return /* binding */ MultiAddressStringBrand; },
/* harmony export */   "SubscriptionIdStringBrand": function() { return /* binding */ SubscriptionIdStringBrand; }
/* harmony export */ });
const HexStringBrand = Symbol();
const HashHexStringBrand = Symbol();
const AccountIdStringBrand = Symbol();
const SubscriptionIdStringBrand = Symbol();
const MultiAddressStringBrand = Symbol();
const HexU64StringBrand = Symbol();
const H256StringBrand = Symbol();
//# sourceMappingURL=branded.js.map

/***/ }),

/***/ "./node_modules/capi/esm/util/error.js":
/*!*********************************************!*\
  !*** ./node_modules/capi/esm/util/error.js ***!
  \*********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ErrorCtor": function() { return /* binding */ ErrorCtor; },
/* harmony export */   "throwIfError": function() { return /* binding */ throwIfError; }
/* harmony export */ });
/** Produces an error whose name is represented within the type system */
function ErrorCtor(name) {
    return class extends Error {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: name
            });
        }
    };
}
function throwIfError(value) {
    if (value instanceof Error) {
        throw value;
    }
    return value;
}
//# sourceMappingURL=error.js.map

/***/ }),

/***/ "./node_modules/capi/esm/util/hex.js":
/*!*******************************************!*\
  !*** ./node_modules/capi/esm/util/hex.js ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "decode": function() { return /* binding */ decode; },
/* harmony export */   "decodeBuf": function() { return /* reexport safe */ _deps_std_encoding_hex_js__WEBPACK_IMPORTED_MODULE_0__.decode; },
/* harmony export */   "encode": function() { return /* binding */ encode; },
/* harmony export */   "encodeBuf": function() { return /* reexport safe */ _deps_std_encoding_hex_js__WEBPACK_IMPORTED_MODULE_0__.encode; },
/* harmony export */   "encodePrefixed": function() { return /* binding */ encodePrefixed; }
/* harmony export */ });
/* harmony import */ var _deps_std_encoding_hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../deps/std/encoding/hex.js */ "./node_modules/capi/esm/deps/std/encoding/hex.js");

function decode(hex) {
    if (hex.startsWith("0x"))
        hex = hex.slice(2);
    if (hex.length % 2 === 1)
        hex = "0" + hex;
    const array = new Uint8Array(hex.length / 2);
    for (let i = 0; i < hex.length; i++) {
        array[i] = parseInt(hex.slice(i * 2, i * 2 + 2), 16);
    }
    return array;
}
function encode(bytes) {
    let str = "";
    for (let i = 0; i < bytes.length; i++) {
        str += bytes[i].toString(16).padStart(2, "0");
    }
    return str;
}
function encodePrefixed(bytes) {
    return "0x" + encode(bytes);
}
//# sourceMappingURL=hex.js.map

/***/ }),

/***/ "./node_modules/capi/esm/util/mod.js":
/*!*******************************************!*\
  !*** ./node_modules/capi/esm/util/mod.js ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AccountIdStringBrand": function() { return /* reexport safe */ _branded_js__WEBPACK_IMPORTED_MODULE_0__.AccountIdStringBrand; },
/* harmony export */   "ErrorCtor": function() { return /* reexport safe */ _error_js__WEBPACK_IMPORTED_MODULE_1__.ErrorCtor; },
/* harmony export */   "H256StringBrand": function() { return /* reexport safe */ _branded_js__WEBPACK_IMPORTED_MODULE_0__.H256StringBrand; },
/* harmony export */   "HashHexStringBrand": function() { return /* reexport safe */ _branded_js__WEBPACK_IMPORTED_MODULE_0__.HashHexStringBrand; },
/* harmony export */   "HexStringBrand": function() { return /* reexport safe */ _branded_js__WEBPACK_IMPORTED_MODULE_0__.HexStringBrand; },
/* harmony export */   "HexU64StringBrand": function() { return /* reexport safe */ _branded_js__WEBPACK_IMPORTED_MODULE_0__.HexU64StringBrand; },
/* harmony export */   "MultiAddressStringBrand": function() { return /* reexport safe */ _branded_js__WEBPACK_IMPORTED_MODULE_0__.MultiAddressStringBrand; },
/* harmony export */   "SubscriptionIdStringBrand": function() { return /* reexport safe */ _branded_js__WEBPACK_IMPORTED_MODULE_0__.SubscriptionIdStringBrand; },
/* harmony export */   "hex": function() { return /* reexport module object */ _hex_js__WEBPACK_IMPORTED_MODULE_2__; },
/* harmony export */   "mapCreateWatchHandler": function() { return /* reexport safe */ _watch_js__WEBPACK_IMPORTED_MODULE_4__.mapCreateWatchHandler; },
/* harmony export */   "throwIfError": function() { return /* reexport safe */ _error_js__WEBPACK_IMPORTED_MODULE_1__.throwIfError; },
/* harmony export */   "watchIter": function() { return /* reexport safe */ _watch_js__WEBPACK_IMPORTED_MODULE_4__.watchIter; }
/* harmony export */ });
/* harmony import */ var _branded_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./branded.js */ "./node_modules/capi/esm/util/branded.js");
/* harmony import */ var _error_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./error.js */ "./node_modules/capi/esm/util/error.js");
/* harmony import */ var _hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hex.js */ "./node_modules/capi/esm/util/hex.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./types.js */ "./node_modules/capi/esm/util/types.js");
/* harmony import */ var _watch_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./watch.js */ "./node_modules/capi/esm/util/watch.js");





//# sourceMappingURL=mod.js.map

/***/ }),

/***/ "./node_modules/capi/esm/util/types.js":
/*!*********************************************!*\
  !*** ./node_modules/capi/esm/util/types.js ***!
  \*********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/capi/esm/util/watch.js":
/*!*********************************************!*\
  !*** ./node_modules/capi/esm/util/watch.js ***!
  \*********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "mapCreateWatchHandler": function() { return /* binding */ mapCreateWatchHandler; },
/* harmony export */   "watchIter": function() { return /* binding */ watchIter; }
/* harmony export */ });
/* harmony import */ var _deps_std_async_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../deps/std/async.js */ "./node_modules/capi/esm/deps/std/async.js");

function mapCreateWatchHandler(createWatchHandler, map) {
    return (close) => {
        const listenerCb = createWatchHandler(close);
        return (message) => {
            listenerCb(map(message));
        };
    };
}
function watchIter() {
    const queue = [];
    const cbs = [];
    const onDoneContainer = {};
    const createWatchHandler = (stop) => {
        onDoneContainer.onDone = stop;
        return (value) => {
            const cb = cbs.shift();
            if (cb) {
                cb({
                    done: false,
                    value,
                });
            }
            else {
                queue.push(value);
            }
        };
    };
    const iter = {
        async next() {
            if (queue.length) {
                return {
                    done: false,
                    value: queue.shift(),
                };
            }
            const pending = (0,_deps_std_async_js__WEBPACK_IMPORTED_MODULE_0__.deferred)();
            cbs.push(pending.resolve);
            return await pending;
        },
        return() {
            onDoneContainer?.onDone?.();
            return Promise.resolve({
                done: true,
                value: undefined,
            });
        },
        [Symbol.asyncIterator]() {
            return this;
        },
    };
    return Object.assign(createWatchHandler, iter);
}
//# sourceMappingURL=watch.js.map

/***/ }),

/***/ "./node_modules/parity-scale-codec/esm/array/codec.js":
/*!************************************************************!*\
  !*** ./node_modules/parity-scale-codec/esm/array/codec.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "array": function() { return /* binding */ array; },
/* harmony export */   "sizedArray": function() { return /* binding */ sizedArray; },
/* harmony export */   "sizedUint8Array": function() { return /* binding */ sizedUint8Array; },
/* harmony export */   "sizedUint8array": function() { return /* binding */ sizedUint8array; },
/* harmony export */   "uint8Array": function() { return /* binding */ uint8Array; },
/* harmony export */   "uint8array": function() { return /* binding */ uint8array; }
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common.js */ "./node_modules/parity-scale-codec/esm/common.js");
/* harmony import */ var _compact_codec_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../compact/codec.js */ "./node_modules/parity-scale-codec/esm/compact/codec.js");


function sizedArray($el, length) {
    return (0,_common_js__WEBPACK_IMPORTED_MODULE_0__.createCodec)({
        name: "sizedArray",
        _metadata: [sizedArray, $el, length],
        _staticSize: $el._staticSize * length,
        _encode(buffer, value) {
            for (let i = 0; i < value.length; i++) {
                $el._encode(buffer, value[i]);
            }
        },
        _decode(buffer) {
            const value = Array(length);
            for (let i = 0; i < value.length; i++) {
                value[i] = $el._decode(buffer);
            }
            return value;
        },
    });
}
function array($el) {
    return (0,_common_js__WEBPACK_IMPORTED_MODULE_0__.createCodec)({
        name: "array",
        _metadata: [array, $el],
        _staticSize: _compact_codec_js__WEBPACK_IMPORTED_MODULE_1__.compactU32._staticSize,
        _encode(buffer, value) {
            _compact_codec_js__WEBPACK_IMPORTED_MODULE_1__.compactU32._encode(buffer, value.length);
            if (value.length) {
                buffer.pushAlloc(value.length * $el._staticSize);
                for (let i = 0; i < value.length; i++) {
                    $el._encode(buffer, value[i]);
                }
                buffer.popAlloc();
            }
        },
        _decode(buffer) {
            const length = _compact_codec_js__WEBPACK_IMPORTED_MODULE_1__.compactU32._decode(buffer);
            const value = Array(length);
            for (let i = 0; i < value.length; i++) {
                value[i] = $el._decode(buffer);
            }
            return value;
        },
    });
}
const uint8Array = (0,_common_js__WEBPACK_IMPORTED_MODULE_0__.createCodec)({
    name: "uint8Array",
    _metadata: null,
    _staticSize: _compact_codec_js__WEBPACK_IMPORTED_MODULE_1__.compactU32._staticSize,
    _encode(buffer, value) {
        _compact_codec_js__WEBPACK_IMPORTED_MODULE_1__.compactU32._encode(buffer, value.length);
        buffer.insertArray(value); // the contents of this will eventually be cloned by buffer
    },
    _decode(buffer) {
        const length = _compact_codec_js__WEBPACK_IMPORTED_MODULE_1__.compactU32._decode(buffer);
        const value = buffer.array.subarray(buffer.index, buffer.index + length);
        buffer.index += length;
        return value;
    },
});
function sizedUint8Array(length) {
    return (0,_common_js__WEBPACK_IMPORTED_MODULE_0__.createCodec)({
        name: "sizedUint8Array",
        _metadata: [sizedUint8Array, length],
        // We could set `_staticSize` to `length`, but in this case it will usually
        // more efficient to insert the array dynamically, rather than manually copy
        // the bytes.
        _staticSize: 0,
        _encode(buffer, value) {
            if (value.length !== length) {
                throw new _common_js__WEBPACK_IMPORTED_MODULE_0__.EncodeError(this, value, `Expected an array of size ${length}, got ${value.length}`);
            }
            buffer.insertArray(value); // the contents of this will eventually be cloned by buffer
        },
        _decode(buffer) {
            return buffer.array.subarray(buffer.index, buffer.index += length);
        },
    });
}
/** @deprecated Use `$.uint8Array` instead */
const uint8array = uint8Array;
/** @deprecated Use `$.sizedUint8Array` instead */
const sizedUint8array = sizedUint8Array;
//# sourceMappingURL=codec.js.map

/***/ }),

/***/ "./node_modules/parity-scale-codec/esm/bitSequence/codec.js":
/*!******************************************************************!*\
  !*** ./node_modules/parity-scale-codec/esm/bitSequence/codec.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BitSequence": function() { return /* binding */ BitSequence; },
/* harmony export */   "bitSequence": function() { return /* binding */ bitSequence; }
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common.js */ "./node_modules/parity-scale-codec/esm/common.js");
/* harmony import */ var _compact_codec_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../compact/codec.js */ "./node_modules/parity-scale-codec/esm/compact/codec.js");


class BitSequence {
    constructor(length = 0, data) {
        Object.defineProperty(this, "length", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: length
        });
        Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        const byteLength = Math.ceil(length / 8);
        data ??= new Uint8Array(byteLength);
        if (data.length !== byteLength) {
            throw new Error("Incorrectly sized Uint8Array passed to BitSequence constructor");
        }
        this.data = data;
    }
    static from(array) {
        const sequence = new BitSequence(array.length);
        for (let i = 0; i < array.length; i++) {
            sequence._setBit(i, array[i]);
        }
        return sequence;
    }
    get byteLength() {
        return this.data.length;
    }
    _hasBit(index) {
        return 0 <= index && index < this.length && index === Math.floor(index);
    }
    _getBit(index) {
        if (!this._hasBit(index))
            return undefined;
        const i = Math.floor(index / 8);
        const j = 7 - index % 8;
        return !!(this.data[i] & (1 << j));
    }
    _setBit(index, bit) {
        if (!this._hasBit(index))
            return false;
        const i = Math.floor(index / 8);
        const j = 7 - index % 8;
        this.data[i] = this.data[i] & ~(1 << j) | (+!!bit << j);
        return true;
    }
}
Object.setPrototypeOf(BitSequence.prototype, new Proxy(Object.prototype, {
    get: (target, k, receiver) => {
        const i = typeof k === "string" ? +k : NaN;
        if (isNaN(i))
            return Reflect.get(target, k, receiver);
        return receiver._getBit(i);
    },
    set: (target, k, v, receiver) => {
        const i = typeof k === "string" ? +k : NaN;
        if (isNaN(i))
            return Reflect.set(target, k, v, receiver);
        return receiver._setBit(i, v);
    },
}));
const bitSequence = (0,_common_js__WEBPACK_IMPORTED_MODULE_0__.createCodec)({
    name: "bitSequence",
    _metadata: null,
    _staticSize: _compact_codec_js__WEBPACK_IMPORTED_MODULE_1__.compactU32._staticSize,
    _encode(buffer, value) {
        _compact_codec_js__WEBPACK_IMPORTED_MODULE_1__.compactU32._encode(buffer, value.length);
        buffer.insertArray(value.data);
    },
    _decode(buffer) {
        const length = _compact_codec_js__WEBPACK_IMPORTED_MODULE_1__.compactU32._decode(buffer);
        const byteLength = Math.ceil(length / 8);
        return new BitSequence(length, buffer.array.subarray(buffer.index, buffer.index += byteLength));
    },
});
//# sourceMappingURL=codec.js.map

/***/ }),

/***/ "./node_modules/parity-scale-codec/esm/bool/codec.js":
/*!***********************************************************!*\
  !*** ./node_modules/parity-scale-codec/esm/bool/codec.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bool": function() { return /* binding */ bool; }
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common.js */ "./node_modules/parity-scale-codec/esm/common.js");

const bool = (0,_common_js__WEBPACK_IMPORTED_MODULE_0__.createCodec)({
    name: "boolean",
    _metadata: null,
    _staticSize: 1,
    _encode(buffer, value) {
        buffer.array[buffer.index++] = +value;
    },
    _decode(buffer) {
        return !!buffer.array[buffer.index++];
    },
});
//# sourceMappingURL=codec.js.map

/***/ }),

/***/ "./node_modules/parity-scale-codec/esm/common.js":
/*!*******************************************************!*\
  !*** ./node_modules/parity-scale-codec/esm/common.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CodecError": function() { return /* binding */ CodecError; },
/* harmony export */   "CodecVisitor": function() { return /* binding */ CodecVisitor; },
/* harmony export */   "Context": function() { return /* binding */ Context; },
/* harmony export */   "DecodeBuffer": function() { return /* binding */ DecodeBuffer; },
/* harmony export */   "DecodeError": function() { return /* binding */ DecodeError; },
/* harmony export */   "EncodeBuffer": function() { return /* binding */ EncodeBuffer; },
/* harmony export */   "EncodeError": function() { return /* binding */ EncodeError; },
/* harmony export */   "createAsyncCodec": function() { return /* binding */ createAsyncCodec; },
/* harmony export */   "createCodec": function() { return /* binding */ createCodec; },
/* harmony export */   "withMetadata": function() { return /* binding */ withMetadata; }
/* harmony export */ });
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _CodecVisitor_fallback, _CodecVisitor_visitors;
function createCodec(_codec) {
    const { _staticSize, _encode, _decode, _metadata, name } = _codec;
    const codec = {
        name,
        _staticSize,
        _encode,
        _decode,
        ..._metadata && { _metadata },
        encode(value) {
            const buf = new EncodeBuffer(_staticSize);
            _encode.call(codec, buf, value);
            if (buf.asyncCount)
                throw new EncodeError(codec, value, "Attempted to synchronously encode an async codec");
            return buf.finish();
        },
        async encodeAsync(value) {
            const buf = new EncodeBuffer(_staticSize);
            _encode.call(codec, buf, value);
            return buf.finishAsync();
        },
        decode(array) {
            const buf = new DecodeBuffer(array);
            return _decode.call(codec, buf);
        },
    };
    return codec;
}
function createAsyncCodec(_codec) {
    const { _staticSize, _encodeAsync, _decode, _metadata, name } = _codec;
    const codec = {
        name,
        _staticSize,
        _encode(buffer, value) {
            buffer.writeAsync(_staticSize, (buf) => _encodeAsync(buf, value));
        },
        _decode,
        ..._metadata && { _metadata },
        encode(value) {
            throw new EncodeError(codec, value, "Attempted to synchronously encode an async codec");
        },
        async encodeAsync(value) {
            const buf = new EncodeBuffer(_staticSize);
            await _encodeAsync.call(codec, buf, value);
            return buf.finishAsync();
        },
        decode(array) {
            const buf = new DecodeBuffer(array);
            return _decode.call(codec, buf);
        },
    };
    return codec;
}
function withMetadata(codec, metadata) {
    return { ...codec, _metadata: metadata };
}
class EncodeBuffer {
    /** Creates a new EncodeBuffer with a specified initial size/buffer */
    constructor(init, context = new Context()) {
        Object.defineProperty(this, "context", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: context
        });
        Object.defineProperty(this, "finishedArrays", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "finishedSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "queuedArrays", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "array", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "view", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "index", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "asyncCount", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "asyncPromise", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: Promise.resolve()
        });
        Object.defineProperty(this, "asyncResolve", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: () => { }
        });
        this._setArray(typeof init === "number" ? new Uint8Array(init) : init);
    }
    /**
     * Inserts a Uint8Array at the current position in the buffer.
     * This does not consume any of the pre-allocated space.
     */
    insertArray(buffer) {
        this._commitWritten();
        this.finishedArrays.push(buffer);
        this.finishedSize += buffer.length;
        if (this.index) {
            this._setArray(this.array.subarray(this.index));
        }
    }
    /**
     * Allocates more space in the EncodeBuffer.
     * `.popAlloc()` must be called after this space is used.
     */
    pushAlloc(size) {
        this._commitWritten();
        this.queuedArrays.push(this.array.subarray(this.index));
        this._setArray(new Uint8Array(size));
    }
    /**
     * Finishes the current array and resumes writing on the previous array.
     * Must be called after `.pushAlloc()`.
     */
    popAlloc() {
        this._commitWritten();
        this._setArray(this.queuedArrays.pop());
    }
    /**
     * Creates a sub-buffer that can be written into asynchronously.
     * The buffer passed to the callback should not be used after the returned promise resolves.
     */
    writeAsync(length, fn) {
        this.waitFor(async () => {
            const cursor = this.createCursor(length);
            await fn(cursor);
            cursor.close();
        });
    }
    /**
     * Creates a sub-buffer that can be written into later to insert data into the middle of the array.
     * `.close()` must be called after the cursor is done being written into.
     * The cursor should not be used after `.close()` is called.
     * If the cursor will be written into asynchronously, the buffer must be held open with `.waitFor()`.
     */
    createCursor(length) {
        const cursor = Object.assign(new EncodeBuffer(this.stealAlloc(length), this.context), {
            close: () => {
                this.waitForBuffer(cursor, () => {
                    cursor._commitWritten();
                    this.finishedSize += cursor.finishedSize;
                });
            },
        });
        this.finishedArrays.push(cursor);
        return cursor;
    }
    /**
     * Immediately invokes the callback, and holds the buffer open until the
     * returned promise resolves.
     */
    waitFor(fn) {
        if (!this.asyncCount) {
            this.asyncPromise = new Promise((resolve) => this.asyncResolve = resolve);
        }
        this.asyncCount++;
        fn()
            .then(() => {
            this.asyncCount--;
            if (!this.asyncCount) {
                this.asyncResolve();
            }
        })
            .catch((e) => {
            this.asyncResolve(Promise.reject(e));
        });
    }
    /**
     * Consumes `length` allocated bytes without writing anything, and returns the skipped subarray.
     * Anything written into the returned array will not affect the buffer,
     * except if it is later reincorporated e.g. via `.insertArray()`.
     * Rather niche.
     */
    stealAlloc(length) {
        this._commitWritten();
        const array = this.array.subarray(this.index, this.index + length);
        this._setArray(this.array.subarray(this.index + length));
        return array;
    }
    /**
     * Invokes the callback once buffer's async tasks finish, and holds this
     * buffer open until the callback returns.
     */
    waitForBuffer(buffer, fn) {
        if (buffer.asyncCount) {
            this.waitFor(async () => {
                await buffer.asyncPromise;
                fn();
            });
        }
        else {
            fn();
        }
    }
    /**
     * Finishes the current array, and returns a Uint8Array containing everything written.
     * The EncodeBuffer is left in an undefined state, and should not be used afterwards.
     * Throws if asynchronous writes are still pending.
     */
    finish() {
        if (this.asyncCount)
            throw new Error("Attempted to finish before async completion");
        if (!this.finishedArrays.length)
            return this.array.subarray(0, this.index);
        this._commitWritten();
        const fullArray = new Uint8Array(this.finishedSize);
        this._finishInto(fullArray, 0);
        return fullArray;
    }
    /**
     * Finishes the current array, and returns a Uint8Array containing everything written.
     * The EncodeBuffer is left in an undefined state, and should not be used afterwards.
     */
    async finishAsync() {
        await this.asyncPromise;
        return this.finish();
    }
    /** Copies all data from finishedArrays into fullArray */
    _finishInto(fullArray, index) {
        for (let i = 0; i < this.finishedArrays.length; i++) {
            const array = this.finishedArrays[i];
            if (array instanceof EncodeBuffer) {
                index = array._finishInto(fullArray, index);
            }
            else {
                fullArray.set(array, index);
                index += array.length;
            }
        }
        return index;
    }
    /**
     * Pushes the data written in array to finishedArrays.
     * Leaves the buffer in an invalid state -- array and index must be updated.
     */
    _commitWritten() {
        if (this.index) {
            this.finishedArrays.push(this.array.subarray(0, this.index));
            this.finishedSize += this.index;
        }
    }
    /** Sets array and updates view */
    _setArray(array) {
        this.array = array;
        this.view = new DataView(array.buffer, array.byteOffset, array.byteLength);
        this.index = 0;
    }
}
class DecodeBuffer {
    constructor(array) {
        Object.defineProperty(this, "array", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: array
        });
        Object.defineProperty(this, "view", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "index", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "context", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Context()
        });
        this.view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    }
}
class Context {
    constructor() {
        Object.defineProperty(this, "map", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
    }
    get(T) {
        let value = this.map.get(T);
        if (!value) {
            value = new T();
            this.map.set(T, value);
        }
        return value;
    }
}
class CodecVisitor {
    constructor() {
        _CodecVisitor_fallback.set(this, void 0);
        _CodecVisitor_visitors.set(this, new Map());
    }
    add(codec, fn) {
        if (__classPrivateFieldGet(this, _CodecVisitor_visitors, "f").has(codec)) {
            throw new Error("Duplicate visitor");
        }
        __classPrivateFieldGet(this, _CodecVisitor_visitors, "f").set(codec, fn);
        return this;
    }
    fallback(fn) {
        if (__classPrivateFieldGet(this, _CodecVisitor_fallback, "f")) {
            throw new Error("Duplicate fallback");
        }
        __classPrivateFieldSet(this, _CodecVisitor_fallback, fn, "f");
        return this;
    }
    /**
     * ```ts
     * visitor.generic(<T>() =>
     *   visitor.add($.array<T>, (codec, $el) => {
     *     ...
     *   })
     * )
     * ```
     */
    generic(fn) {
        fn(this);
        return this;
    }
    visit(codec) {
        const visitor = __classPrivateFieldGet(this, _CodecVisitor_visitors, "f").get(codec);
        if (visitor)
            return visitor(codec);
        if (codec._metadata) {
            const visitor = __classPrivateFieldGet(this, _CodecVisitor_visitors, "f").get(codec._metadata[0]);
            if (visitor)
                return visitor(codec, ...codec._metadata.slice(1));
        }
        if (__classPrivateFieldGet(this, _CodecVisitor_fallback, "f")) {
            return __classPrivateFieldGet(this, _CodecVisitor_fallback, "f").call(this, codec);
        }
        throw new Error("Unrecognized codec");
    }
}
_CodecVisitor_fallback = new WeakMap(), _CodecVisitor_visitors = new WeakMap();
class CodecError extends Error {
    constructor(codec, message) {
        super(message);
        Object.defineProperty(this, "codec", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: codec
        });
    }
}
class EncodeError extends CodecError {
    constructor(codec, value, message) {
        super(codec, message);
        Object.defineProperty(this, "value", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: value
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "EncodeError"
        });
    }
}
class DecodeError extends CodecError {
    constructor(codec, buffer, message) {
        super(codec, message);
        Object.defineProperty(this, "buffer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: buffer
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "DecodeError"
        });
    }
}
//# sourceMappingURL=common.js.map

/***/ }),

/***/ "./node_modules/parity-scale-codec/esm/compact/codec.js":
/*!**************************************************************!*\
  !*** ./node_modules/parity-scale-codec/esm/compact/codec.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "compactU128": function() { return /* binding */ compactU128; },
/* harmony export */   "compactU16": function() { return /* binding */ compactU16; },
/* harmony export */   "compactU256": function() { return /* binding */ compactU256; },
/* harmony export */   "compactU32": function() { return /* binding */ compactU32; },
/* harmony export */   "compactU64": function() { return /* binding */ compactU64; },
/* harmony export */   "compactU8": function() { return /* binding */ compactU8; }
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common.js */ "./node_modules/parity-scale-codec/esm/common.js");
/* harmony import */ var _int_codec_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../int/codec.js */ "./node_modules/parity-scale-codec/esm/int/codec.js");


const MAX_U6 = 0b00111111;
const MAX_U14 = 16383;
const MAX_U30 = 1073741823;
const compactNumber = (0,_common_js__WEBPACK_IMPORTED_MODULE_0__.createCodec)({
    name: "compactNumber",
    _metadata: null,
    _staticSize: 5,
    _encode(buffer, value) {
        if (value <= MAX_U6) {
            buffer.array[buffer.index++] = value << 2;
        }
        else if (value <= MAX_U14) {
            _int_codec_js__WEBPACK_IMPORTED_MODULE_1__.u16._encode(buffer, (value << 2) | 0b01);
        }
        else if (value <= MAX_U30) {
            // Because JS bitwise ops use *signed* 32-bit ints, this operation
            // produces negative values when `value >= 2 ** 29`. However, this is ok,
            // as `setUint32` correctly casts these negative values back to unsigned
            // 32-bit ints.
            _int_codec_js__WEBPACK_IMPORTED_MODULE_1__.u32._encode(buffer, (value << 2) | 0b10);
        }
        else {
            buffer.array[buffer.index++] = 0b11;
            _int_codec_js__WEBPACK_IMPORTED_MODULE_1__.u32._encode(buffer, value);
        }
    },
    _decode(buffer) {
        switch (buffer.array[buffer.index] & 0b11) {
            case 0:
                return buffer.array[buffer.index++] >> 2;
            case 1:
                return _int_codec_js__WEBPACK_IMPORTED_MODULE_1__.u16._decode(buffer) >> 2;
            case 2:
                // We use an unsigned right shift, as the default shift operator
                // uses signed 32-bit ints, which would yield invalid values.
                return _int_codec_js__WEBPACK_IMPORTED_MODULE_1__.u32._decode(buffer) >>> 2;
            default:
                if (buffer.array[buffer.index++] !== 3)
                    throw new _common_js__WEBPACK_IMPORTED_MODULE_0__.DecodeError(this, buffer, "Out of range for U32");
                return _int_codec_js__WEBPACK_IMPORTED_MODULE_1__.u32._decode(buffer);
        }
    },
});
const compactU8 = compactNumber;
const compactU16 = compactNumber;
const compactU32 = compactNumber;
const compactBigInt = (0,_common_js__WEBPACK_IMPORTED_MODULE_0__.createCodec)({
    name: "compactBigInt",
    _metadata: null,
    _staticSize: 5,
    _encode(buffer, value) {
        if (value <= 4294967295) {
            compactNumber._encode(buffer, Number(value));
            return;
        }
        let extraBytes = 0;
        let _value = value >> 32n;
        while (_value > 0n) {
            _value >>= 8n;
            extraBytes++;
        }
        buffer.array[buffer.index++] = (extraBytes << 2) | 0b11;
        _int_codec_js__WEBPACK_IMPORTED_MODULE_1__.u32._encode(buffer, Number(value & 0xffffffffn));
        _value = value >> 32n;
        buffer.pushAlloc(extraBytes);
        for (let i = 0; i < extraBytes; i++) {
            buffer.array[buffer.index++] = Number(_value & 0xffn);
            _value >>= 8n;
        }
        buffer.popAlloc();
    },
    _decode(buffer) {
        const b = buffer.array[buffer.index];
        if ((b & 0b11) < 3 || b === 3) {
            return BigInt(compactNumber._decode(buffer));
        }
        const extraBytes = b >> 2;
        buffer.index++;
        let value = BigInt(_int_codec_js__WEBPACK_IMPORTED_MODULE_1__.u32._decode(buffer));
        for (let i = 0; i < extraBytes; i++) {
            value |= BigInt(buffer.array[buffer.index++]) << BigInt(32 + i * 8);
        }
        return value;
    },
});
const compactU64 = compactBigInt;
const compactU128 = compactBigInt;
const compactU256 = compactBigInt;
//# sourceMappingURL=codec.js.map

/***/ }),

/***/ "./node_modules/parity-scale-codec/esm/constantPattern/codec.js":
/*!**********************************************************************!*\
  !*** ./node_modules/parity-scale-codec/esm/constantPattern/codec.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "constantPattern": function() { return /* binding */ constantPattern; }
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common.js */ "./node_modules/parity-scale-codec/esm/common.js");

function constantPattern(value, c) {
    const pattern = c instanceof Uint8Array ? c : c.encode(value);
    return (0,_common_js__WEBPACK_IMPORTED_MODULE_0__.createCodec)({
        name: "constantPattern",
        _metadata: [constantPattern, value, pattern],
        // We could set `_staticSize` to `pattern.length`, but in this case it will
        // usually more efficient to insert `pattern` dynamically, rather than
        // manually copy the bytes.
        _staticSize: 0,
        _encode(buffer, got) {
            if (got !== value) {
                throw new _common_js__WEBPACK_IMPORTED_MODULE_0__.EncodeError(this, got, `Invalid value; expected ${value}, got ${got}`);
            }
            buffer.insertArray(pattern);
        },
        _decode(buffer) {
            const got = buffer.array.subarray(buffer.index, buffer.index += pattern.length);
            for (let i = 0; i < pattern.length; i++) {
                if (pattern[i] !== got[i]) {
                    throw new _common_js__WEBPACK_IMPORTED_MODULE_0__.DecodeError(this, buffer, `Invalid pattern; expected ${hex(pattern)}, got ${hex(got)}`);
                }
            }
            return value;
        },
    });
}
function hex(pattern) {
    let str = "0x";
    for (let i = 0; i < pattern.length; i++) {
        str += pattern[i].toString(16).padStart(2, "0");
    }
    return str;
}
//# sourceMappingURL=codec.js.map

/***/ }),

/***/ "./node_modules/parity-scale-codec/esm/deferred/codec.js":
/*!***************************************************************!*\
  !*** ./node_modules/parity-scale-codec/esm/deferred/codec.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "deferred": function() { return /* binding */ deferred; }
/* harmony export */ });
function deferred(getCodec) {
    let $codec;
    return {
        name: "deferred",
        _metadata: [deferred, getCodec],
        _staticSize: 0,
        _encode(buffer, value) {
            $codec ??= getCodec();
            buffer.pushAlloc($codec._staticSize);
            $codec._encode(buffer, value);
            buffer.popAlloc();
        },
        _decode(buffer) {
            $codec ??= getCodec();
            return $codec._decode(buffer);
        },
        encode(value) {
            $codec ??= getCodec();
            return $codec.encode(value);
        },
        encodeAsync(value) {
            $codec ??= getCodec();
            return $codec.encodeAsync(value);
        },
        decode(buffer) {
            $codec ??= getCodec();
            return $codec.decode(buffer);
        },
    };
}
//# sourceMappingURL=codec.js.map

/***/ }),

/***/ "./node_modules/parity-scale-codec/esm/dummy/codec.js":
/*!************************************************************!*\
  !*** ./node_modules/parity-scale-codec/esm/dummy/codec.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "dummy": function() { return /* binding */ dummy; }
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common.js */ "./node_modules/parity-scale-codec/esm/common.js");

/**
 * `Dummy`'s decoder returns a hard-coded JS value and DOES NOT encode or decode from any bytes.
 * @param value The native value corresponding to the generically-supplied codec
 * @returns A dummy codec with the patched signature of `E`
 */
function dummy(value) {
    return (0,_common_js__WEBPACK_IMPORTED_MODULE_0__.createCodec)({
        name: "dummy",
        _metadata: [dummy, value],
        _staticSize: 0,
        _encode() { },
        _decode() {
            return value;
        },
    });
}
//# sourceMappingURL=codec.js.map

/***/ }),

/***/ "./node_modules/parity-scale-codec/esm/instance/codec.js":
/*!***************************************************************!*\
  !*** ./node_modules/parity-scale-codec/esm/instance/codec.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "instance": function() { return /* binding */ instance; }
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common.js */ "./node_modules/parity-scale-codec/esm/common.js");
/* harmony import */ var _object_codec_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../object/codec.js */ "./node_modules/parity-scale-codec/esm/object/codec.js");


/**
 * @param ctor The constructor with which to instantiate the instance / from whose instance to encode
 * @param fields the ordered fields used to decode params for the constructor / encode from the instance
 * @returns the instance codec
 */
function instance(ctor, ...fields) {
    const $object = (0,_object_codec_js__WEBPACK_IMPORTED_MODULE_1__.object)(...fields);
    return (0,_common_js__WEBPACK_IMPORTED_MODULE_0__.createCodec)({
        ...$object,
        _metadata: [instance, ctor, ...fields],
        _decode(buffer) {
            const arr = Array(fields.length);
            for (let i = 0; i < arr.length; i++) {
                arr[i] = fields[i][1]._decode(buffer);
            }
            return new ctor(...arr);
        },
    });
}
//# sourceMappingURL=codec.js.map

/***/ }),

/***/ "./node_modules/parity-scale-codec/esm/int/codec.js":
/*!**********************************************************!*\
  !*** ./node_modules/parity-scale-codec/esm/int/codec.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "i128": function() { return /* binding */ i128; },
/* harmony export */   "i16": function() { return /* binding */ i16; },
/* harmony export */   "i256": function() { return /* binding */ i256; },
/* harmony export */   "i32": function() { return /* binding */ i32; },
/* harmony export */   "i64": function() { return /* binding */ i64; },
/* harmony export */   "i8": function() { return /* binding */ i8; },
/* harmony export */   "int": function() { return /* binding */ int; },
/* harmony export */   "u128": function() { return /* binding */ u128; },
/* harmony export */   "u16": function() { return /* binding */ u16; },
/* harmony export */   "u256": function() { return /* binding */ u256; },
/* harmony export */   "u32": function() { return /* binding */ u32; },
/* harmony export */   "u64": function() { return /* binding */ u64; },
/* harmony export */   "u8": function() { return /* binding */ u8; }
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common.js */ "./node_modules/parity-scale-codec/esm/common.js");

const u8 = (0,_common_js__WEBPACK_IMPORTED_MODULE_0__.createCodec)({
    name: "u8",
    _metadata: [int, false, 8],
    _staticSize: 1,
    _encode(buffer, value) {
        buffer.array[buffer.index++] = value;
    },
    _decode(buffer) {
        return buffer.array[buffer.index++];
    },
});
function _int(size, key) {
    const getMethod = DataView.prototype["get" + key];
    const setMethod = DataView.prototype["set" + key];
    return (0,_common_js__WEBPACK_IMPORTED_MODULE_0__.createCodec)({
        name: `${key[0].toLowerCase}${size * 8}`,
        _metadata: [int, key.includes("Int"), size * 8],
        _staticSize: size,
        _encode(buffer, value) {
            setMethod.call(buffer.view, buffer.index, value, true);
            buffer.index += size;
        },
        _decode(buffer) {
            const value = getMethod.call(buffer.view, buffer.index, true);
            buffer.index += size;
            return value;
        },
    });
}
const i8 = _int(1, "Int8");
const u16 = _int(2, "Uint16");
const i16 = _int(2, "Int16");
const u32 = _int(4, "Uint32");
const i32 = _int(4, "Int32");
const u64 = _int(8, "BigUint64");
const i64 = _int(8, "BigInt64");
const _128 = (signed) => {
    const getMethod = DataView.prototype[signed ? "getBigInt64" : "getBigUint64"];
    return (0,_common_js__WEBPACK_IMPORTED_MODULE_0__.createCodec)({
        name: `${signed ? "i" : "u"}128`,
        _metadata: [int, signed, 128],
        _staticSize: 16,
        _encode(buffer, value) {
            buffer.view.setBigInt64(buffer.index, value, true);
            buffer.view.setBigInt64(buffer.index + 8, value >> 64n, true);
            buffer.index += 16;
        },
        _decode(buffer) {
            const b = buffer.view.getBigUint64(buffer.index, true);
            const a = getMethod.call(buffer.view, buffer.index + 8, true);
            buffer.index += 16;
            return (a << 64n) | b;
        },
    });
};
const u128 = _128(false);
const i128 = _128(true);
const _256 = (signed) => {
    const getMethod = DataView.prototype[signed ? "getBigInt64" : "getBigUint64"];
    return (0,_common_js__WEBPACK_IMPORTED_MODULE_0__.createCodec)({
        name: `${signed ? "i" : "u"}256`,
        _metadata: [int, signed, 256],
        _staticSize: 32,
        _encode(buffer, value) {
            buffer.view.setBigInt64(buffer.index, value, true);
            buffer.view.setBigInt64(buffer.index + 8, value >> 64n, true);
            buffer.view.setBigInt64(buffer.index + 16, value >> 128n, true);
            buffer.view.setBigInt64(buffer.index + 24, value >> 192n, true);
            buffer.index += 32;
        },
        _decode(buffer) {
            const d = buffer.view.getBigUint64(buffer.index, true);
            const c = buffer.view.getBigUint64(buffer.index + 8, true);
            const b = buffer.view.getBigUint64(buffer.index + 16, true);
            const a = getMethod.call(buffer.view, buffer.index + 24, true);
            buffer.index += 32;
            return (a << 192n) | (b << 128n) | (c << 64n) | d;
        },
    });
};
const u256 = _256(false);
const i256 = _256(true);
function int(signed, size) {
    const key = `${signed ? "i" : "u"}${size}`;
    return { u8, i8, u16, i16, u32, i32, u64, i64, u128, i128, u256, i256 }[key];
}
//# sourceMappingURL=codec.js.map

/***/ }),

/***/ "./node_modules/parity-scale-codec/esm/iterable/codec.js":
/*!***************************************************************!*\
  !*** ./node_modules/parity-scale-codec/esm/iterable/codec.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "iterable": function() { return /* binding */ iterable; },
/* harmony export */   "map": function() { return /* binding */ map; },
/* harmony export */   "set": function() { return /* binding */ set; }
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common.js */ "./node_modules/parity-scale-codec/esm/common.js");
/* harmony import */ var _compact_codec_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../compact/codec.js */ "./node_modules/parity-scale-codec/esm/compact/codec.js");
/* harmony import */ var _mod_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../mod.js */ "./node_modules/parity-scale-codec/esm/mod.js");



function iterable({ $el, calcLength, rehydrate }) {
    return (0,_common_js__WEBPACK_IMPORTED_MODULE_0__.createCodec)({
        name: "iterable",
        _metadata: [iterable, { $el, calcLength, rehydrate }],
        _staticSize: _compact_codec_js__WEBPACK_IMPORTED_MODULE_1__.compactU32._staticSize,
        _encode(buffer, value) {
            const length = calcLength(value);
            _compact_codec_js__WEBPACK_IMPORTED_MODULE_1__.compactU32._encode(buffer, length);
            buffer.pushAlloc(length * $el._staticSize);
            let i = 0;
            for (const el of value) {
                $el._encode(buffer, el);
                i++;
            }
            if (i !== length)
                throw new _common_js__WEBPACK_IMPORTED_MODULE_0__.EncodeError(this, value, "Incorrect length returned by calcLength");
            buffer.popAlloc();
        },
        _decode(buffer) {
            const length = _compact_codec_js__WEBPACK_IMPORTED_MODULE_1__.compactU32._decode(buffer);
            let done = false;
            const value = rehydrate(function* () {
                for (let i = 0; i < length; i++) {
                    yield $el._decode(buffer);
                }
                done = true;
            }());
            if (!done)
                throw new _common_js__WEBPACK_IMPORTED_MODULE_0__.DecodeError(this, buffer, "Iterable passed to rehydrate must be immediately exhausted");
            return value;
        },
    });
}
function set($el) {
    return (0,_common_js__WEBPACK_IMPORTED_MODULE_0__.withMetadata)(iterable({
        $el,
        calcLength: (set) => set.size,
        rehydrate: (values) => new Set(values),
    }), [set, $el]);
}
function map($key, $value) {
    return (0,_common_js__WEBPACK_IMPORTED_MODULE_0__.withMetadata)(iterable({
        $el: (0,_mod_js__WEBPACK_IMPORTED_MODULE_2__.tuple)($key, $value),
        calcLength: (map) => map.size,
        rehydrate: (values) => new Map(values),
    }), [map, $key, $value]);
}
//# sourceMappingURL=codec.js.map

/***/ }),

/***/ "./node_modules/parity-scale-codec/esm/lenPrefixed/codec.js":
/*!******************************************************************!*\
  !*** ./node_modules/parity-scale-codec/esm/lenPrefixed/codec.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "lenPrefixed": function() { return /* binding */ lenPrefixed; }
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common.js */ "./node_modules/parity-scale-codec/esm/common.js");
/* harmony import */ var _compact_codec_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../compact/codec.js */ "./node_modules/parity-scale-codec/esm/compact/codec.js");


function lenPrefixed($inner) {
    return (0,_common_js__WEBPACK_IMPORTED_MODULE_0__.createCodec)({
        _metadata: [lenPrefixed, $inner],
        _staticSize: _compact_codec_js__WEBPACK_IMPORTED_MODULE_1__.compactU32._staticSize + $inner._staticSize,
        _encode(buffer, extrinsic) {
            const lengthCursor = buffer.createCursor(_compact_codec_js__WEBPACK_IMPORTED_MODULE_1__.compactU32._staticSize);
            const contentCursor = buffer.createCursor($inner._staticSize);
            $inner._encode(contentCursor, extrinsic);
            buffer.waitForBuffer(contentCursor, () => {
                const length = contentCursor.finishedSize + contentCursor.index;
                _compact_codec_js__WEBPACK_IMPORTED_MODULE_1__.compactU32._encode(lengthCursor, length);
                lengthCursor.close();
                contentCursor.close();
            });
        },
        _decode(buffer) {
            const length = _compact_codec_js__WEBPACK_IMPORTED_MODULE_1__.compactU32._decode(buffer);
            return $inner.decode(buffer.array.subarray(buffer.index, buffer.index += length));
        },
    });
}
//# sourceMappingURL=codec.js.map

/***/ }),

/***/ "./node_modules/parity-scale-codec/esm/mod.js":
/*!****************************************************!*\
  !*** ./node_modules/parity-scale-codec/esm/mod.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BitSequence": function() { return /* reexport safe */ _bitSequence_codec_js__WEBPACK_IMPORTED_MODULE_1__.BitSequence; },
/* harmony export */   "CodecError": function() { return /* reexport safe */ _common_js__WEBPACK_IMPORTED_MODULE_3__.CodecError; },
/* harmony export */   "CodecVisitor": function() { return /* reexport safe */ _common_js__WEBPACK_IMPORTED_MODULE_3__.CodecVisitor; },
/* harmony export */   "Context": function() { return /* reexport safe */ _common_js__WEBPACK_IMPORTED_MODULE_3__.Context; },
/* harmony export */   "DecodeBuffer": function() { return /* reexport safe */ _common_js__WEBPACK_IMPORTED_MODULE_3__.DecodeBuffer; },
/* harmony export */   "DecodeError": function() { return /* reexport safe */ _common_js__WEBPACK_IMPORTED_MODULE_3__.DecodeError; },
/* harmony export */   "EncodeBuffer": function() { return /* reexport safe */ _common_js__WEBPACK_IMPORTED_MODULE_3__.EncodeBuffer; },
/* harmony export */   "EncodeError": function() { return /* reexport safe */ _common_js__WEBPACK_IMPORTED_MODULE_3__.EncodeError; },
/* harmony export */   "array": function() { return /* reexport safe */ _array_codec_js__WEBPACK_IMPORTED_MODULE_0__.array; },
/* harmony export */   "bitSequence": function() { return /* reexport safe */ _bitSequence_codec_js__WEBPACK_IMPORTED_MODULE_1__.bitSequence; },
/* harmony export */   "bool": function() { return /* reexport safe */ _bool_codec_js__WEBPACK_IMPORTED_MODULE_2__.bool; },
/* harmony export */   "compactU128": function() { return /* reexport safe */ _compact_codec_js__WEBPACK_IMPORTED_MODULE_4__.compactU128; },
/* harmony export */   "compactU16": function() { return /* reexport safe */ _compact_codec_js__WEBPACK_IMPORTED_MODULE_4__.compactU16; },
/* harmony export */   "compactU256": function() { return /* reexport safe */ _compact_codec_js__WEBPACK_IMPORTED_MODULE_4__.compactU256; },
/* harmony export */   "compactU32": function() { return /* reexport safe */ _compact_codec_js__WEBPACK_IMPORTED_MODULE_4__.compactU32; },
/* harmony export */   "compactU64": function() { return /* reexport safe */ _compact_codec_js__WEBPACK_IMPORTED_MODULE_4__.compactU64; },
/* harmony export */   "compactU8": function() { return /* reexport safe */ _compact_codec_js__WEBPACK_IMPORTED_MODULE_4__.compactU8; },
/* harmony export */   "constantPattern": function() { return /* reexport safe */ _constantPattern_codec_js__WEBPACK_IMPORTED_MODULE_5__.constantPattern; },
/* harmony export */   "createAsyncCodec": function() { return /* reexport safe */ _common_js__WEBPACK_IMPORTED_MODULE_3__.createAsyncCodec; },
/* harmony export */   "createCodec": function() { return /* reexport safe */ _common_js__WEBPACK_IMPORTED_MODULE_3__.createCodec; },
/* harmony export */   "deferred": function() { return /* reexport safe */ _deferred_codec_js__WEBPACK_IMPORTED_MODULE_6__.deferred; },
/* harmony export */   "dummy": function() { return /* reexport safe */ _dummy_codec_js__WEBPACK_IMPORTED_MODULE_7__.dummy; },
/* harmony export */   "i128": function() { return /* reexport safe */ _int_codec_js__WEBPACK_IMPORTED_MODULE_9__.i128; },
/* harmony export */   "i16": function() { return /* reexport safe */ _int_codec_js__WEBPACK_IMPORTED_MODULE_9__.i16; },
/* harmony export */   "i256": function() { return /* reexport safe */ _int_codec_js__WEBPACK_IMPORTED_MODULE_9__.i256; },
/* harmony export */   "i32": function() { return /* reexport safe */ _int_codec_js__WEBPACK_IMPORTED_MODULE_9__.i32; },
/* harmony export */   "i64": function() { return /* reexport safe */ _int_codec_js__WEBPACK_IMPORTED_MODULE_9__.i64; },
/* harmony export */   "i8": function() { return /* reexport safe */ _int_codec_js__WEBPACK_IMPORTED_MODULE_9__.i8; },
/* harmony export */   "instance": function() { return /* reexport safe */ _instance_codec_js__WEBPACK_IMPORTED_MODULE_8__.instance; },
/* harmony export */   "int": function() { return /* reexport safe */ _int_codec_js__WEBPACK_IMPORTED_MODULE_9__.int; },
/* harmony export */   "iterable": function() { return /* reexport safe */ _iterable_codec_js__WEBPACK_IMPORTED_MODULE_10__.iterable; },
/* harmony export */   "lenPrefixed": function() { return /* reexport safe */ _lenPrefixed_codec_js__WEBPACK_IMPORTED_MODULE_11__.lenPrefixed; },
/* harmony export */   "map": function() { return /* reexport safe */ _iterable_codec_js__WEBPACK_IMPORTED_MODULE_10__.map; },
/* harmony export */   "never": function() { return /* reexport safe */ _never_codec_js__WEBPACK_IMPORTED_MODULE_12__.never; },
/* harmony export */   "object": function() { return /* reexport safe */ _object_codec_js__WEBPACK_IMPORTED_MODULE_13__.object; },
/* harmony export */   "option": function() { return /* reexport safe */ _option_codec_js__WEBPACK_IMPORTED_MODULE_14__.option; },
/* harmony export */   "optionBool": function() { return /* reexport safe */ _option_optionBool_codec_js__WEBPACK_IMPORTED_MODULE_15__.optionBool; },
/* harmony export */   "promise": function() { return /* reexport safe */ _promise_codec_js__WEBPACK_IMPORTED_MODULE_16__.promise; },
/* harmony export */   "result": function() { return /* reexport safe */ _result_codec_js__WEBPACK_IMPORTED_MODULE_17__.result; },
/* harmony export */   "set": function() { return /* reexport safe */ _iterable_codec_js__WEBPACK_IMPORTED_MODULE_10__.set; },
/* harmony export */   "sizedArray": function() { return /* reexport safe */ _array_codec_js__WEBPACK_IMPORTED_MODULE_0__.sizedArray; },
/* harmony export */   "sizedUint8Array": function() { return /* reexport safe */ _array_codec_js__WEBPACK_IMPORTED_MODULE_0__.sizedUint8Array; },
/* harmony export */   "sizedUint8array": function() { return /* reexport safe */ _array_codec_js__WEBPACK_IMPORTED_MODULE_0__.sizedUint8array; },
/* harmony export */   "spread": function() { return /* reexport safe */ _spread_codec_js__WEBPACK_IMPORTED_MODULE_18__.spread; },
/* harmony export */   "str": function() { return /* reexport safe */ _str_codec_js__WEBPACK_IMPORTED_MODULE_19__.str; },
/* harmony export */   "stringUnion": function() { return /* reexport safe */ _union_codec_js__WEBPACK_IMPORTED_MODULE_22__.stringUnion; },
/* harmony export */   "taggedUnion": function() { return /* reexport safe */ _union_codec_js__WEBPACK_IMPORTED_MODULE_22__.taggedUnion; },
/* harmony export */   "transform": function() { return /* reexport safe */ _transform_codec_js__WEBPACK_IMPORTED_MODULE_20__.transform; },
/* harmony export */   "tuple": function() { return /* reexport safe */ _tuple_codec_js__WEBPACK_IMPORTED_MODULE_21__.tuple; },
/* harmony export */   "u128": function() { return /* reexport safe */ _int_codec_js__WEBPACK_IMPORTED_MODULE_9__.u128; },
/* harmony export */   "u16": function() { return /* reexport safe */ _int_codec_js__WEBPACK_IMPORTED_MODULE_9__.u16; },
/* harmony export */   "u256": function() { return /* reexport safe */ _int_codec_js__WEBPACK_IMPORTED_MODULE_9__.u256; },
/* harmony export */   "u32": function() { return /* reexport safe */ _int_codec_js__WEBPACK_IMPORTED_MODULE_9__.u32; },
/* harmony export */   "u64": function() { return /* reexport safe */ _int_codec_js__WEBPACK_IMPORTED_MODULE_9__.u64; },
/* harmony export */   "u8": function() { return /* reexport safe */ _int_codec_js__WEBPACK_IMPORTED_MODULE_9__.u8; },
/* harmony export */   "uint8Array": function() { return /* reexport safe */ _array_codec_js__WEBPACK_IMPORTED_MODULE_0__.uint8Array; },
/* harmony export */   "uint8array": function() { return /* reexport safe */ _array_codec_js__WEBPACK_IMPORTED_MODULE_0__.uint8array; },
/* harmony export */   "union": function() { return /* reexport safe */ _union_codec_js__WEBPACK_IMPORTED_MODULE_22__.union; },
/* harmony export */   "withMetadata": function() { return /* reexport safe */ _common_js__WEBPACK_IMPORTED_MODULE_3__.withMetadata; }
/* harmony export */ });
/* harmony import */ var _array_codec_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array/codec.js */ "./node_modules/parity-scale-codec/esm/array/codec.js");
/* harmony import */ var _bitSequence_codec_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bitSequence/codec.js */ "./node_modules/parity-scale-codec/esm/bitSequence/codec.js");
/* harmony import */ var _bool_codec_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bool/codec.js */ "./node_modules/parity-scale-codec/esm/bool/codec.js");
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./common.js */ "./node_modules/parity-scale-codec/esm/common.js");
/* harmony import */ var _compact_codec_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./compact/codec.js */ "./node_modules/parity-scale-codec/esm/compact/codec.js");
/* harmony import */ var _constantPattern_codec_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constantPattern/codec.js */ "./node_modules/parity-scale-codec/esm/constantPattern/codec.js");
/* harmony import */ var _deferred_codec_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./deferred/codec.js */ "./node_modules/parity-scale-codec/esm/deferred/codec.js");
/* harmony import */ var _dummy_codec_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./dummy/codec.js */ "./node_modules/parity-scale-codec/esm/dummy/codec.js");
/* harmony import */ var _instance_codec_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./instance/codec.js */ "./node_modules/parity-scale-codec/esm/instance/codec.js");
/* harmony import */ var _int_codec_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./int/codec.js */ "./node_modules/parity-scale-codec/esm/int/codec.js");
/* harmony import */ var _iterable_codec_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./iterable/codec.js */ "./node_modules/parity-scale-codec/esm/iterable/codec.js");
/* harmony import */ var _lenPrefixed_codec_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./lenPrefixed/codec.js */ "./node_modules/parity-scale-codec/esm/lenPrefixed/codec.js");
/* harmony import */ var _never_codec_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./never/codec.js */ "./node_modules/parity-scale-codec/esm/never/codec.js");
/* harmony import */ var _object_codec_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./object/codec.js */ "./node_modules/parity-scale-codec/esm/object/codec.js");
/* harmony import */ var _option_codec_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./option/codec.js */ "./node_modules/parity-scale-codec/esm/option/codec.js");
/* harmony import */ var _option_optionBool_codec_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./option/optionBool/codec.js */ "./node_modules/parity-scale-codec/esm/option/optionBool/codec.js");
/* harmony import */ var _promise_codec_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./promise/codec.js */ "./node_modules/parity-scale-codec/esm/promise/codec.js");
/* harmony import */ var _result_codec_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./result/codec.js */ "./node_modules/parity-scale-codec/esm/result/codec.js");
/* harmony import */ var _spread_codec_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./spread/codec.js */ "./node_modules/parity-scale-codec/esm/spread/codec.js");
/* harmony import */ var _str_codec_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./str/codec.js */ "./node_modules/parity-scale-codec/esm/str/codec.js");
/* harmony import */ var _transform_codec_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./transform/codec.js */ "./node_modules/parity-scale-codec/esm/transform/codec.js");
/* harmony import */ var _tuple_codec_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./tuple/codec.js */ "./node_modules/parity-scale-codec/esm/tuple/codec.js");
/* harmony import */ var _union_codec_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./union/codec.js */ "./node_modules/parity-scale-codec/esm/union/codec.js");























//# sourceMappingURL=mod.js.map

/***/ }),

/***/ "./node_modules/parity-scale-codec/esm/never/codec.js":
/*!************************************************************!*\
  !*** ./node_modules/parity-scale-codec/esm/never/codec.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "never": function() { return /* binding */ never; }
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common.js */ "./node_modules/parity-scale-codec/esm/common.js");

const never = (0,_common_js__WEBPACK_IMPORTED_MODULE_0__.createCodec)({
    name: "never",
    _metadata: null,
    _staticSize: 0,
    _encode(value) {
        throw new _common_js__WEBPACK_IMPORTED_MODULE_0__.EncodeError(this, value, "Cannot encode $.never");
    },
    _decode(buffer) {
        throw new _common_js__WEBPACK_IMPORTED_MODULE_0__.DecodeError(this, buffer, "Cannot decode $.never");
    },
});
//# sourceMappingURL=codec.js.map

/***/ }),

/***/ "./node_modules/parity-scale-codec/esm/object/codec.js":
/*!*************************************************************!*\
  !*** ./node_modules/parity-scale-codec/esm/object/codec.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "object": function() { return /* binding */ object; }
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common.js */ "./node_modules/parity-scale-codec/esm/common.js");

function object(...fields) {
    return (0,_common_js__WEBPACK_IMPORTED_MODULE_0__.createCodec)({
        name: "object",
        _metadata: [object, ...fields],
        _staticSize: fields.map((x) => x[1]._staticSize).reduce((a, b) => a + b, 0),
        _encode(buffer, value) {
            fields.forEach(([key, fieldEncoder]) => {
                fieldEncoder._encode(buffer, value[key]);
            });
        },
        _decode(buffer) {
            const obj = {};
            for (let i = 0; i < fields.length; i++) {
                const [key, field] = fields[i];
                obj[key] = field._decode(buffer);
            }
            return obj;
        },
    });
}
//# sourceMappingURL=codec.js.map

/***/ }),

/***/ "./node_modules/parity-scale-codec/esm/option/codec.js":
/*!*************************************************************!*\
  !*** ./node_modules/parity-scale-codec/esm/option/codec.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "option": function() { return /* binding */ option; }
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common.js */ "./node_modules/parity-scale-codec/esm/common.js");

function option($some) {
    return (0,_common_js__WEBPACK_IMPORTED_MODULE_0__.createCodec)({
        name: "option",
        _metadata: [option, $some],
        _staticSize: 1 + $some._staticSize,
        _encode(buffer, value) {
            buffer.array[buffer.index++] = +(value !== undefined);
            if (value !== undefined) {
                $some._encode(buffer, value);
            }
        },
        _decode(buffer) {
            switch (buffer.array[buffer.index++]) {
                case 0: {
                    return undefined;
                }
                case 1: {
                    return $some._decode(buffer);
                }
                default: {
                    throw new _common_js__WEBPACK_IMPORTED_MODULE_0__.DecodeError($some, buffer, "Could not decode Option as `Some(_)` nor `None`");
                }
            }
        },
    });
}
//# sourceMappingURL=codec.js.map

/***/ }),

/***/ "./node_modules/parity-scale-codec/esm/option/optionBool/codec.js":
/*!************************************************************************!*\
  !*** ./node_modules/parity-scale-codec/esm/option/optionBool/codec.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "optionBool": function() { return /* binding */ optionBool; }
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common.js */ "./node_modules/parity-scale-codec/esm/common.js");

const optionBool = (0,_common_js__WEBPACK_IMPORTED_MODULE_0__.createCodec)({
    name: "optionBool",
    _metadata: null,
    _staticSize: 1,
    _encode(buffer, value) {
        buffer.array[buffer.index++] = value === undefined ? 0 : 1 + +!value;
    },
    _decode(buffer) {
        const byte = buffer.array[buffer.index++];
        return byte === 0 ? undefined : !(byte - 1);
    },
});
//# sourceMappingURL=codec.js.map

/***/ }),

/***/ "./node_modules/parity-scale-codec/esm/promise/codec.js":
/*!**************************************************************!*\
  !*** ./node_modules/parity-scale-codec/esm/promise/codec.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "promise": function() { return /* binding */ promise; }
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common.js */ "./node_modules/parity-scale-codec/esm/common.js");

function promise($value) {
    return (0,_common_js__WEBPACK_IMPORTED_MODULE_0__.createAsyncCodec)({
        name: "promise",
        _metadata: [promise, $value],
        _staticSize: $value._staticSize,
        async _encodeAsync(buffer, value) {
            $value._encode(buffer, await value);
        },
        _decode(buffer) {
            return Promise.resolve($value._decode(buffer));
        },
    });
}
//# sourceMappingURL=codec.js.map

/***/ }),

/***/ "./node_modules/parity-scale-codec/esm/result/codec.js":
/*!*************************************************************!*\
  !*** ./node_modules/parity-scale-codec/esm/result/codec.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "result": function() { return /* binding */ result; }
/* harmony export */ });
/* harmony import */ var _union_codec_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../union/codec.js */ "./node_modules/parity-scale-codec/esm/union/codec.js");

function result($ok, $err) {
    return Object.assign((0,_union_codec_js__WEBPACK_IMPORTED_MODULE_0__.union)((value) => value instanceof Error ? 1 : 0, [$ok, $err]), {
        _metadata: [result, $ok, $err],
    });
}
//# sourceMappingURL=codec.js.map

/***/ }),

/***/ "./node_modules/parity-scale-codec/esm/spread/codec.js":
/*!*************************************************************!*\
  !*** ./node_modules/parity-scale-codec/esm/spread/codec.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "spread": function() { return /* binding */ spread; }
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common.js */ "./node_modules/parity-scale-codec/esm/common.js");

function spread($a, $b) {
    return (0,_common_js__WEBPACK_IMPORTED_MODULE_0__.createCodec)({
        name: "spread",
        _metadata: [spread, $a, $b],
        _staticSize: $a._staticSize + $b._staticSize,
        _encode(buffer, value) {
            $a._encode(buffer, value);
            $b._encode(buffer, value);
        },
        _decode(buffer) {
            return { ...$a._decode(buffer), ...$b._decode(buffer) };
        },
    });
}
//# sourceMappingURL=codec.js.map

/***/ }),

/***/ "./node_modules/parity-scale-codec/esm/str/codec.js":
/*!**********************************************************!*\
  !*** ./node_modules/parity-scale-codec/esm/str/codec.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "str": function() { return /* binding */ str; }
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common.js */ "./node_modules/parity-scale-codec/esm/common.js");
/* harmony import */ var _compact_codec_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../compact/codec.js */ "./node_modules/parity-scale-codec/esm/compact/codec.js");


const str = (0,_common_js__WEBPACK_IMPORTED_MODULE_0__.createCodec)({
    name: "str",
    _metadata: null,
    _staticSize: _compact_codec_js__WEBPACK_IMPORTED_MODULE_1__.compactU32._staticSize,
    _encode(buffer, value) {
        const array = new TextEncoder().encode(value);
        _compact_codec_js__WEBPACK_IMPORTED_MODULE_1__.compactU32._encode(buffer, array.length);
        buffer.insertArray(array);
    },
    _decode(buffer) {
        const len = _compact_codec_js__WEBPACK_IMPORTED_MODULE_1__.compactU32._decode(buffer);
        if (buffer.array.length < buffer.index + len) {
            throw new _common_js__WEBPACK_IMPORTED_MODULE_0__.DecodeError(this, buffer, "Attempting to `str`-decode beyond bounds of input bytes");
        }
        const slice = buffer.array.slice(buffer.index, buffer.index + len);
        buffer.index += len;
        return new TextDecoder().decode(slice);
    },
});
//# sourceMappingURL=codec.js.map

/***/ }),

/***/ "./node_modules/parity-scale-codec/esm/transform/codec.js":
/*!****************************************************************!*\
  !*** ./node_modules/parity-scale-codec/esm/transform/codec.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "transform": function() { return /* binding */ transform; }
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common.js */ "./node_modules/parity-scale-codec/esm/common.js");

function transform($base, encode, decode) {
    return (0,_common_js__WEBPACK_IMPORTED_MODULE_0__.createCodec)({
        name: "transform",
        _metadata: [transform, $base, encode, decode],
        _staticSize: $base._staticSize,
        _encode(buffer, value) {
            $base._encode(buffer, encode(value));
        },
        _decode(buffer) {
            return decode($base._decode(buffer));
        },
    });
}
//# sourceMappingURL=codec.js.map

/***/ }),

/***/ "./node_modules/parity-scale-codec/esm/tuple/codec.js":
/*!************************************************************!*\
  !*** ./node_modules/parity-scale-codec/esm/tuple/codec.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "tuple": function() { return /* binding */ tuple; }
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common.js */ "./node_modules/parity-scale-codec/esm/common.js");

function tuple(...codecs) {
    return (0,_common_js__WEBPACK_IMPORTED_MODULE_0__.createCodec)({
        name: "tuple",
        _metadata: [tuple, ...codecs],
        _staticSize: codecs.map((x) => x._staticSize).reduce((a, b) => a + b, 0),
        _encode(buffer, value) {
            for (let i = 0; i < codecs.length; i++) {
                codecs[i]._encode(buffer, value[i]);
            }
        },
        _decode(buffer) {
            const value = Array(codecs.length);
            for (let i = 0; i < codecs.length; i++) {
                value[i] = codecs[i]._decode(buffer);
            }
            return value;
        },
    });
}
//# sourceMappingURL=codec.js.map

/***/ }),

/***/ "./node_modules/parity-scale-codec/esm/union/codec.js":
/*!************************************************************!*\
  !*** ./node_modules/parity-scale-codec/esm/union/codec.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "stringUnion": function() { return /* binding */ stringUnion; },
/* harmony export */   "taggedUnion": function() { return /* binding */ taggedUnion; },
/* harmony export */   "union": function() { return /* binding */ union; }
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common.js */ "./node_modules/parity-scale-codec/esm/common.js");
/* harmony import */ var _dummy_codec_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dummy/codec.js */ "./node_modules/parity-scale-codec/esm/dummy/codec.js");
/* harmony import */ var _object_codec_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../object/codec.js */ "./node_modules/parity-scale-codec/esm/object/codec.js");



function union(getIndex, $members) {
    return (0,_common_js__WEBPACK_IMPORTED_MODULE_0__.createCodec)({
        name: "union",
        _metadata: [union, getIndex, $members],
        _staticSize: 1 + Math.max(...Object.values($members).map((x) => x._staticSize)),
        _encode(buffer, value) {
            const discriminant = getIndex(value);
            const $member = $members[discriminant];
            buffer.array[buffer.index++] = discriminant;
            $member._encode(buffer, value);
        },
        _decode(buffer) {
            const discriminant = buffer.array[buffer.index++];
            const $member = $members[discriminant];
            if (!$member) {
                throw new _common_js__WEBPACK_IMPORTED_MODULE_0__.DecodeError(this, buffer, `No such member codec matching the discriminant \`${discriminant}\``);
            }
            return $member._decode(buffer);
        },
    });
}
function taggedUnion(tagKey, members) {
    const tagToDiscriminant = {};
    const discriminantToMember = {};
    for (const _discriminant in members) {
        const discriminant = +_discriminant;
        if (isNaN(discriminant))
            continue;
        const [tag, ...fields] = members[discriminant];
        tagToDiscriminant[tag] = discriminant;
        discriminantToMember[discriminant] = (0,_object_codec_js__WEBPACK_IMPORTED_MODULE_2__.object)([tagKey, (0,_dummy_codec_js__WEBPACK_IMPORTED_MODULE_1__.dummy)(tag)], ...fields);
    }
    return (0,_common_js__WEBPACK_IMPORTED_MODULE_0__.withMetadata)(union((value) => tagToDiscriminant[value[tagKey]], discriminantToMember), [taggedUnion, tagKey, members]);
}
function stringUnion(members) {
    const keyToDiscriminant = {};
    for (const _discriminant in members) {
        const discriminant = +_discriminant;
        if (isNaN(discriminant))
            continue;
        const key = members[discriminant];
        keyToDiscriminant[key] = discriminant;
    }
    return (0,_common_js__WEBPACK_IMPORTED_MODULE_0__.createCodec)({
        name: "stringUnion",
        _metadata: [stringUnion, members],
        _staticSize: 1,
        _encode(buffer, value) {
            const discriminant = keyToDiscriminant[value];
            buffer.array[buffer.index++] = discriminant;
        },
        _decode(buffer) {
            const discriminant = buffer.array[buffer.index++];
            return members[discriminant];
        },
    });
}
//# sourceMappingURL=codec.js.map

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			if (cachedModule.error !== undefined) throw cachedModule.error;
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		try {
/******/ 			var execOptions = { id: moduleId, module: module, factory: __webpack_modules__[moduleId], require: __webpack_require__ };
/******/ 			__webpack_require__.i.forEach(function(handler) { handler(execOptions); });
/******/ 			module = execOptions.module;
/******/ 			execOptions.factory.call(module.exports, module, module.exports, execOptions.require);
/******/ 		} catch(e) {
/******/ 			module.error = e;
/******/ 			throw e;
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/******/ 	// expose the module execution interceptor
/******/ 	__webpack_require__.i = [];
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	!function() {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = function(chunkId) {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	!function() {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = function(chunkId) {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".js";
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/get javascript update chunk filename */
/******/ 	!function() {
/******/ 		// This function allow to reference all chunks
/******/ 		__webpack_require__.hu = function(chunkId) {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + "." + __webpack_require__.h() + ".hot-update.js";
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/get update manifest filename */
/******/ 	!function() {
/******/ 		__webpack_require__.hmrF = function() { return "main." + __webpack_require__.h() + ".hot-update.json"; };
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/getFullHash */
/******/ 	!function() {
/******/ 		__webpack_require__.h = function() { return "9c07df4432b64b4a34ce"; }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	!function() {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "capi-simple-demo:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = function(url, done, key, chunkId) {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = function(prev, event) {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach(function(fn) { return fn(event); });
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			;
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hot module replacement */
/******/ 	!function() {
/******/ 		var currentModuleData = {};
/******/ 		var installedModules = __webpack_require__.c;
/******/ 		
/******/ 		// module and require creation
/******/ 		var currentChildModule;
/******/ 		var currentParents = [];
/******/ 		
/******/ 		// status
/******/ 		var registeredStatusHandlers = [];
/******/ 		var currentStatus = "idle";
/******/ 		
/******/ 		// while downloading
/******/ 		var blockingPromises = 0;
/******/ 		var blockingPromisesWaiting = [];
/******/ 		
/******/ 		// The update info
/******/ 		var currentUpdateApplyHandlers;
/******/ 		var queuedInvalidatedModules;
/******/ 		
/******/ 		// eslint-disable-next-line no-unused-vars
/******/ 		__webpack_require__.hmrD = currentModuleData;
/******/ 		
/******/ 		__webpack_require__.i.push(function (options) {
/******/ 			var module = options.module;
/******/ 			var require = createRequire(options.require, options.id);
/******/ 			module.hot = createModuleHotObject(options.id, module);
/******/ 			module.parents = currentParents;
/******/ 			module.children = [];
/******/ 			currentParents = [];
/******/ 			options.require = require;
/******/ 		});
/******/ 		
/******/ 		__webpack_require__.hmrC = {};
/******/ 		__webpack_require__.hmrI = {};
/******/ 		
/******/ 		function createRequire(require, moduleId) {
/******/ 			var me = installedModules[moduleId];
/******/ 			if (!me) return require;
/******/ 			var fn = function (request) {
/******/ 				if (me.hot.active) {
/******/ 					if (installedModules[request]) {
/******/ 						var parents = installedModules[request].parents;
/******/ 						if (parents.indexOf(moduleId) === -1) {
/******/ 							parents.push(moduleId);
/******/ 						}
/******/ 					} else {
/******/ 						currentParents = [moduleId];
/******/ 						currentChildModule = request;
/******/ 					}
/******/ 					if (me.children.indexOf(request) === -1) {
/******/ 						me.children.push(request);
/******/ 					}
/******/ 				} else {
/******/ 					console.warn(
/******/ 						"[HMR] unexpected require(" +
/******/ 							request +
/******/ 							") from disposed module " +
/******/ 							moduleId
/******/ 					);
/******/ 					currentParents = [];
/******/ 				}
/******/ 				return require(request);
/******/ 			};
/******/ 			var createPropertyDescriptor = function (name) {
/******/ 				return {
/******/ 					configurable: true,
/******/ 					enumerable: true,
/******/ 					get: function () {
/******/ 						return require[name];
/******/ 					},
/******/ 					set: function (value) {
/******/ 						require[name] = value;
/******/ 					}
/******/ 				};
/******/ 			};
/******/ 			for (var name in require) {
/******/ 				if (Object.prototype.hasOwnProperty.call(require, name) && name !== "e") {
/******/ 					Object.defineProperty(fn, name, createPropertyDescriptor(name));
/******/ 				}
/******/ 			}
/******/ 			fn.e = function (chunkId) {
/******/ 				return trackBlockingPromise(require.e(chunkId));
/******/ 			};
/******/ 			return fn;
/******/ 		}
/******/ 		
/******/ 		function createModuleHotObject(moduleId, me) {
/******/ 			var _main = currentChildModule !== moduleId;
/******/ 			var hot = {
/******/ 				// private stuff
/******/ 				_acceptedDependencies: {},
/******/ 				_acceptedErrorHandlers: {},
/******/ 				_declinedDependencies: {},
/******/ 				_selfAccepted: false,
/******/ 				_selfDeclined: false,
/******/ 				_selfInvalidated: false,
/******/ 				_disposeHandlers: [],
/******/ 				_main: _main,
/******/ 				_requireSelf: function () {
/******/ 					currentParents = me.parents.slice();
/******/ 					currentChildModule = _main ? undefined : moduleId;
/******/ 					__webpack_require__(moduleId);
/******/ 				},
/******/ 		
/******/ 				// Module API
/******/ 				active: true,
/******/ 				accept: function (dep, callback, errorHandler) {
/******/ 					if (dep === undefined) hot._selfAccepted = true;
/******/ 					else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 					else if (typeof dep === "object" && dep !== null) {
/******/ 						for (var i = 0; i < dep.length; i++) {
/******/ 							hot._acceptedDependencies[dep[i]] = callback || function () {};
/******/ 							hot._acceptedErrorHandlers[dep[i]] = errorHandler;
/******/ 						}
/******/ 					} else {
/******/ 						hot._acceptedDependencies[dep] = callback || function () {};
/******/ 						hot._acceptedErrorHandlers[dep] = errorHandler;
/******/ 					}
/******/ 				},
/******/ 				decline: function (dep) {
/******/ 					if (dep === undefined) hot._selfDeclined = true;
/******/ 					else if (typeof dep === "object" && dep !== null)
/******/ 						for (var i = 0; i < dep.length; i++)
/******/ 							hot._declinedDependencies[dep[i]] = true;
/******/ 					else hot._declinedDependencies[dep] = true;
/******/ 				},
/******/ 				dispose: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				addDisposeHandler: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				removeDisposeHandler: function (callback) {
/******/ 					var idx = hot._disposeHandlers.indexOf(callback);
/******/ 					if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 				},
/******/ 				invalidate: function () {
/******/ 					this._selfInvalidated = true;
/******/ 					switch (currentStatus) {
/******/ 						case "idle":
/******/ 							currentUpdateApplyHandlers = [];
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							setStatus("ready");
/******/ 							break;
/******/ 						case "ready":
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							break;
/******/ 						case "prepare":
/******/ 						case "check":
/******/ 						case "dispose":
/******/ 						case "apply":
/******/ 							(queuedInvalidatedModules = queuedInvalidatedModules || []).push(
/******/ 								moduleId
/******/ 							);
/******/ 							break;
/******/ 						default:
/******/ 							// ignore requests in error states
/******/ 							break;
/******/ 					}
/******/ 				},
/******/ 		
/******/ 				// Management API
/******/ 				check: hotCheck,
/******/ 				apply: hotApply,
/******/ 				status: function (l) {
/******/ 					if (!l) return currentStatus;
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				addStatusHandler: function (l) {
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				removeStatusHandler: function (l) {
/******/ 					var idx = registeredStatusHandlers.indexOf(l);
/******/ 					if (idx >= 0) registeredStatusHandlers.splice(idx, 1);
/******/ 				},
/******/ 		
/******/ 				//inherit from previous dispose call
/******/ 				data: currentModuleData[moduleId]
/******/ 			};
/******/ 			currentChildModule = undefined;
/******/ 			return hot;
/******/ 		}
/******/ 		
/******/ 		function setStatus(newStatus) {
/******/ 			currentStatus = newStatus;
/******/ 			var results = [];
/******/ 		
/******/ 			for (var i = 0; i < registeredStatusHandlers.length; i++)
/******/ 				results[i] = registeredStatusHandlers[i].call(null, newStatus);
/******/ 		
/******/ 			return Promise.all(results);
/******/ 		}
/******/ 		
/******/ 		function unblock() {
/******/ 			if (--blockingPromises === 0) {
/******/ 				setStatus("ready").then(function () {
/******/ 					if (blockingPromises === 0) {
/******/ 						var list = blockingPromisesWaiting;
/******/ 						blockingPromisesWaiting = [];
/******/ 						for (var i = 0; i < list.length; i++) {
/******/ 							list[i]();
/******/ 						}
/******/ 					}
/******/ 				});
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function trackBlockingPromise(promise) {
/******/ 			switch (currentStatus) {
/******/ 				case "ready":
/******/ 					setStatus("prepare");
/******/ 				/* fallthrough */
/******/ 				case "prepare":
/******/ 					blockingPromises++;
/******/ 					promise.then(unblock, unblock);
/******/ 					return promise;
/******/ 				default:
/******/ 					return promise;
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function waitForBlockingPromises(fn) {
/******/ 			if (blockingPromises === 0) return fn();
/******/ 			return new Promise(function (resolve) {
/******/ 				blockingPromisesWaiting.push(function () {
/******/ 					resolve(fn());
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function hotCheck(applyOnUpdate) {
/******/ 			if (currentStatus !== "idle") {
/******/ 				throw new Error("check() is only allowed in idle status");
/******/ 			}
/******/ 			return setStatus("check")
/******/ 				.then(__webpack_require__.hmrM)
/******/ 				.then(function (update) {
/******/ 					if (!update) {
/******/ 						return setStatus(applyInvalidatedModules() ? "ready" : "idle").then(
/******/ 							function () {
/******/ 								return null;
/******/ 							}
/******/ 						);
/******/ 					}
/******/ 		
/******/ 					return setStatus("prepare").then(function () {
/******/ 						var updatedModules = [];
/******/ 						currentUpdateApplyHandlers = [];
/******/ 		
/******/ 						return Promise.all(
/******/ 							Object.keys(__webpack_require__.hmrC).reduce(function (
/******/ 								promises,
/******/ 								key
/******/ 							) {
/******/ 								__webpack_require__.hmrC[key](
/******/ 									update.c,
/******/ 									update.r,
/******/ 									update.m,
/******/ 									promises,
/******/ 									currentUpdateApplyHandlers,
/******/ 									updatedModules
/******/ 								);
/******/ 								return promises;
/******/ 							},
/******/ 							[])
/******/ 						).then(function () {
/******/ 							return waitForBlockingPromises(function () {
/******/ 								if (applyOnUpdate) {
/******/ 									return internalApply(applyOnUpdate);
/******/ 								} else {
/******/ 									return setStatus("ready").then(function () {
/******/ 										return updatedModules;
/******/ 									});
/******/ 								}
/******/ 							});
/******/ 						});
/******/ 					});
/******/ 				});
/******/ 		}
/******/ 		
/******/ 		function hotApply(options) {
/******/ 			if (currentStatus !== "ready") {
/******/ 				return Promise.resolve().then(function () {
/******/ 					throw new Error(
/******/ 						"apply() is only allowed in ready status (state: " +
/******/ 							currentStatus +
/******/ 							")"
/******/ 					);
/******/ 				});
/******/ 			}
/******/ 			return internalApply(options);
/******/ 		}
/******/ 		
/******/ 		function internalApply(options) {
/******/ 			options = options || {};
/******/ 		
/******/ 			applyInvalidatedModules();
/******/ 		
/******/ 			var results = currentUpdateApplyHandlers.map(function (handler) {
/******/ 				return handler(options);
/******/ 			});
/******/ 			currentUpdateApplyHandlers = undefined;
/******/ 		
/******/ 			var errors = results
/******/ 				.map(function (r) {
/******/ 					return r.error;
/******/ 				})
/******/ 				.filter(Boolean);
/******/ 		
/******/ 			if (errors.length > 0) {
/******/ 				return setStatus("abort").then(function () {
/******/ 					throw errors[0];
/******/ 				});
/******/ 			}
/******/ 		
/******/ 			// Now in "dispose" phase
/******/ 			var disposePromise = setStatus("dispose");
/******/ 		
/******/ 			results.forEach(function (result) {
/******/ 				if (result.dispose) result.dispose();
/******/ 			});
/******/ 		
/******/ 			// Now in "apply" phase
/******/ 			var applyPromise = setStatus("apply");
/******/ 		
/******/ 			var error;
/******/ 			var reportError = function (err) {
/******/ 				if (!error) error = err;
/******/ 			};
/******/ 		
/******/ 			var outdatedModules = [];
/******/ 			results.forEach(function (result) {
/******/ 				if (result.apply) {
/******/ 					var modules = result.apply(reportError);
/******/ 					if (modules) {
/******/ 						for (var i = 0; i < modules.length; i++) {
/******/ 							outdatedModules.push(modules[i]);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			});
/******/ 		
/******/ 			return Promise.all([disposePromise, applyPromise]).then(function () {
/******/ 				// handle errors in accept handlers and self accepted module load
/******/ 				if (error) {
/******/ 					return setStatus("fail").then(function () {
/******/ 						throw error;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				if (queuedInvalidatedModules) {
/******/ 					return internalApply(options).then(function (list) {
/******/ 						outdatedModules.forEach(function (moduleId) {
/******/ 							if (list.indexOf(moduleId) < 0) list.push(moduleId);
/******/ 						});
/******/ 						return list;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				return setStatus("idle").then(function () {
/******/ 					return outdatedModules;
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function applyInvalidatedModules() {
/******/ 			if (queuedInvalidatedModules) {
/******/ 				if (!currentUpdateApplyHandlers) currentUpdateApplyHandlers = [];
/******/ 				Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 					queuedInvalidatedModules.forEach(function (moduleId) {
/******/ 						__webpack_require__.hmrI[key](
/******/ 							moduleId,
/******/ 							currentUpdateApplyHandlers
/******/ 						);
/******/ 					});
/******/ 				});
/******/ 				queuedInvalidatedModules = undefined;
/******/ 				return true;
/******/ 			}
/******/ 		}
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	!function() {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	!function() {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = __webpack_require__.hmrS_jsonp = __webpack_require__.hmrS_jsonp || {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = function(chunkId, promises) {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise(function(resolve, reject) { installedChunkData = installedChunks[chunkId] = [resolve, reject]; });
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = function(event) {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						} else installedChunks[chunkId] = 0;
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		var currentUpdatedModulesList;
/******/ 		var waitingUpdateResolves = {};
/******/ 		function loadUpdateChunk(chunkId, updatedModulesList) {
/******/ 			currentUpdatedModulesList = updatedModulesList;
/******/ 			return new Promise(function(resolve, reject) {
/******/ 				waitingUpdateResolves[chunkId] = resolve;
/******/ 				// start update chunk loading
/******/ 				var url = __webpack_require__.p + __webpack_require__.hu(chunkId);
/******/ 				// create error before stack unwound to get useful stacktrace later
/******/ 				var error = new Error();
/******/ 				var loadingEnded = function(event) {
/******/ 					if(waitingUpdateResolves[chunkId]) {
/******/ 						waitingUpdateResolves[chunkId] = undefined
/******/ 						var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 						var realSrc = event && event.target && event.target.src;
/******/ 						error.message = 'Loading hot update chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 						error.name = 'ChunkLoadError';
/******/ 						error.type = errorType;
/******/ 						error.request = realSrc;
/******/ 						reject(error);
/******/ 					}
/******/ 				};
/******/ 				__webpack_require__.l(url, loadingEnded);
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		self["webpackHotUpdatecapi_simple_demo"] = function(chunkId, moreModules, runtime) {
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					currentUpdate[moduleId] = moreModules[moduleId];
/******/ 					if(currentUpdatedModulesList) currentUpdatedModulesList.push(moduleId);
/******/ 				}
/******/ 			}
/******/ 			if(runtime) currentUpdateRuntime.push(runtime);
/******/ 			if(waitingUpdateResolves[chunkId]) {
/******/ 				waitingUpdateResolves[chunkId]();
/******/ 				waitingUpdateResolves[chunkId] = undefined;
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		var currentUpdateChunks;
/******/ 		var currentUpdate;
/******/ 		var currentUpdateRemovedChunks;
/******/ 		var currentUpdateRuntime;
/******/ 		function applyHandler(options) {
/******/ 			if (__webpack_require__.f) delete __webpack_require__.f.jsonpHmr;
/******/ 			currentUpdateChunks = undefined;
/******/ 			function getAffectedModuleEffects(updateModuleId) {
/******/ 				var outdatedModules = [updateModuleId];
/******/ 				var outdatedDependencies = {};
/******/ 		
/******/ 				var queue = outdatedModules.map(function (id) {
/******/ 					return {
/******/ 						chain: [id],
/******/ 						id: id
/******/ 					};
/******/ 				});
/******/ 				while (queue.length > 0) {
/******/ 					var queueItem = queue.pop();
/******/ 					var moduleId = queueItem.id;
/******/ 					var chain = queueItem.chain;
/******/ 					var module = __webpack_require__.c[moduleId];
/******/ 					if (
/******/ 						!module ||
/******/ 						(module.hot._selfAccepted && !module.hot._selfInvalidated)
/******/ 					)
/******/ 						continue;
/******/ 					if (module.hot._selfDeclined) {
/******/ 						return {
/******/ 							type: "self-declined",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					if (module.hot._main) {
/******/ 						return {
/******/ 							type: "unaccepted",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					for (var i = 0; i < module.parents.length; i++) {
/******/ 						var parentId = module.parents[i];
/******/ 						var parent = __webpack_require__.c[parentId];
/******/ 						if (!parent) continue;
/******/ 						if (parent.hot._declinedDependencies[moduleId]) {
/******/ 							return {
/******/ 								type: "declined",
/******/ 								chain: chain.concat([parentId]),
/******/ 								moduleId: moduleId,
/******/ 								parentId: parentId
/******/ 							};
/******/ 						}
/******/ 						if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 						if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 							if (!outdatedDependencies[parentId])
/******/ 								outdatedDependencies[parentId] = [];
/******/ 							addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 							continue;
/******/ 						}
/******/ 						delete outdatedDependencies[parentId];
/******/ 						outdatedModules.push(parentId);
/******/ 						queue.push({
/******/ 							chain: chain.concat([parentId]),
/******/ 							id: parentId
/******/ 						});
/******/ 					}
/******/ 				}
/******/ 		
/******/ 				return {
/******/ 					type: "accepted",
/******/ 					moduleId: updateModuleId,
/******/ 					outdatedModules: outdatedModules,
/******/ 					outdatedDependencies: outdatedDependencies
/******/ 				};
/******/ 			}
/******/ 		
/******/ 			function addAllToSet(a, b) {
/******/ 				for (var i = 0; i < b.length; i++) {
/******/ 					var item = b[i];
/******/ 					if (a.indexOf(item) === -1) a.push(item);
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			// at begin all updates modules are outdated
/******/ 			// the "outdated" status can propagate to parents if they don't accept the children
/******/ 			var outdatedDependencies = {};
/******/ 			var outdatedModules = [];
/******/ 			var appliedUpdate = {};
/******/ 		
/******/ 			var warnUnexpectedRequire = function warnUnexpectedRequire(module) {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" + module.id + ") to disposed module"
/******/ 				);
/******/ 			};
/******/ 		
/******/ 			for (var moduleId in currentUpdate) {
/******/ 				if (__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 					var newModuleFactory = currentUpdate[moduleId];
/******/ 					/** @type {TODO} */
/******/ 					var result;
/******/ 					if (newModuleFactory) {
/******/ 						result = getAffectedModuleEffects(moduleId);
/******/ 					} else {
/******/ 						result = {
/******/ 							type: "disposed",
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					/** @type {Error|false} */
/******/ 					var abortError = false;
/******/ 					var doApply = false;
/******/ 					var doDispose = false;
/******/ 					var chainInfo = "";
/******/ 					if (result.chain) {
/******/ 						chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 					}
/******/ 					switch (result.type) {
/******/ 						case "self-declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of self decline: " +
/******/ 										result.moduleId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of declined dependency: " +
/******/ 										result.moduleId +
/******/ 										" in " +
/******/ 										result.parentId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "unaccepted":
/******/ 							if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 							if (!options.ignoreUnaccepted)
/******/ 								abortError = new Error(
/******/ 									"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "accepted":
/******/ 							if (options.onAccepted) options.onAccepted(result);
/******/ 							doApply = true;
/******/ 							break;
/******/ 						case "disposed":
/******/ 							if (options.onDisposed) options.onDisposed(result);
/******/ 							doDispose = true;
/******/ 							break;
/******/ 						default:
/******/ 							throw new Error("Unexception type " + result.type);
/******/ 					}
/******/ 					if (abortError) {
/******/ 						return {
/******/ 							error: abortError
/******/ 						};
/******/ 					}
/******/ 					if (doApply) {
/******/ 						appliedUpdate[moduleId] = newModuleFactory;
/******/ 						addAllToSet(outdatedModules, result.outdatedModules);
/******/ 						for (moduleId in result.outdatedDependencies) {
/******/ 							if (__webpack_require__.o(result.outdatedDependencies, moduleId)) {
/******/ 								if (!outdatedDependencies[moduleId])
/******/ 									outdatedDependencies[moduleId] = [];
/******/ 								addAllToSet(
/******/ 									outdatedDependencies[moduleId],
/******/ 									result.outdatedDependencies[moduleId]
/******/ 								);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 					if (doDispose) {
/******/ 						addAllToSet(outdatedModules, [result.moduleId]);
/******/ 						appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 			currentUpdate = undefined;
/******/ 		
/******/ 			// Store self accepted outdated modules to require them later by the module system
/******/ 			var outdatedSelfAcceptedModules = [];
/******/ 			for (var j = 0; j < outdatedModules.length; j++) {
/******/ 				var outdatedModuleId = outdatedModules[j];
/******/ 				var module = __webpack_require__.c[outdatedModuleId];
/******/ 				if (
/******/ 					module &&
/******/ 					(module.hot._selfAccepted || module.hot._main) &&
/******/ 					// removed self-accepted modules should not be required
/******/ 					appliedUpdate[outdatedModuleId] !== warnUnexpectedRequire &&
/******/ 					// when called invalidate self-accepting is not possible
/******/ 					!module.hot._selfInvalidated
/******/ 				) {
/******/ 					outdatedSelfAcceptedModules.push({
/******/ 						module: outdatedModuleId,
/******/ 						require: module.hot._requireSelf,
/******/ 						errorHandler: module.hot._selfAccepted
/******/ 					});
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			var moduleOutdatedDependencies;
/******/ 		
/******/ 			return {
/******/ 				dispose: function () {
/******/ 					currentUpdateRemovedChunks.forEach(function (chunkId) {
/******/ 						delete installedChunks[chunkId];
/******/ 					});
/******/ 					currentUpdateRemovedChunks = undefined;
/******/ 		
/******/ 					var idx;
/******/ 					var queue = outdatedModules.slice();
/******/ 					while (queue.length > 0) {
/******/ 						var moduleId = queue.pop();
/******/ 						var module = __webpack_require__.c[moduleId];
/******/ 						if (!module) continue;
/******/ 		
/******/ 						var data = {};
/******/ 		
/******/ 						// Call dispose handlers
/******/ 						var disposeHandlers = module.hot._disposeHandlers;
/******/ 						for (j = 0; j < disposeHandlers.length; j++) {
/******/ 							disposeHandlers[j].call(null, data);
/******/ 						}
/******/ 						__webpack_require__.hmrD[moduleId] = data;
/******/ 		
/******/ 						// disable module (this disables requires from this module)
/******/ 						module.hot.active = false;
/******/ 		
/******/ 						// remove module from cache
/******/ 						delete __webpack_require__.c[moduleId];
/******/ 		
/******/ 						// when disposing there is no need to call dispose handler
/******/ 						delete outdatedDependencies[moduleId];
/******/ 		
/******/ 						// remove "parents" references from all children
/******/ 						for (j = 0; j < module.children.length; j++) {
/******/ 							var child = __webpack_require__.c[module.children[j]];
/******/ 							if (!child) continue;
/******/ 							idx = child.parents.indexOf(moduleId);
/******/ 							if (idx >= 0) {
/******/ 								child.parents.splice(idx, 1);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// remove outdated dependency from module children
/******/ 					var dependency;
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									dependency = moduleOutdatedDependencies[j];
/******/ 									idx = module.children.indexOf(dependency);
/******/ 									if (idx >= 0) module.children.splice(idx, 1);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				},
/******/ 				apply: function (reportError) {
/******/ 					// insert new code
/******/ 					for (var updateModuleId in appliedUpdate) {
/******/ 						if (__webpack_require__.o(appliedUpdate, updateModuleId)) {
/******/ 							__webpack_require__.m[updateModuleId] = appliedUpdate[updateModuleId];
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// run new runtime modules
/******/ 					for (var i = 0; i < currentUpdateRuntime.length; i++) {
/******/ 						currentUpdateRuntime[i](__webpack_require__);
/******/ 					}
/******/ 		
/******/ 					// call accept handlers
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							var module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								var callbacks = [];
/******/ 								var errorHandlers = [];
/******/ 								var dependenciesForCallbacks = [];
/******/ 								for (var j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									var dependency = moduleOutdatedDependencies[j];
/******/ 									var acceptCallback =
/******/ 										module.hot._acceptedDependencies[dependency];
/******/ 									var errorHandler =
/******/ 										module.hot._acceptedErrorHandlers[dependency];
/******/ 									if (acceptCallback) {
/******/ 										if (callbacks.indexOf(acceptCallback) !== -1) continue;
/******/ 										callbacks.push(acceptCallback);
/******/ 										errorHandlers.push(errorHandler);
/******/ 										dependenciesForCallbacks.push(dependency);
/******/ 									}
/******/ 								}
/******/ 								for (var k = 0; k < callbacks.length; k++) {
/******/ 									try {
/******/ 										callbacks[k].call(null, moduleOutdatedDependencies);
/******/ 									} catch (err) {
/******/ 										if (typeof errorHandlers[k] === "function") {
/******/ 											try {
/******/ 												errorHandlers[k](err, {
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k]
/******/ 												});
/******/ 											} catch (err2) {
/******/ 												if (options.onErrored) {
/******/ 													options.onErrored({
/******/ 														type: "accept-error-handler-errored",
/******/ 														moduleId: outdatedModuleId,
/******/ 														dependencyId: dependenciesForCallbacks[k],
/******/ 														error: err2,
/******/ 														originalError: err
/******/ 													});
/******/ 												}
/******/ 												if (!options.ignoreErrored) {
/******/ 													reportError(err2);
/******/ 													reportError(err);
/******/ 												}
/******/ 											}
/******/ 										} else {
/******/ 											if (options.onErrored) {
/******/ 												options.onErrored({
/******/ 													type: "accept-errored",
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k],
/******/ 													error: err
/******/ 												});
/******/ 											}
/******/ 											if (!options.ignoreErrored) {
/******/ 												reportError(err);
/******/ 											}
/******/ 										}
/******/ 									}
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// Load self accepted modules
/******/ 					for (var o = 0; o < outdatedSelfAcceptedModules.length; o++) {
/******/ 						var item = outdatedSelfAcceptedModules[o];
/******/ 						var moduleId = item.module;
/******/ 						try {
/******/ 							item.require(moduleId);
/******/ 						} catch (err) {
/******/ 							if (typeof item.errorHandler === "function") {
/******/ 								try {
/******/ 									item.errorHandler(err, {
/******/ 										moduleId: moduleId,
/******/ 										module: __webpack_require__.c[moduleId]
/******/ 									});
/******/ 								} catch (err2) {
/******/ 									if (options.onErrored) {
/******/ 										options.onErrored({
/******/ 											type: "self-accept-error-handler-errored",
/******/ 											moduleId: moduleId,
/******/ 											error: err2,
/******/ 											originalError: err
/******/ 										});
/******/ 									}
/******/ 									if (!options.ignoreErrored) {
/******/ 										reportError(err2);
/******/ 										reportError(err);
/******/ 									}
/******/ 								}
/******/ 							} else {
/******/ 								if (options.onErrored) {
/******/ 									options.onErrored({
/******/ 										type: "self-accept-errored",
/******/ 										moduleId: moduleId,
/******/ 										error: err
/******/ 									});
/******/ 								}
/******/ 								if (!options.ignoreErrored) {
/******/ 									reportError(err);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					return outdatedModules;
/******/ 				}
/******/ 			};
/******/ 		}
/******/ 		__webpack_require__.hmrI.jsonp = function (moduleId, applyHandlers) {
/******/ 			if (!currentUpdate) {
/******/ 				currentUpdate = {};
/******/ 				currentUpdateRuntime = [];
/******/ 				currentUpdateRemovedChunks = [];
/******/ 				applyHandlers.push(applyHandler);
/******/ 			}
/******/ 			if (!__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 				currentUpdate[moduleId] = __webpack_require__.m[moduleId];
/******/ 			}
/******/ 		};
/******/ 		__webpack_require__.hmrC.jsonp = function (
/******/ 			chunkIds,
/******/ 			removedChunks,
/******/ 			removedModules,
/******/ 			promises,
/******/ 			applyHandlers,
/******/ 			updatedModulesList
/******/ 		) {
/******/ 			applyHandlers.push(applyHandler);
/******/ 			currentUpdateChunks = {};
/******/ 			currentUpdateRemovedChunks = removedChunks;
/******/ 			currentUpdate = removedModules.reduce(function (obj, key) {
/******/ 				obj[key] = false;
/******/ 				return obj;
/******/ 			}, {});
/******/ 			currentUpdateRuntime = [];
/******/ 			chunkIds.forEach(function (chunkId) {
/******/ 				if (
/******/ 					__webpack_require__.o(installedChunks, chunkId) &&
/******/ 					installedChunks[chunkId] !== undefined
/******/ 				) {
/******/ 					promises.push(loadUpdateChunk(chunkId, updatedModulesList));
/******/ 					currentUpdateChunks[chunkId] = true;
/******/ 				} else {
/******/ 					currentUpdateChunks[chunkId] = false;
/******/ 				}
/******/ 			});
/******/ 			if (__webpack_require__.f) {
/******/ 				__webpack_require__.f.jsonpHmr = function (chunkId, promises) {
/******/ 					if (
/******/ 						currentUpdateChunks &&
/******/ 						__webpack_require__.o(currentUpdateChunks, chunkId) &&
/******/ 						!currentUpdateChunks[chunkId]
/******/ 					) {
/******/ 						promises.push(loadUpdateChunk(chunkId));
/******/ 						currentUpdateChunks[chunkId] = true;
/******/ 					}
/******/ 				};
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.hmrM = function() {
/******/ 			if (typeof fetch === "undefined") throw new Error("No browser support: need fetch API");
/******/ 			return fetch(__webpack_require__.p + __webpack_require__.hmrF()).then(function(response) {
/******/ 				if(response.status === 404) return; // no update available
/******/ 				if(!response.ok) throw new Error("Failed to fetch update manifest " + response.statusText);
/******/ 				return response.json();
/******/ 			});
/******/ 		};
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = function(parentChunkLoadingFunction, data) {
/******/ 			var chunkIds = data[0];
/******/ 			var moreModules = data[1];
/******/ 			var runtime = data[2];
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some(function(id) { return installedChunks[id] !== 0; })) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkcapi_simple_demo"] = self["webpackChunkcapi_simple_demo"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsbUJBQW1CO0FBQ3BEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0JBQWdCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUEsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLCtDQUErQyxRQUFR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Q0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0NBQWdDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsS0FBSztXQUNMO1dBQ0E7O1dBRUE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7O1dBRUE7V0FDQSxrQkFBa0IsY0FBYztXQUNoQztXQUNBO1dBQ0E7V0FDQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7O1dBRUE7V0FDQTtXQUNBO1dBQ0EsY0FBYyxNQUFNO1dBQ3BCO1dBQ0E7V0FDQTtXQUNBLEtBQUs7V0FDTDtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsY0FBYyxhQUFhO1dBQzNCO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTtXQUNBO1dBQ0EsaUJBQWlCLDRCQUE0QjtXQUM3QztXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsSUFBSTtXQUNKO1dBQ0E7O1dBRUE7O1dBRUE7V0FDQTtXQUNBO1dBQ0E7V0FDQSxJQUFJO1dBQ0o7O1dBRUE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBOztXQUVBO1dBQ0E7V0FDQSxnQkFBZ0IsNEJBQTRCO1dBQzVDO1dBQ0E7V0FDQTs7V0FFQTtXQUNBOztXQUVBO1dBQ0E7O1dBRUE7V0FDQTs7V0FFQTtXQUNBLGdCQUFnQiw0QkFBNEI7V0FDNUM7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0Esa0JBQWtCLHVDQUF1QztXQUN6RDtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEdBQUc7V0FDSDtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTtXQUNBLG1CQUFtQixpQ0FBaUM7V0FDcEQ7V0FDQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHNCQUFzQix1Q0FBdUM7V0FDN0Q7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0Esc0JBQXNCLHNCQUFzQjtXQUM1QztXQUNBO1dBQ0EsU0FBUztXQUNUO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxXQUFXO1dBQ1gsV0FBVztXQUNYO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsWUFBWTtXQUNaO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLFVBQVU7V0FDVjtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxXQUFXO1dBQ1g7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7O1dBRUE7V0FDQSxtQkFBbUIsd0NBQXdDO1dBQzNEO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsTUFBTTtXQUNOO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxRQUFRO1dBQ1IsUUFBUTtXQUNSO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLFNBQVM7V0FDVDtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxPQUFPO1dBQ1A7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLFFBQVE7V0FDUjtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsRUFBRSxJQUFJO1dBQ047V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLElBQUk7V0FDSjtXQUNBO1dBQ0EsRUFBRTtXQUNGO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBO1dBQ0E7V0FDQTtXQUNBLHNDQUFzQztXQUN0QztXQUNBO1dBQ0EsRUFBRTtXQUNGOztXQUVBOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxpQ0FBaUMsbUNBQW1DO1dBQ3BFO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxNQUFNLHFCQUFxQjtXQUMzQjtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7O1dBRUE7O1dBRUE7V0FDQTtXQUNBOzs7OztVRWhrQkE7VUFDQTtVQUNBO1VBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXBpLXNpbXBsZS1kZW1vLy4vbm9kZV9tb2R1bGVzL0BkZW5vL3NoaW0tZGVuby10ZXN0L2Rpc3QvZGVmaW5pdGlvbnMuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9AZGVuby9zaGltLWRlbm8tdGVzdC9kaXN0L2luZGV4LmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvQGRlbm8vc2hpbS1kZW5vLXRlc3QvZGlzdC90ZXN0LmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvY2FwaS9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9zcmMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL3NyYy92aWV3LnRzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX2Fzc2VydC5qcyIsIndlYnBhY2s6Ly9jYXBpLXNpbXBsZS1kZW1vLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19ibGFrZTIuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fdTY0LmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vYmxha2UyYi5qcyIsIndlYnBhY2s6Ly9jYXBpLXNpbXBsZS1kZW1vLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2NyeXB0b0Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS91dGlscy5qcyIsIndlYnBhY2s6Ly9jYXBpLXNpbXBsZS1kZW1vLy4vbm9kZV9tb2R1bGVzL2NhcGkvZXNtL19kbnQuc2hpbXMuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9jYXBpL2VzbS9jb25maWcvbW9kLmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvY2FwaS9lc20vZGVwcy9ibGFrZTJiLmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvY2FwaS9lc20vZGVwcy9zY2FsZS5qcyIsIndlYnBhY2s6Ly9jYXBpLXNpbXBsZS1kZW1vLy4vbm9kZV9tb2R1bGVzL2NhcGkvZXNtL2RlcHMvc3RkL2FzeW5jLmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvY2FwaS9lc20vZGVwcy9zdGQvZW5jb2RpbmcvYmFzZTU4LmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvY2FwaS9lc20vZGVwcy9zdGQvZW5jb2RpbmcvaGV4LmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvY2FwaS9lc20vZGVwcy9zdGQvdGVzdGluZy9hc3NlcnRzLmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvY2FwaS9lc20vZGVwc18yL2Rlbm8ubGFuZC9zdGRAMC4xMjcuMC9hc3luYy9kZWFkbGluZS5qcyIsIndlYnBhY2s6Ly9jYXBpLXNpbXBsZS1kZW1vLy4vbm9kZV9tb2R1bGVzL2NhcGkvZXNtL2RlcHNfMi9kZW5vLmxhbmQvc3RkQDAuMTI3LjAvYXN5bmMvZGVib3VuY2UuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9jYXBpL2VzbS9kZXBzXzIvZGVuby5sYW5kL3N0ZEAwLjEyNy4wL2FzeW5jL2RlZmVycmVkLmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvY2FwaS9lc20vZGVwc18yL2Rlbm8ubGFuZC9zdGRAMC4xMjcuMC9hc3luYy9kZWxheS5qcyIsIndlYnBhY2s6Ly9jYXBpLXNpbXBsZS1kZW1vLy4vbm9kZV9tb2R1bGVzL2NhcGkvZXNtL2RlcHNfMi9kZW5vLmxhbmQvc3RkQDAuMTI3LjAvYXN5bmMvbW9kLmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvY2FwaS9lc20vZGVwc18yL2Rlbm8ubGFuZC9zdGRAMC4xMjcuMC9hc3luYy9tdXhfYXN5bmNfaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9jYXBpL2VzbS9kZXBzXzIvZGVuby5sYW5kL3N0ZEAwLjEyNy4wL2FzeW5jL3Bvb2wuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9jYXBpL2VzbS9kZXBzXzIvZGVuby5sYW5kL3N0ZEAwLjEyNy4wL2FzeW5jL3RlZS5qcyIsIndlYnBhY2s6Ly9jYXBpLXNpbXBsZS1kZW1vLy4vbm9kZV9tb2R1bGVzL2NhcGkvZXNtL2RlcHNfMi9kZW5vLmxhbmQvc3RkQDAuMTI3LjAvZW5jb2RpbmcvaGV4LmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvY2FwaS9lc20vZGVwc18yL2Rlbm8ubGFuZC9zdGRAMC4xNTQuMC9lbmNvZGluZy9iYXNlNTguanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9jYXBpL2VzbS9kZXBzXzIvZGVuby5sYW5kL3N0ZEAwLjE1OC4wL2ZtdC9jb2xvcnMuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9jYXBpL2VzbS9kZXBzXzIvZGVuby5sYW5kL3N0ZEAwLjE1OC4wL3Rlc3RpbmcvX2RpZmYuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9jYXBpL2VzbS9kZXBzXzIvZGVuby5sYW5kL3N0ZEAwLjE1OC4wL3Rlc3RpbmcvX2Zvcm1hdC5qcyIsIndlYnBhY2s6Ly9jYXBpLXNpbXBsZS1kZW1vLy4vbm9kZV9tb2R1bGVzL2NhcGkvZXNtL2RlcHNfMi9kZW5vLmxhbmQvc3RkQDAuMTU4LjAvdGVzdGluZy9hc3NlcnRzLmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvY2FwaS9lc20vZWZmZWN0L2F0b21zLyRFeHRyaW5zaWMuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9jYXBpL2VzbS9lZmZlY3QvYXRvbXMvJEtleS5qcyIsIndlYnBhY2s6Ly9jYXBpLXNpbXBsZS1kZW1vLy4vbm9kZV9tb2R1bGVzL2NhcGkvZXNtL2VmZmVjdC9hdG9tcy8kU3RvcmFnZUtleS5qcyIsIndlYnBhY2s6Ly9jYXBpLXNpbXBsZS1kZW1vLy4vbm9kZV9tb2R1bGVzL2NhcGkvZXNtL2VmZmVjdC9hdG9tcy9Db2RlYy5qcyIsIndlYnBhY2s6Ly9jYXBpLXNpbXBsZS1kZW1vLy4vbm9kZV9tb2R1bGVzL2NhcGkvZXNtL2VmZmVjdC9hdG9tcy9EZWNvZGVkLmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvY2FwaS9lc20vZWZmZWN0L2F0b21zL0Rlcml2ZUNvZGVjLmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvY2FwaS9lc20vZWZmZWN0L2F0b21zL01ldGFkYXRhLmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvY2FwaS9lc20vZWZmZWN0L2F0b21zL1JwY0NhbGwuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9jYXBpL2VzbS9lZmZlY3QvYXRvbXMvUnBjQ2xpZW50LmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvY2FwaS9lc20vZWZmZWN0L2F0b21zL1JwY1N1YnNjcmlwdGlvbi5qcyIsIndlYnBhY2s6Ly9jYXBpLXNpbXBsZS1kZW1vLy4vbm9kZV9tb2R1bGVzL2NhcGkvZXNtL2VmZmVjdC9hdG9tcy9TZWxlY3QuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9jYXBpL2VzbS9lZmZlY3QvYXRvbXMvU3RvcmFnZUtleS5qcyIsIndlYnBhY2s6Ly9jYXBpLXNpbXBsZS1kZW1vLy4vbm9kZV9tb2R1bGVzL2NhcGkvZXNtL2VmZmVjdC9hdG9tcy9XcmFwLmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvY2FwaS9lc20vZWZmZWN0L2F0b21zL2NvbW1vbi5qcyIsIndlYnBhY2s6Ly9jYXBpLXNpbXBsZS1kZW1vLy4vbm9kZV9tb2R1bGVzL2NhcGkvZXNtL2VmZmVjdC9hdG9tcy9tb2QuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9jYXBpL2VzbS9lZmZlY3QvbW9kLmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvY2FwaS9lc20vZWZmZWN0L3N0ZC9tb2QuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9jYXBpL2VzbS9lZmZlY3Qvc3RkL3JlYWRCbG9jay5qcyIsIndlYnBhY2s6Ly9jYXBpLXNpbXBsZS1kZW1vLy4vbm9kZV9tb2R1bGVzL2NhcGkvZXNtL2VmZmVjdC9zdGQvcmVhZEVudHJ5LmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvY2FwaS9lc20vZWZmZWN0L3N0ZC9yZWFkS2V5UGFnZS5qcyIsIndlYnBhY2s6Ly9jYXBpLXNpbXBsZS1kZW1vLy4vbm9kZV9tb2R1bGVzL2NhcGkvZXNtL2VmZmVjdC9zdGQvc3VibWl0QW5kV2F0Y2hFeHRyaW5zaWMuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9jYXBpL2VzbS9lZmZlY3Qvc3RkL3dhdGNoQmxvY2tzLmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvY2FwaS9lc20vZWZmZWN0L3N0ZC93YXRjaEVudHJ5LmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvY2FwaS9lc20vZWZmZWN0L3N5cy9BdG9tLmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvY2FwaS9lc20vZWZmZWN0L3N5cy9FZmZlY3QuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9jYXBpL2VzbS9lZmZlY3Qvc3lzL2tleS5qcyIsIndlYnBhY2s6Ly9jYXBpLXNpbXBsZS1kZW1vLy4vbm9kZV9tb2R1bGVzL2NhcGkvZXNtL2VmZmVjdC9zeXMvbW9kLmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvY2FwaS9lc20vZWZmZWN0L3N5cy9ydW4uanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9jYXBpL2VzbS9mcmFtZV9tZXRhZGF0YS9Db2RlYy5qcyIsIndlYnBhY2s6Ly9jYXBpLXNpbXBsZS1kZW1vLy4vbm9kZV9tb2R1bGVzL2NhcGkvZXNtL2ZyYW1lX21ldGFkYXRhL0NvbnRyYWN0LmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvY2FwaS9lc20vZnJhbWVfbWV0YWRhdGEvRXJhLmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvY2FwaS9lc20vZnJhbWVfbWV0YWRhdGEvRXh0cmluc2ljLmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvY2FwaS9lc20vZnJhbWVfbWV0YWRhdGEvS2V5LmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvY2FwaS9lc20vZnJhbWVfbWV0YWRhdGEvTWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9jYXBpL2VzbS9mcmFtZV9tZXRhZGF0YS9UeVZpc2l0b3IuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9jYXBpL2VzbS9mcmFtZV9tZXRhZGF0YS9tb2QuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9jYXBpL2VzbS9mcmFtZV9tZXRhZGF0YS9zY2FsZV9pbmZvLmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvY2FwaS9lc20vaGFzaGVycy9tb2QuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9jYXBpL2VzbS9oYXNoZXJzL3h4aGFzaC5qcyIsIndlYnBhY2s6Ly9jYXBpLXNpbXBsZS1kZW1vLy4vbm9kZV9tb2R1bGVzL2NhcGkvZXNtL2tub3duL2NvbmZpZ3MuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9jYXBpL2VzbS9rbm93bi9tb2QuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9jYXBpL2VzbS9rbm93bi9ycGMuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9jYXBpL2VzbS9rbm93bi90eXBlcy9hdXRob3IuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9jYXBpL2VzbS9rbm93bi90eXBlcy9iZWVmeS5qcyIsIndlYnBhY2s6Ly9jYXBpLXNpbXBsZS1kZW1vLy4vbm9kZV9tb2R1bGVzL2NhcGkvZXNtL2tub3duL3R5cGVzL2NoYWluX2hlYWQvdW5zdGFibGUvZm9sbG93LmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvY2FwaS9lc20va25vd24vdHlwZXMvY29tbW9uLmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvY2FwaS9lc20va25vd24vdHlwZXMvbW9kLmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvY2FwaS9lc20va25vd24vdHlwZXMvc3RhdGUuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9jYXBpL2VzbS9rbm93bi90eXBlcy9zeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9jYXBpL2VzbS9rbm93bi90eXBlcy90b2RvX29yZ2FuaXplX3RoZXNlLmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvY2FwaS9lc20vbW9kLmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvY2FwaS9lc20vcnBjL0Jhc2UuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9jYXBpL2VzbS9ycGMvY29tbW9uLmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvY2FwaS9lc20vcnBjL21lc3NhZ2VzLmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvY2FwaS9lc20vcnBjL21vZC5qcyIsIndlYnBhY2s6Ly9jYXBpLXNpbXBsZS1kZW1vLy4vbm9kZV9tb2R1bGVzL2NhcGkvZXNtL3JwYy9wcm92aWRlcnMvcHJveHkuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9jYXBpL2VzbS9ycGMvcHJvdmlkZXJzL3Ntb2xkb3QuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9jYXBpL2VzbS9ycGMvcHJvdmlkZXJzL3N0ZC5qcyIsIndlYnBhY2s6Ly9jYXBpLXNpbXBsZS1kZW1vLy4vbm9kZV9tb2R1bGVzL2NhcGkvZXNtL3JwYy91dGlsLmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvY2FwaS9lc20vc3M1OC9tb2QuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9jYXBpL2VzbS91dGlsL2JyYW5kZWQuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9jYXBpL2VzbS91dGlsL2Vycm9yLmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvY2FwaS9lc20vdXRpbC9oZXguanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9jYXBpL2VzbS91dGlsL21vZC5qcyIsIndlYnBhY2s6Ly9jYXBpLXNpbXBsZS1kZW1vLy4vbm9kZV9tb2R1bGVzL2NhcGkvZXNtL3V0aWwvdHlwZXMuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9jYXBpL2VzbS91dGlsL3dhdGNoLmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvcGFyaXR5LXNjYWxlLWNvZGVjL2VzbS9hcnJheS9jb2RlYy5qcyIsIndlYnBhY2s6Ly9jYXBpLXNpbXBsZS1kZW1vLy4vbm9kZV9tb2R1bGVzL3Bhcml0eS1zY2FsZS1jb2RlYy9lc20vYml0U2VxdWVuY2UvY29kZWMuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9wYXJpdHktc2NhbGUtY29kZWMvZXNtL2Jvb2wvY29kZWMuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9wYXJpdHktc2NhbGUtY29kZWMvZXNtL2NvbW1vbi5qcyIsIndlYnBhY2s6Ly9jYXBpLXNpbXBsZS1kZW1vLy4vbm9kZV9tb2R1bGVzL3Bhcml0eS1zY2FsZS1jb2RlYy9lc20vY29tcGFjdC9jb2RlYy5qcyIsIndlYnBhY2s6Ly9jYXBpLXNpbXBsZS1kZW1vLy4vbm9kZV9tb2R1bGVzL3Bhcml0eS1zY2FsZS1jb2RlYy9lc20vY29uc3RhbnRQYXR0ZXJuL2NvZGVjLmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvcGFyaXR5LXNjYWxlLWNvZGVjL2VzbS9kZWZlcnJlZC9jb2RlYy5qcyIsIndlYnBhY2s6Ly9jYXBpLXNpbXBsZS1kZW1vLy4vbm9kZV9tb2R1bGVzL3Bhcml0eS1zY2FsZS1jb2RlYy9lc20vZHVtbXkvY29kZWMuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9wYXJpdHktc2NhbGUtY29kZWMvZXNtL2luc3RhbmNlL2NvZGVjLmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvcGFyaXR5LXNjYWxlLWNvZGVjL2VzbS9pbnQvY29kZWMuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9wYXJpdHktc2NhbGUtY29kZWMvZXNtL2l0ZXJhYmxlL2NvZGVjLmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvcGFyaXR5LXNjYWxlLWNvZGVjL2VzbS9sZW5QcmVmaXhlZC9jb2RlYy5qcyIsIndlYnBhY2s6Ly9jYXBpLXNpbXBsZS1kZW1vLy4vbm9kZV9tb2R1bGVzL3Bhcml0eS1zY2FsZS1jb2RlYy9lc20vbW9kLmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvcGFyaXR5LXNjYWxlLWNvZGVjL2VzbS9uZXZlci9jb2RlYy5qcyIsIndlYnBhY2s6Ly9jYXBpLXNpbXBsZS1kZW1vLy4vbm9kZV9tb2R1bGVzL3Bhcml0eS1zY2FsZS1jb2RlYy9lc20vb2JqZWN0L2NvZGVjLmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvcGFyaXR5LXNjYWxlLWNvZGVjL2VzbS9vcHRpb24vY29kZWMuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9wYXJpdHktc2NhbGUtY29kZWMvZXNtL29wdGlvbi9vcHRpb25Cb29sL2NvZGVjLmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvcGFyaXR5LXNjYWxlLWNvZGVjL2VzbS9wcm9taXNlL2NvZGVjLmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvcGFyaXR5LXNjYWxlLWNvZGVjL2VzbS9yZXN1bHQvY29kZWMuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9wYXJpdHktc2NhbGUtY29kZWMvZXNtL3NwcmVhZC9jb2RlYy5qcyIsIndlYnBhY2s6Ly9jYXBpLXNpbXBsZS1kZW1vLy4vbm9kZV9tb2R1bGVzL3Bhcml0eS1zY2FsZS1jb2RlYy9lc20vc3RyL2NvZGVjLmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvcGFyaXR5LXNjYWxlLWNvZGVjL2VzbS90cmFuc2Zvcm0vY29kZWMuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9wYXJpdHktc2NhbGUtY29kZWMvZXNtL3R1cGxlL2NvZGVjLmpzIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vLi9ub2RlX21vZHVsZXMvcGFyaXR5LXNjYWxlLWNvZGVjL2VzbS91bmlvbi9jb2RlYy5qcyIsIndlYnBhY2s6Ly9jYXBpLXNpbXBsZS1kZW1vL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby93ZWJwYWNrL3J1bnRpbWUvZW5zdXJlIGNodW5rIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vd2VicGFjay9ydW50aW1lL2dldCBqYXZhc2NyaXB0IGNodW5rIGZpbGVuYW1lIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vd2VicGFjay9ydW50aW1lL2dldCBqYXZhc2NyaXB0IHVwZGF0ZSBjaHVuayBmaWxlbmFtZSIsIndlYnBhY2s6Ly9jYXBpLXNpbXBsZS1kZW1vL3dlYnBhY2svcnVudGltZS9nZXQgdXBkYXRlIG1hbmlmZXN0IGZpbGVuYW1lIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vd2VicGFjay9ydW50aW1lL2dldEZ1bGxIYXNoIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly9jYXBpLXNpbXBsZS1kZW1vL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby93ZWJwYWNrL3J1bnRpbWUvbG9hZCBzY3JpcHQiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vd2VicGFjay9ydW50aW1lL2hvdCBtb2R1bGUgcmVwbGFjZW1lbnQiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby93ZWJwYWNrL3J1bnRpbWUvcHVibGljUGF0aCIsIndlYnBhY2s6Ly9jYXBpLXNpbXBsZS1kZW1vL3dlYnBhY2svcnVudGltZS9qc29ucCBjaHVuayBsb2FkaW5nIiwid2VicGFjazovL2NhcGktc2ltcGxlLWRlbW8vd2VicGFjay9iZWZvcmUtc3RhcnR1cCIsIndlYnBhY2s6Ly9jYXBpLXNpbXBsZS1kZW1vL3dlYnBhY2svc3RhcnR1cCIsIndlYnBhY2s6Ly9jYXBpLXNpbXBsZS1kZW1vL3dlYnBhY2svYWZ0ZXItc3RhcnR1cCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLnRlc3REZWZpbml0aW9ucyA9IHZvaWQgMDtcclxuLyoqIFJlZmVyZW5jZSB0byB0aGUgYXJyYXkgdGhhdCBgRGVuby50ZXN0YCBjYWxscyBpbnNlcnQgdGhlaXIgZGVmaW5pdGlvbiBpbnRvLiAqL1xyXG5leHBvcnRzLnRlc3REZWZpbml0aW9ucyA9IFtdO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcclxuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XHJcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xyXG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufSkpO1xyXG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLnRlc3REZWZpbml0aW9ucyA9IGV4cG9ydHMuRGVubyA9IHZvaWQgMDtcclxuZXhwb3J0cy5EZW5vID0gcmVxdWlyZShcIi4vdGVzdC5qc1wiKTtcclxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3Rlc3QuanNcIiksIGV4cG9ydHMpO1xyXG52YXIgZGVmaW5pdGlvbnNfanNfMSA9IHJlcXVpcmUoXCIuL2RlZmluaXRpb25zLmpzXCIpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0ZXN0RGVmaW5pdGlvbnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlZmluaXRpb25zX2pzXzEudGVzdERlZmluaXRpb25zOyB9IH0pO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLnRlc3QgPSB2b2lkIDA7XHJcbmNvbnN0IGRlZmluaXRpb25zX2pzXzEgPSByZXF1aXJlKFwiLi9kZWZpbml0aW9ucy5qc1wiKTtcclxuY29uc3QgdGVzdCA9IGZ1bmN0aW9uIHRlc3QoKSB7XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgbGV0IHRlc3REZWY7XHJcbiAgICBjb25zdCBmaXJzdEFyZyA9IGFyZ3VtZW50c1swXTtcclxuICAgIGNvbnN0IHNlY29uZEFyZyA9IGFyZ3VtZW50c1sxXTtcclxuICAgIGNvbnN0IHRoaXJkQXJnID0gYXJndW1lbnRzWzJdO1xyXG4gICAgaWYgKHR5cGVvZiBmaXJzdEFyZyA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc2Vjb25kQXJnID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcmRBcmcgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlY29uZEFyZy5mbiAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuZXhwZWN0ZWQgJ2ZuJyBmaWVsZCBpbiBvcHRpb25zLCB0ZXN0IGZ1bmN0aW9uIGlzIGFscmVhZHkgcHJvdmlkZWQgYXMgdGhlIHRoaXJkIGFyZ3VtZW50LlwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc2Vjb25kQXJnLm5hbWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuZXhwZWN0ZWQgJ25hbWUnIGZpZWxkIGluIG9wdGlvbnMsIHRlc3QgbmFtZSBpcyBhbHJlYWR5IHByb3ZpZGVkIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gbmFtZSwgb3B0aW9ucywgZm5cclxuICAgICAgICAgICAgdGVzdERlZiA9IHsgbmFtZTogZmlyc3RBcmcsIGZuOiB0aGlyZEFyZywgLi4uc2Vjb25kQXJnIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBuYW1lLCBmblxyXG4gICAgICAgICAgICB0ZXN0RGVmID0geyBuYW1lOiBmaXJzdEFyZywgZm46IHNlY29uZEFyZyB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGZpcnN0QXJnIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcclxuICAgICAgICAvLyBmdW5jdGlvbiBvbmx5XHJcbiAgICAgICAgaWYgKGZpcnN0QXJnLm5hbWUubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgdGVzdCBmdW5jdGlvbiBtdXN0IGhhdmUgYSBuYW1lXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0ZXN0RGVmID0geyBmbjogZmlyc3RBcmcsIG5hbWU6IGZpcnN0QXJnLm5hbWUgfTtcclxuICAgICAgICBpZiAoc2Vjb25kQXJnICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuZXhwZWN0ZWQgc2Vjb25kIGFyZ3VtZW50IHRvIERlbm8udGVzdCgpXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBmaXJzdEFyZyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIHRlc3REZWYgPSB7IC4uLmZpcnN0QXJnIH07XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzZWNvbmRBcmcgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAvLyBvcHRpb25zLCBmblxyXG4gICAgICAgICAgICB0ZXN0RGVmLmZuID0gc2Vjb25kQXJnO1xyXG4gICAgICAgICAgICBpZiAoZmlyc3RBcmcuZm4gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuZXhwZWN0ZWQgJ2ZuJyBmaWVsZCBpbiBvcHRpb25zLCB0ZXN0IGZ1bmN0aW9uIGlzIGFscmVhZHkgcHJvdmlkZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudC5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRlc3REZWYubmFtZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2Vjb25kQXJnLm5hbWUubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSB0ZXN0IGZ1bmN0aW9uIG11c3QgaGF2ZSBhIG5hbWVcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBvcHRpb25zIHdpdGhvdXQgbmFtZSwgZm5cclxuICAgICAgICAgICAgICAgIHRlc3REZWYubmFtZSA9IHNlY29uZEFyZy5uYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGZpcnN0QXJnLmZuICE9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCAnZm4nIGZpZWxkIGluIHRoZSBmaXJzdCBhcmd1bWVudCB0byBiZSBhIHRlc3QgZnVuY3Rpb24uXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gdGVzdCBvdmVybG9hZFwiKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgdGVzdERlZi5mbiAhPT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk1pc3NpbmcgdGVzdCBmdW5jdGlvblwiKTtcclxuICAgIH1cclxuICAgIGlmICgoKF9iID0gKF9hID0gdGVzdERlZi5uYW1lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKSA9PT0gMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgdGVzdCBuYW1lIGNhbid0IGJlIGVtcHR5XCIpO1xyXG4gICAgfVxyXG4gICAgZGVmaW5pdGlvbnNfanNfMS50ZXN0RGVmaW5pdGlvbnMucHVzaCh0ZXN0RGVmKTtcclxufTtcclxuZXhwb3J0cy50ZXN0ID0gdGVzdDtcclxuIiwiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19jcmVhdGVCaW5kaW5nID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBvKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSBfX2NyZWF0ZUJpbmRpbmcobywgbSwgcCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XHJcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICByZXR1cm4gcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcclxuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXHJcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxufSkgOiBmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcclxuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcclxufVxyXG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBydW50aW1lID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIG9ialtrZXldO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gSUUgOCBoYXMgYSBicm9rZW4gT2JqZWN0LmRlZmluZVByb3BlcnR5IHRoYXQgb25seSB3b3JrcyBvbiBET00gb2JqZWN0cy5cbiAgICBkZWZpbmUoe30sIFwiXCIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZWZpbmUgPSBmdW5jdGlvbihvYmosIGtleSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBleHBvcnRzLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBkZWZpbmUoSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIGRlZmluZShHcCwgXCJjb25zdHJ1Y3RvclwiLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gIGRlZmluZShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCBHZW5lcmF0b3JGdW5jdGlvbik7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gZGVmaW5lKFxuICAgIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLFxuICAgIHRvU3RyaW5nVGFnU3ltYm9sLFxuICAgIFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICApO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIGRlZmluZShwcm90b3R5cGUsIG1ldGhvZCwgZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGRlZmluZShnZW5GdW4sIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIC8vIElmIGEgcmVqZWN0ZWQgUHJvbWlzZSB3YXMgeWllbGRlZCwgdGhyb3cgdGhlIHJlamVjdGlvbiBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSBoYW5kbGVkIHRoZXJlLlxuICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgZGVmaW5lKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlLCBhc3luY0l0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuICBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7XG4gICAgaWYgKFByb21pc2VJbXBsID09PSB2b2lkIDApIFByb21pc2VJbXBsID0gUHJvbWlzZTtcblxuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSxcbiAgICAgIFByb21pc2VJbXBsXG4gICAgKTtcblxuICAgIHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAvLyBOb3RlOiBbXCJyZXR1cm5cIl0gbXVzdCBiZSB1c2VkIGZvciBFUzMgcGFyc2luZyBjb21wYXRpYmlsaXR5LlxuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBkZWZpbmUoR3AsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvclwiKTtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIGRlZmluZShHcCwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KTtcblxuICBkZWZpbmUoR3AsIFwidG9TdHJpbmdcIiwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZVxuICAvLyBvciBub3QsIHJldHVybiB0aGUgcnVudGltZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZGVjbGFyZSB0aGUgdmFyaWFibGVcbiAgLy8gcmVnZW5lcmF0b3JSdW50aW1lIGluIHRoZSBvdXRlciBzY29wZSwgd2hpY2ggYWxsb3dzIHRoaXMgbW9kdWxlIHRvIGJlXG4gIC8vIGluamVjdGVkIGVhc2lseSBieSBgYmluL3JlZ2VuZXJhdG9yIC0taW5jbHVkZS1ydW50aW1lIHNjcmlwdC5qc2AuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KFxuICAvLyBJZiB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGUsIHVzZSBtb2R1bGUuZXhwb3J0c1xuICAvLyBhcyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIG5hbWVzcGFjZS4gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBlbXB0eVxuICAvLyBvYmplY3QuIEVpdGhlciB3YXksIHRoZSByZXN1bHRpbmcgb2JqZWN0IHdpbGwgYmUgdXNlZCB0byBpbml0aWFsaXplXG4gIC8vIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgdmFyaWFibGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUuXG4gIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgPyBtb2R1bGUuZXhwb3J0cyA6IHt9XG4pKTtcblxudHJ5IHtcbiAgcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbn0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XG4gIC8vIFRoaXMgbW9kdWxlIHNob3VsZCBub3QgYmUgcnVubmluZyBpbiBzdHJpY3QgbW9kZSwgc28gdGhlIGFib3ZlXG4gIC8vIGFzc2lnbm1lbnQgc2hvdWxkIGFsd2F5cyB3b3JrIHVubGVzcyBzb21ldGhpbmcgaXMgbWlzY29uZmlndXJlZC4gSnVzdFxuICAvLyBpbiBjYXNlIHJ1bnRpbWUuanMgYWNjaWRlbnRhbGx5IHJ1bnMgaW4gc3RyaWN0IG1vZGUsIGluIG1vZGVybiBlbmdpbmVzXG4gIC8vIHdlIGNhbiBleHBsaWNpdGx5IGFjY2VzcyBnbG9iYWxUaGlzLiBJbiBvbGRlciBlbmdpbmVzIHdlIGNhbiBlc2NhcGVcbiAgLy8gc3RyaWN0IG1vZGUgdXNpbmcgYSBnbG9iYWwgRnVuY3Rpb24gY2FsbC4gVGhpcyBjb3VsZCBjb25jZWl2YWJseSBmYWlsXG4gIC8vIGlmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgZm9yYmlkcyB1c2luZyBGdW5jdGlvbiwgYnV0IGluIHRoYXQgY2FzZVxuICAvLyB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzIHRvIGZpeCB0aGUgYWNjaWRlbnRhbCBzdHJpY3QgbW9kZSBwcm9ibGVtLiBJZlxuICAvLyB5b3UndmUgbWlzY29uZmlndXJlZCB5b3VyIGJ1bmRsZXIgdG8gZm9yY2Ugc3RyaWN0IG1vZGUgYW5kIGFwcGxpZWQgYVxuICAvLyBDU1AgdG8gZm9yYmlkIEZ1bmN0aW9uLCBhbmQgeW91J3JlIG5vdCB3aWxsaW5nIHRvIGZpeCBlaXRoZXIgb2YgdGhvc2VcbiAgLy8gcHJvYmxlbXMsIHBsZWFzZSBkZXRhaWwgeW91ciB1bmlxdWUgcHJlZGljYW1lbnQgaW4gYSBHaXRIdWIgaXNzdWUuXG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gXCJvYmplY3RcIikge1xuICAgIGdsb2JhbFRoaXMucmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbiAgfSBlbHNlIHtcbiAgICBGdW5jdGlvbihcInJcIiwgXCJyZWdlbmVyYXRvclJ1bnRpbWUgPSByXCIpKHJ1bnRpbWUpO1xuICB9XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MgKi9cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCAqL1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsICovXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXMgKi9cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC10ZW1wbGF0ZS1leHByZXNzaW9ucyAqL1xuaW1wb3J0IFwicmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lXCI7XG5pbXBvcnQgVUksIHsgZW1vamlzIH0gZnJvbSBcIi4vdmlld1wiO1xuaW1wb3J0ICogYXMgQyBmcm9tIFwiY2FwaVwiO1xud2luZG93Lm9ubG9hZCA9ICgpID0+IHtcbiAgICBjb25zdCBsb2FkVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnN0IHVpID0gbmV3IFVJKHsgY29udGFpbmVySWQ6IFwibWVzc2FnZXNcIiB9LCB7IGxvYWRUaW1lIH0pO1xuICAgIHVpLnNob3dTeW5jaW5nKCk7XG4gICAgdm9pZCAoYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBibG9jazogeyBibG9jayB9IH0gPSBhd2FpdCBDLnJlYWRCbG9jayhDLndlc3RlbmQpLnJ1bigpO1xuICAgICAgICAgICAgdWkuc2hvd1N5bmNlZCgpO1xuICAgICAgICAgICAgdWkubG9nKGAke2Vtb2ppcy5zZWVkbGluZ30gQ2hhaW4gaXMgcmVhZHkgKHBvd2VyZWQgYnkgQ0FQSSkgLSBSZWFkaW5nIGF0IGJsb2NrICMke3BhcnNlSW50KGJsb2NrLmhlYWRlci5udW1iZXIsIDApfWAsIHRydWUpO1xuICAgICAgICAgICAgY29uc3QgY2hhaW5OYW1lID0gYXdhaXQgQy5ycGNDYWxsKEMud2VzdGVuZCwgXCJzeXN0ZW1fY2hhaW5cIiwgW10pLnNlbGVjdChcInJlc3VsdFwiKS5ydW4oKTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWx0aCA9IGF3YWl0IEMucnBjQ2FsbChDLndlc3RlbmQsIFwic3lzdGVtX2hlYWx0aFwiLCBbXSkuc2VsZWN0KFwicmVzdWx0XCIpLnJ1bigpO1xuICAgICAgICAgICAgY29uc3QgZ2VuZXNpc0hhc2ggPSBhd2FpdCBDLnJwY0NhbGwoQy53ZXN0ZW5kLCBcImNoYWluX2dldEJsb2NrSGFzaFwiLCBbMF0pLnNlbGVjdChcInJlc3VsdFwiKS5ydW4oKTtcbiAgICAgICAgICAgIHVpLmxvZyhgJHtlbW9qaXMuaW5mb30gQ29ubmVjdGVkIHRvICR7Y2hhaW5OYW1lfSB3aXRoICR7aGVhbHRoLnBlZXJzfSBwZWVycy5gKTtcbiAgICAgICAgICAgIHVpLmxvZyhgJHtlbW9qaXMuY2hlcXVlcmVkRmxhZ30gR2VuZXNpcyBoYXNoIGlzICR7Z2VuZXNpc0hhc2h9YCk7XG4gICAgICAgICAgICB1aS5sb2coYCR7ZW1vamlzLm5ld3NwYXBlcn0gU3Vic2NyaWJpbmcgdG8gbmV3IGJsb2NrIGhlYWRlcnNgKTtcbiAgICAgICAgICAgIGNvbnN0IHJwYyA9IEMucnBjU3Vic2NyaXB0aW9uKEMud2VzdGVuZCwgXCJjaGFpbl9zdWJzY3JpYmVOZXdIZWFkXCIsIFtdLCAoKSA9PiAobSkgPT4gdWkubG9nKGAke2Vtb2ppcy5icmlja30gTmV3IGJsb2NrICMke3BhcnNlSW50KG0ucGFyYW1zLnJlc3VsdC5udW1iZXIsIDApfSBoYXMgaGFzaCAke20ucGFyYW1zLnJlc3VsdC5wYXJlbnRIYXNofWApKTtcbiAgICAgICAgICAgIGF3YWl0IEMucnVuKHJwYyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB1aS5lcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9KSgpO1xufTtcbiIsImV4cG9ydCBjb25zdCBlbW9qaXMgPSB7XG4gICAgYmFua25vdGU6IFwi8J+StVwiLFxuICAgIGJyaWNrOiBcIvCfp7FcIixcbiAgICBjaGFpbjogXCLwn5SXXCIsXG4gICAgY2hlcXVlcmVkRmxhZzogXCLwn4+BXCIsXG4gICAgY2xvY2s6IFwi8J+VklwiLFxuICAgIGluZm86IFwi4oS577iPXCIsXG4gICAgbmV3c3BhcGVyOiBcIvCfl57vuI9cIixcbiAgICBzZWVkbGluZzogXCLwn4yxXCIsXG4gICAgc3RldGhvc2NvcGU6IFwi8J+pulwiLFxuICAgIHRpY2s6IFwi4pyFXCIsXG59O1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVUkge1xuICAgIG9wdGlvbnM7XG4gICAgbW9kZWw7XG4gICAgY29udGFpbmVyO1xuICAgIHN5bmNTdGF0ZTtcbiAgICBzeW5jTWVzc2FnZTtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBtb2RlbCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMub3B0aW9ucy5jb250YWluZXJJZCk7XG4gICAgICAgIGlmIChjb250YWluZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiQ291bGQgbm90IGZpbmQgdGhlIGNvbnRhaW5lci4gRGlkIHlvdSBjaGFuZ2UgdGhlIEh0bWw/XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIH1cbiAgICB0aW1lRWxhcHNlZCA9IChmcm9tLCB0aWxsKSA9PiB7XG4gICAgICAgIHJldHVybiAoKHRpbGwgLSBmcm9tKSAvIDEwMDApLnRvRml4ZWQoMik7XG4gICAgfTtcbiAgICB0aW1lc3RhbXBIdG1sID0gKHdpdGhUaW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0aW1lXCIpO1xuICAgICAgICBpZiAoIXdpdGhUaW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGltZXN0YW1wRGl2O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgdGltZXN0YW1wRGl2LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGAke25ldyBEYXRlKCkudG9Mb2NhbGVUaW1lU3RyaW5nKCl9ICgke3RoaXMudGltZUVsYXBzZWQodGhpcy5tb2RlbC5sb2FkVGltZSwgdGltZSl9cylgKSk7XG4gICAgICAgIHJldHVybiB0aW1lc3RhbXBEaXY7XG4gICAgfTtcbiAgICBtZXNzYWdlSHRtbCA9IChtZXNzYWdlLCB3aXRoVGltZSkgPT4ge1xuICAgICAgICBjb25zdCBtZXNzYWdlRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgbWVzc2FnZURpdi5jbGFzc0xpc3QuYWRkKFwibWVzc2FnZVwiKTtcbiAgICAgICAgbWVzc2FnZURpdi5hcHBlbmRDaGlsZCh0aGlzLnRpbWVzdGFtcEh0bWwod2l0aFRpbWUpKTtcbiAgICAgICAgbWVzc2FnZURpdi5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShtZXNzYWdlKSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlRGl2O1xuICAgIH07XG4gICAgZXJyb3JIdG1sID0gKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgY29uc3QgbWVzc2FnZURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIG1lc3NhZ2VEaXYuY2xhc3NMaXN0LmFkZChcIm1lc3NhZ2VcIik7XG4gICAgICAgIG1lc3NhZ2VEaXYuY2xhc3NMaXN0LmFkZChcImVycm9yXCIpO1xuICAgICAgICBtZXNzYWdlRGl2LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG1lc3NhZ2UpKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VEaXY7XG4gICAgfTtcbiAgICBkaXNwbGF5TWVzc2FnZSA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgZXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgdGhpcy5kaXNwbGF5TWVzc2FnZSh0aGlzLmVycm9ySHRtbChlcnJvci5tZXNzYWdlKSk7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH07XG4gICAgbG9nID0gKG1lc3NhZ2UsIHdpdGhUaW1lKSA9PiB7XG4gICAgICAgIHRoaXMuZGlzcGxheU1lc3NhZ2UodGhpcy5tZXNzYWdlSHRtbChtZXNzYWdlLCB3aXRoVGltZSkpO1xuICAgIH07XG4gICAgaW5zZXJ0QXRUb3BPZkNvbnRhaW5lciA9IChlbCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5jb250YWluZXIuZmlyc3RDaGlsZCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5pbnNlcnRCZWZvcmUoZWwsIHRoaXMuY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBlbnN1cmVDbGFzc09uID0gKGVsLCBjbGFzc05hbWUpID0+IHtcbiAgICAgICAgaWYgKCFlbC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBzaG93U3luY2luZyA9ICgpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLnN5bmNNZXNzYWdlKSB7XG4gICAgICAgICAgICAvLyBtZXNzYWdlIGNvbnRhaW5lclxuICAgICAgICAgICAgY29uc3Qgc3luY1N0YXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHN5bmNTdGF0ZS5jbGFzc0xpc3QuYWRkKFwibWVzc2FnZVwiKTtcbiAgICAgICAgICAgIC8vY29udGVudHMgLSBlbXB0eSB0aW1lc3RhbXAgYW5kIHB1bHNpbmcgbWVzc2FnZVxuICAgICAgICAgICAgc3luY1N0YXRlLmFwcGVuZENoaWxkKHRoaXMudGltZXN0YW1wSHRtbCgpKTtcbiAgICAgICAgICAgIGNvbnN0IHN5bmNNZXNzYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImVtXCIpO1xuICAgICAgICAgICAgc3luY01lc3NhZ2UuY2xhc3NMaXN0LmFkZChcInB1bHNlXCIpO1xuICAgICAgICAgICAgc3luY01lc3NhZ2UuaW5uZXJIVE1MID0gYCR7ZW1vamlzLmNoYWlufSBDaGFpbiBpcyBzeW5jaW5nLi4uYDtcbiAgICAgICAgICAgIHN5bmNTdGF0ZS5hcHBlbmRDaGlsZChzeW5jTWVzc2FnZSk7XG4gICAgICAgICAgICB0aGlzLnN5bmNNZXNzYWdlID0gc3luY01lc3NhZ2U7XG4gICAgICAgICAgICB0aGlzLnN5bmNTdGF0ZSA9IHN5bmNTdGF0ZTtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0QXRUb3BPZkNvbnRhaW5lcih0aGlzLnN5bmNTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBDb3ZlciBjYXNlIHRoYXQgd2UgY2hhbmdlIGZyb20gc3luY2VkIHN0YXRlIGJhY2sgdG8gc3luY2luZy5cbiAgICAgICAgICAgIHRoaXMuc3luY01lc3NhZ2UuaW5uZXJIVE1MID0gYCR7ZW1vamlzLmNoYWlufSBDaGFpbiBpcyBzeW5jaW5nLi4uYDtcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlQ2xhc3NPbih0aGlzLnN5bmNNZXNzYWdlLCBcInB1bHNlXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBzaG93U3luY2VkID0gKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuc3luY1N0YXRlIHx8ICF0aGlzLnN5bmNNZXNzYWdlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSBpcyBubyBzeW5jIHN0YXRlIFVJIHRvIHVwZGF0ZS4gWW91IHNob3VsZCBoYXZlIGNhbGxlZCBgc2hvd1N5bmNpbmcoKWAgZmlyc3QuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3luY01lc3NhZ2UuY2xhc3NMaXN0LnJlbW92ZShcInB1bHNlXCIpO1xuICAgICAgICB0aGlzLnN5bmNNZXNzYWdlLmlubmVySFRNTCA9IGAke2Vtb2ppcy50aWNrfSBDaGFpbiBzeW5jZWQhYDtcbiAgICB9O1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIG51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBwb3NpdGl2ZSBpbnRlZ2VyOiAke259YCk7XG59XG5leHBvcnQgZnVuY3Rpb24gYm9vbChiKSB7XG4gICAgaWYgKHR5cGVvZiBiICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiwgbm90ICR7Yn1gKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBieXRlcyhiLCAuLi5sZW5ndGhzKSB7XG4gICAgaWYgKCEoYiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBVaW50OEFycmF5Jyk7XG4gICAgaWYgKGxlbmd0aHMubGVuZ3RoID4gMCAmJiAhbGVuZ3Rocy5pbmNsdWRlcyhiLmxlbmd0aCkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIFVpbnQ4QXJyYXkgb2YgbGVuZ3RoICR7bGVuZ3Roc30sIG5vdCBvZiBsZW5ndGg9JHtiLmxlbmd0aH1gKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoYXNoKGhhc2gpIHtcbiAgICBpZiAodHlwZW9mIGhhc2ggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGhhc2guY3JlYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggc2hvdWxkIGJlIHdyYXBwZWQgYnkgdXRpbHMud3JhcENvbnN0cnVjdG9yJyk7XG4gICAgbnVtYmVyKGhhc2gub3V0cHV0TGVuKTtcbiAgICBudW1iZXIoaGFzaC5ibG9ja0xlbik7XG59XG5leHBvcnQgZnVuY3Rpb24gZXhpc3RzKGluc3RhbmNlLCBjaGVja0ZpbmlzaGVkID0gdHJ1ZSkge1xuICAgIGlmIChpbnN0YW5jZS5kZXN0cm95ZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQnKTtcbiAgICBpZiAoY2hlY2tGaW5pc2hlZCAmJiBpbnN0YW5jZS5maW5pc2hlZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoI2RpZ2VzdCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gb3V0cHV0KG91dCwgaW5zdGFuY2UpIHtcbiAgICBieXRlcyhvdXQpO1xuICAgIGNvbnN0IG1pbiA9IGluc3RhbmNlLm91dHB1dExlbjtcbiAgICBpZiAob3V0Lmxlbmd0aCA8IG1pbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICR7bWlufWApO1xuICAgIH1cbn1cbmNvbnN0IGFzc2VydCA9IHtcbiAgICBudW1iZXIsXG4gICAgYm9vbCxcbiAgICBieXRlcyxcbiAgICBoYXNoLFxuICAgIGV4aXN0cyxcbiAgICBvdXRwdXQsXG59O1xuZXhwb3J0IGRlZmF1bHQgYXNzZXJ0O1xuIiwiaW1wb3J0IGFzc2VydCBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgSGFzaCwgdG9CeXRlcywgdTMyIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCBjb25zdCBTSUdNQSA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LFxuICAgIDE0LCAxMCwgNCwgOCwgOSwgMTUsIDEzLCA2LCAxLCAxMiwgMCwgMiwgMTEsIDcsIDUsIDMsXG4gICAgMTEsIDgsIDEyLCAwLCA1LCAyLCAxNSwgMTMsIDEwLCAxNCwgMywgNiwgNywgMSwgOSwgNCxcbiAgICA3LCA5LCAzLCAxLCAxMywgMTIsIDExLCAxNCwgMiwgNiwgNSwgMTAsIDQsIDAsIDE1LCA4LFxuICAgIDksIDAsIDUsIDcsIDIsIDQsIDEwLCAxNSwgMTQsIDEsIDExLCAxMiwgNiwgOCwgMywgMTMsXG4gICAgMiwgMTIsIDYsIDEwLCAwLCAxMSwgOCwgMywgNCwgMTMsIDcsIDUsIDE1LCAxNCwgMSwgOSxcbiAgICAxMiwgNSwgMSwgMTUsIDE0LCAxMywgNCwgMTAsIDAsIDcsIDYsIDMsIDksIDIsIDgsIDExLFxuICAgIDEzLCAxMSwgNywgMTQsIDEyLCAxLCAzLCA5LCA1LCAwLCAxNSwgNCwgOCwgNiwgMiwgMTAsXG4gICAgNiwgMTUsIDE0LCA5LCAxMSwgMywgMCwgOCwgMTIsIDIsIDEzLCA3LCAxLCA0LCAxMCwgNSxcbiAgICAxMCwgMiwgOCwgNCwgNywgNiwgMSwgNSwgMTUsIDExLCA5LCAxNCwgMywgMTIsIDEzLCAwLFxuICAgIC8vIEZvciBCTEFLRTJiLCB0aGUgdHdvIGV4dHJhIHBlcm11dGF0aW9ucyBmb3Igcm91bmRzIDEwIGFuZCAxMSBhcmUgU0lHTUFbMTAuLjExXSA9IFNJR01BWzAuLjFdLlxuICAgIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsXG4gICAgMTQsIDEwLCA0LCA4LCA5LCAxNSwgMTMsIDYsIDEsIDEyLCAwLCAyLCAxMSwgNywgNSwgMyxcbl0pO1xuZXhwb3J0IGNsYXNzIEJMQUtFMiBleHRlbmRzIEhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBvdXRwdXRMZW4sIG9wdHMgPSB7fSwga2V5TGVuLCBzYWx0TGVuLCBwZXJzTGVuKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIGFzc2VydC5udW1iZXIoYmxvY2tMZW4pO1xuICAgICAgICBhc3NlcnQubnVtYmVyKG91dHB1dExlbik7XG4gICAgICAgIGFzc2VydC5udW1iZXIoa2V5TGVuKTtcbiAgICAgICAgaWYgKG91dHB1dExlbiA8IDAgfHwgb3V0cHV0TGVuID4ga2V5TGVuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCbGFrZTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBrZXlMZW4nKTtcbiAgICAgICAgaWYgKG9wdHMua2V5ICE9PSB1bmRlZmluZWQgJiYgKG9wdHMua2V5Lmxlbmd0aCA8IDEgfHwgb3B0cy5rZXkubGVuZ3RoID4ga2V5TGVuKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5IHNob3VsZCBiZSB1cCAxLi4ke2tleUxlbn0gYnl0ZSBsb25nIG9yIHVuZGVmaW5lZGApO1xuICAgICAgICBpZiAob3B0cy5zYWx0ICE9PSB1bmRlZmluZWQgJiYgb3B0cy5zYWx0Lmxlbmd0aCAhPT0gc2FsdExlbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU2FsdCBzaG91bGQgYmUgJHtzYWx0TGVufSBieXRlIGxvbmcgb3IgdW5kZWZpbmVkYCk7XG4gICAgICAgIGlmIChvcHRzLnBlcnNvbmFsaXphdGlvbiAhPT0gdW5kZWZpbmVkICYmIG9wdHMucGVyc29uYWxpemF0aW9uLmxlbmd0aCAhPT0gcGVyc0xlbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUGVyc29uYWxpemF0aW9uIHNob3VsZCBiZSAke3BlcnNMZW59IGJ5dGUgbG9uZyBvciB1bmRlZmluZWRgKTtcbiAgICAgICAgdGhpcy5idWZmZXIzMiA9IHUzMigodGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShibG9ja0xlbikpKTtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgYXNzZXJ0LmV4aXN0cyh0aGlzKTtcbiAgICAgICAgLy8gTWFpbiBkaWZmZXJlbmNlIHdpdGggb3RoZXIgaGFzaGVzOiB0aGVyZSBpcyBmbGFnIGZvciBsYXN0IGJsb2NrLFxuICAgICAgICAvLyBzbyB3ZSBjYW5ub3QgcHJvY2VzcyBjdXJyZW50IGJsb2NrIGJlZm9yZSB3ZSBrbm93IHRoYXQgdGhlcmVcbiAgICAgICAgLy8gaXMgdGhlIG5leHQgb25lLiBUaGlzIHNpZ25pZmljYW50bHkgY29tcGxpY2F0ZXMgbG9naWMgYW5kIHJlZHVjZXMgYWJpbGl0eVxuICAgICAgICAvLyB0byBkbyB6ZXJvLWNvcHkgcHJvY2Vzc2luZ1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGJ1ZmZlcjMyIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gdG9CeXRlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIC8vIElmIGJ1ZmZlciBpcyBmdWxsIGFuZCB3ZSBzdGlsbCBoYXZlIGlucHV0IChkb24ndCBwcm9jZXNzIGxhc3QgYmxvY2ssIHNhbWUgYXMgYmxha2UycylcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXByZXNzKGJ1ZmZlcjMyLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICBjb25zdCBkYXRhT2Zmc2V0ID0gZGF0YS5ieXRlT2Zmc2V0ICsgcG9zO1xuICAgICAgICAgICAgLy8gZnVsbCBibG9jayAmJiBhbGlnbmVkIHRvIDQgYnl0ZXMgJiYgbm90IGxhc3QgaW4gaW5wdXRcbiAgICAgICAgICAgIGlmICh0YWtlID09PSBibG9ja0xlbiAmJiAhKGRhdGFPZmZzZXQgJSA0KSAmJiBwb3MgKyB0YWtlIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YTMyID0gbmV3IFVpbnQzMkFycmF5KGRhdGEuYnVmZmVyLCBkYXRhT2Zmc2V0LCBNYXRoLmZsb29yKChsZW4gLSBwb3MpIC8gNCkpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHBvczMyID0gMDsgcG9zICsgYmxvY2tMZW4gPCBsZW47IHBvczMyICs9IGJ1ZmZlcjMyLmxlbmd0aCwgcG9zICs9IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoICs9IGJsb2NrTGVuO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXByZXNzKGRhdGEzMiwgcG9zMzIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyB0YWtlKSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgYXNzZXJ0LmV4aXN0cyh0aGlzKTtcbiAgICAgICAgYXNzZXJ0Lm91dHB1dChvdXQsIHRoaXMpO1xuICAgICAgICBjb25zdCB7IHBvcywgYnVmZmVyMzIgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAvLyBQYWRkaW5nXG4gICAgICAgIHRoaXMuYnVmZmVyLnN1YmFycmF5KHBvcykuZmlsbCgwKTtcbiAgICAgICAgdGhpcy5jb21wcmVzcyhidWZmZXIzMiwgMCwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IG91dDMyID0gdTMyKG91dCk7XG4gICAgICAgIHRoaXMuZ2V0KCkuZm9yRWFjaCgodiwgaSkgPT4gKG91dDMyW2ldID0gdikpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhidWZmZXIpO1xuICAgICAgICBjb25zdCByZXMgPSBidWZmZXIuc2xpY2UoMCwgb3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgb3V0cHV0TGVuLCBwb3MgfSA9IHRoaXM7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHsgZGtMZW46IG91dHB1dExlbiB9KSk7XG4gICAgICAgIHRvLnNldCguLi50aGlzLmdldCgpKTtcbiAgICAgICAgdG8ubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8uYnVmZmVyLnNldChidWZmZXIpO1xuICAgICAgICB0by5wb3MgPSBwb3M7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG4iLCJjb25zdCBVMzJfTUFTSzY0ID0gQmlnSW50KDIgKiogMzIgLSAxKTtcbmNvbnN0IF8zMm4gPSBCaWdJbnQoMzIpO1xuLy8gV2UgYXJlIG5vdCB1c2luZyBCaWdVaW50NjRBcnJheSwgYmVjYXVzZSB0aGV5IGFyZSBleHRyZW1lbHkgc2xvdyBhcyBwZXIgMjAyMlxuZXhwb3J0IGZ1bmN0aW9uIGZyb21CaWcobiwgbGUgPSBmYWxzZSkge1xuICAgIGlmIChsZSlcbiAgICAgICAgcmV0dXJuIHsgaDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSwgbDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfTtcbiAgICByZXR1cm4geyBoOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB8IDAsIGw6IE51bWJlcihuICYgVTMyX01BU0s2NCkgfCAwIH07XG59XG5leHBvcnQgZnVuY3Rpb24gc3BsaXQobHN0LCBsZSA9IGZhbHNlKSB7XG4gICAgbGV0IEFoID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xuICAgIGxldCBBbCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB7IGgsIGwgfSA9IGZyb21CaWcobHN0W2ldLCBsZSk7XG4gICAgICAgIFtBaFtpXSwgQWxbaV1dID0gW2gsIGxdO1xuICAgIH1cbiAgICByZXR1cm4gW0FoLCBBbF07XG59XG5leHBvcnQgY29uc3QgdG9CaWcgPSAoaCwgbCkgPT4gKEJpZ0ludChoID4+PiAwKSA8PCBfMzJuKSB8IEJpZ0ludChsID4+PiAwKTtcbi8vIGZvciBTaGlmdCBpbiBbMCwgMzIpXG5jb25zdCBzaHJTSCA9IChoLCBsLCBzKSA9PiBoID4+PiBzO1xuY29uc3Qgc2hyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RyU0ggPSAoaCwgbCwgcykgPT4gKGggPj4+IHMpIHwgKGwgPDwgKDMyIC0gcykpO1xuY29uc3Qgcm90clNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdHJCSCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoNjQgLSBzKSkgfCAobCA+Pj4gKHMgLSAzMikpO1xuY29uc3Qgcm90ckJMID0gKGgsIGwsIHMpID0+IChoID4+PiAocyAtIDMyKSkgfCAobCA8PCAoNjQgLSBzKSk7XG4vLyBSaWdodCByb3RhdGUgZm9yIHNoaWZ0PT09MzIgKGp1c3Qgc3dhcHMgbCZoKVxuY29uc3Qgcm90cjMySCA9IChoLCBsKSA9PiBsO1xuY29uc3Qgcm90cjMyTCA9IChoLCBsKSA9PiBoO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdGxTSCA9IChoLCBsLCBzKSA9PiAoaCA8PCBzKSB8IChsID4+PiAoMzIgLSBzKSk7XG5jb25zdCByb3RsU0wgPSAoaCwgbCwgcykgPT4gKGwgPDwgcykgfCAoaCA+Pj4gKDMyIC0gcykpO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RsQkggPSAoaCwgbCwgcykgPT4gKGwgPDwgKHMgLSAzMikpIHwgKGggPj4+ICg2NCAtIHMpKTtcbmNvbnN0IHJvdGxCTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAocyAtIDMyKSkgfCAobCA+Pj4gKDY0IC0gcykpO1xuLy8gSlMgdXNlcyAzMi1iaXQgc2lnbmVkIGludGVnZXJzIGZvciBiaXR3aXNlIG9wZXJhdGlvbnMgd2hpY2ggbWVhbnMgd2UgY2Fubm90XG4vLyBzaW1wbGUgdGFrZSBjYXJyeSBvdXQgb2YgbG93IGJpdCBzdW0gYnkgc2hpZnQsIHdlIG5lZWQgdG8gdXNlIGRpdmlzaW9uLlxuLy8gUmVtb3ZpbmcgXCJleHBvcnRcIiBoYXMgNSUgcGVyZiBwZW5hbHR5IC1fLVxuZXhwb3J0IGZ1bmN0aW9uIGFkZChBaCwgQWwsIEJoLCBCbCkge1xuICAgIGNvbnN0IGwgPSAoQWwgPj4+IDApICsgKEJsID4+PiAwKTtcbiAgICByZXR1cm4geyBoOiAoQWggKyBCaCArICgobCAvIDIgKiogMzIpIHwgMCkpIHwgMCwgbDogbCB8IDAgfTtcbn1cbi8vIEFkZGl0aW9uIHdpdGggbW9yZSB0aGFuIDIgZWxlbWVudHNcbmNvbnN0IGFkZDNMID0gKEFsLCBCbCwgQ2wpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKTtcbmNvbnN0IGFkZDNIID0gKGxvdywgQWgsIEJoLCBDaCkgPT4gKEFoICsgQmggKyBDaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuY29uc3QgYWRkNEwgPSAoQWwsIEJsLCBDbCwgRGwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCk7XG5jb25zdCBhZGQ0SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmNvbnN0IGFkZDVMID0gKEFsLCBCbCwgQ2wsIERsLCBFbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKSArIChFbCA+Pj4gMCk7XG5jb25zdCBhZGQ1SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoLCBFaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgRWggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgdTY0ID0ge1xuICAgIGZyb21CaWcsIHNwbGl0LCB0b0JpZyxcbiAgICBzaHJTSCwgc2hyU0wsXG4gICAgcm90clNILCByb3RyU0wsIHJvdHJCSCwgcm90ckJMLFxuICAgIHJvdHIzMkgsIHJvdHIzMkwsXG4gICAgcm90bFNILCByb3RsU0wsIHJvdGxCSCwgcm90bEJMLFxuICAgIGFkZCwgYWRkM0wsIGFkZDNILCBhZGQ0TCwgYWRkNEgsIGFkZDVILCBhZGQ1TCxcbn07XG5leHBvcnQgZGVmYXVsdCB1NjQ7XG4iLCJpbXBvcnQgeyBCTEFLRTIsIFNJR01BIH0gZnJvbSAnLi9fYmxha2UyLmpzJztcbmltcG9ydCB1NjQgZnJvbSAnLi9fdTY0LmpzJztcbmltcG9ydCB7IHRvQnl0ZXMsIHUzMiwgd3JhcENvbnN0cnVjdG9yV2l0aE9wdHMgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFNhbWUgYXMgU0hBLTUxMiBidXQgTEVcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgSVYgPSBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4ZjNiY2M5MDgsIDB4NmEwOWU2NjcsIDB4ODRjYWE3M2IsIDB4YmI2N2FlODUsIDB4ZmU5NGY4MmIsIDB4M2M2ZWYzNzIsIDB4NWYxZDM2ZjEsIDB4YTU0ZmY1M2EsXG4gICAgMHhhZGU2ODJkMSwgMHg1MTBlNTI3ZiwgMHgyYjNlNmMxZiwgMHg5YjA1Njg4YywgMHhmYjQxYmQ2YiwgMHgxZjgzZDlhYiwgMHgxMzdlMjE3OSwgMHg1YmUwY2QxOVxuXSk7XG4vLyBUZW1wb3JhcnkgYnVmZmVyXG5jb25zdCBCVUYgPSBuZXcgVWludDMyQXJyYXkoMzIpO1xuLy8gTWl4aW5nIGZ1bmN0aW9uIEcgc3BsaXR0ZWQgaW4gdHdvIGhhbGZzXG5mdW5jdGlvbiBHMShhLCBiLCBjLCBkLCBtc2csIHgpIHtcbiAgICAvLyBOT1RFOiBWIGlzIExFIGhlcmVcbiAgICBjb25zdCBYbCA9IG1zZ1t4XSwgWGggPSBtc2dbeCArIDFdOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBsZXQgQWwgPSBCVUZbMiAqIGFdLCBBaCA9IEJVRlsyICogYSArIDFdOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBsZXQgQmwgPSBCVUZbMiAqIGJdLCBCaCA9IEJVRlsyICogYiArIDFdOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBsZXQgQ2wgPSBCVUZbMiAqIGNdLCBDaCA9IEJVRlsyICogYyArIDFdOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBsZXQgRGwgPSBCVUZbMiAqIGRdLCBEaCA9IEJVRlsyICogZCArIDFdOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAvLyB2W2FdID0gKHZbYV0gKyB2W2JdICsgeCkgfCAwO1xuICAgIGxldCBsbCA9IHU2NC5hZGQzTChBbCwgQmwsIFhsKTtcbiAgICBBaCA9IHU2NC5hZGQzSChsbCwgQWgsIEJoLCBYaCk7XG4gICAgQWwgPSBsbCB8IDA7XG4gICAgLy8gdltkXSA9IHJvdHIodltkXSBeIHZbYV0sIDMyKVxuICAgICh7IERoLCBEbCB9ID0geyBEaDogRGggXiBBaCwgRGw6IERsIF4gQWwgfSk7XG4gICAgKHsgRGgsIERsIH0gPSB7IERoOiB1NjQucm90cjMySChEaCwgRGwpLCBEbDogdTY0LnJvdHIzMkwoRGgsIERsKSB9KTtcbiAgICAvLyB2W2NdID0gKHZbY10gKyB2W2RdKSB8IDA7XG4gICAgKHsgaDogQ2gsIGw6IENsIH0gPSB1NjQuYWRkKENoLCBDbCwgRGgsIERsKSk7XG4gICAgLy8gdltiXSA9IHJvdHIodltiXSBeIHZbY10sIDI0KVxuICAgICh7IEJoLCBCbCB9ID0geyBCaDogQmggXiBDaCwgQmw6IEJsIF4gQ2wgfSk7XG4gICAgKHsgQmgsIEJsIH0gPSB7IEJoOiB1NjQucm90clNIKEJoLCBCbCwgMjQpLCBCbDogdTY0LnJvdHJTTChCaCwgQmwsIDI0KSB9KTtcbiAgICAoQlVGWzIgKiBhXSA9IEFsKSwgKEJVRlsyICogYSArIDFdID0gQWgpO1xuICAgIChCVUZbMiAqIGJdID0gQmwpLCAoQlVGWzIgKiBiICsgMV0gPSBCaCk7XG4gICAgKEJVRlsyICogY10gPSBDbCksIChCVUZbMiAqIGMgKyAxXSA9IENoKTtcbiAgICAoQlVGWzIgKiBkXSA9IERsKSwgKEJVRlsyICogZCArIDFdID0gRGgpO1xufVxuZnVuY3Rpb24gRzIoYSwgYiwgYywgZCwgbXNnLCB4KSB7XG4gICAgLy8gTk9URTogViBpcyBMRSBoZXJlXG4gICAgY29uc3QgWGwgPSBtc2dbeF0sIFhoID0gbXNnW3ggKyAxXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IEFsID0gQlVGWzIgKiBhXSwgQWggPSBCVUZbMiAqIGEgKyAxXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IEJsID0gQlVGWzIgKiBiXSwgQmggPSBCVUZbMiAqIGIgKyAxXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IENsID0gQlVGWzIgKiBjXSwgQ2ggPSBCVUZbMiAqIGMgKyAxXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IERsID0gQlVGWzIgKiBkXSwgRGggPSBCVUZbMiAqIGQgKyAxXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgLy8gdlthXSA9ICh2W2FdICsgdltiXSArIHgpIHwgMDtcbiAgICBsZXQgbGwgPSB1NjQuYWRkM0woQWwsIEJsLCBYbCk7XG4gICAgQWggPSB1NjQuYWRkM0gobGwsIEFoLCBCaCwgWGgpO1xuICAgIEFsID0gbGwgfCAwO1xuICAgIC8vIHZbZF0gPSByb3RyKHZbZF0gXiB2W2FdLCAxNilcbiAgICAoeyBEaCwgRGwgfSA9IHsgRGg6IERoIF4gQWgsIERsOiBEbCBeIEFsIH0pO1xuICAgICh7IERoLCBEbCB9ID0geyBEaDogdTY0LnJvdHJTSChEaCwgRGwsIDE2KSwgRGw6IHU2NC5yb3RyU0woRGgsIERsLCAxNikgfSk7XG4gICAgLy8gdltjXSA9ICh2W2NdICsgdltkXSkgfCAwO1xuICAgICh7IGg6IENoLCBsOiBDbCB9ID0gdTY0LmFkZChDaCwgQ2wsIERoLCBEbCkpO1xuICAgIC8vIHZbYl0gPSByb3RyKHZbYl0gXiB2W2NdLCA2MylcbiAgICAoeyBCaCwgQmwgfSA9IHsgQmg6IEJoIF4gQ2gsIEJsOiBCbCBeIENsIH0pO1xuICAgICh7IEJoLCBCbCB9ID0geyBCaDogdTY0LnJvdHJCSChCaCwgQmwsIDYzKSwgQmw6IHU2NC5yb3RyQkwoQmgsIEJsLCA2MykgfSk7XG4gICAgKEJVRlsyICogYV0gPSBBbCksIChCVUZbMiAqIGEgKyAxXSA9IEFoKTtcbiAgICAoQlVGWzIgKiBiXSA9IEJsKSwgKEJVRlsyICogYiArIDFdID0gQmgpO1xuICAgIChCVUZbMiAqIGNdID0gQ2wpLCAoQlVGWzIgKiBjICsgMV0gPSBDaCk7XG4gICAgKEJVRlsyICogZF0gPSBEbCksIChCVUZbMiAqIGQgKyAxXSA9IERoKTtcbn1cbmNsYXNzIEJMQUtFMmIgZXh0ZW5kcyBCTEFLRTIge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgICAgICBzdXBlcigxMjgsIG9wdHMuZGtMZW4gPT09IHVuZGVmaW5lZCA/IDY0IDogb3B0cy5ka0xlbiwgb3B0cywgNjQsIDE2LCAxNik7XG4gICAgICAgIC8vIFNhbWUgYXMgU0hBLTUxMiwgYnV0IExFXG4gICAgICAgIHRoaXMudjBsID0gSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLnYwaCA9IElWWzFdIHwgMDtcbiAgICAgICAgdGhpcy52MWwgPSBJVlsyXSB8IDA7XG4gICAgICAgIHRoaXMudjFoID0gSVZbM10gfCAwO1xuICAgICAgICB0aGlzLnYybCA9IElWWzRdIHwgMDtcbiAgICAgICAgdGhpcy52MmggPSBJVls1XSB8IDA7XG4gICAgICAgIHRoaXMudjNsID0gSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLnYzaCA9IElWWzddIHwgMDtcbiAgICAgICAgdGhpcy52NGwgPSBJVls4XSB8IDA7XG4gICAgICAgIHRoaXMudjRoID0gSVZbOV0gfCAwO1xuICAgICAgICB0aGlzLnY1bCA9IElWWzEwXSB8IDA7XG4gICAgICAgIHRoaXMudjVoID0gSVZbMTFdIHwgMDtcbiAgICAgICAgdGhpcy52NmwgPSBJVlsxMl0gfCAwO1xuICAgICAgICB0aGlzLnY2aCA9IElWWzEzXSB8IDA7XG4gICAgICAgIHRoaXMudjdsID0gSVZbMTRdIHwgMDtcbiAgICAgICAgdGhpcy52N2ggPSBJVlsxNV0gfCAwO1xuICAgICAgICBjb25zdCBrZXlMZW5ndGggPSBvcHRzLmtleSA/IG9wdHMua2V5Lmxlbmd0aCA6IDA7XG4gICAgICAgIHRoaXMudjBsIF49IHRoaXMub3V0cHV0TGVuIHwgKGtleUxlbmd0aCA8PCA4KSB8ICgweDAxIDw8IDE2KSB8ICgweDAxIDw8IDI0KTtcbiAgICAgICAgaWYgKG9wdHMuc2FsdCkge1xuICAgICAgICAgICAgY29uc3Qgc2FsdCA9IHUzMih0b0J5dGVzKG9wdHMuc2FsdCkpO1xuICAgICAgICAgICAgdGhpcy52NGwgXj0gc2FsdFswXTtcbiAgICAgICAgICAgIHRoaXMudjRoIF49IHNhbHRbMV07XG4gICAgICAgICAgICB0aGlzLnY1bCBePSBzYWx0WzJdO1xuICAgICAgICAgICAgdGhpcy52NWggXj0gc2FsdFszXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5wZXJzb25hbGl6YXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHBlcnMgPSB1MzIodG9CeXRlcyhvcHRzLnBlcnNvbmFsaXphdGlvbikpO1xuICAgICAgICAgICAgdGhpcy52NmwgXj0gcGVyc1swXTtcbiAgICAgICAgICAgIHRoaXMudjZoIF49IHBlcnNbMV07XG4gICAgICAgICAgICB0aGlzLnY3bCBePSBwZXJzWzJdO1xuICAgICAgICAgICAgdGhpcy52N2ggXj0gcGVyc1szXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5rZXkpIHtcbiAgICAgICAgICAgIC8vIFBhZCB0byBibG9ja0xlbiBhbmQgdXBkYXRlXG4gICAgICAgICAgICBjb25zdCB0bXAgPSBuZXcgVWludDhBcnJheSh0aGlzLmJsb2NrTGVuKTtcbiAgICAgICAgICAgIHRtcC5zZXQodG9CeXRlcyhvcHRzLmtleSkpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUodG1wKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBnZXQoKSB7XG4gICAgICAgIGxldCB7IHYwbCwgdjBoLCB2MWwsIHYxaCwgdjJsLCB2MmgsIHYzbCwgdjNoLCB2NGwsIHY0aCwgdjVsLCB2NWgsIHY2bCwgdjZoLCB2N2wsIHY3aCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFt2MGwsIHYwaCwgdjFsLCB2MWgsIHYybCwgdjJoLCB2M2wsIHYzaCwgdjRsLCB2NGgsIHY1bCwgdjVoLCB2NmwsIHY2aCwgdjdsLCB2N2hdO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQodjBsLCB2MGgsIHYxbCwgdjFoLCB2MmwsIHYyaCwgdjNsLCB2M2gsIHY0bCwgdjRoLCB2NWwsIHY1aCwgdjZsLCB2NmgsIHY3bCwgdjdoKSB7XG4gICAgICAgIHRoaXMudjBsID0gdjBsIHwgMDtcbiAgICAgICAgdGhpcy52MGggPSB2MGggfCAwO1xuICAgICAgICB0aGlzLnYxbCA9IHYxbCB8IDA7XG4gICAgICAgIHRoaXMudjFoID0gdjFoIHwgMDtcbiAgICAgICAgdGhpcy52MmwgPSB2MmwgfCAwO1xuICAgICAgICB0aGlzLnYyaCA9IHYyaCB8IDA7XG4gICAgICAgIHRoaXMudjNsID0gdjNsIHwgMDtcbiAgICAgICAgdGhpcy52M2ggPSB2M2ggfCAwO1xuICAgICAgICB0aGlzLnY0bCA9IHY0bCB8IDA7XG4gICAgICAgIHRoaXMudjRoID0gdjRoIHwgMDtcbiAgICAgICAgdGhpcy52NWwgPSB2NWwgfCAwO1xuICAgICAgICB0aGlzLnY1aCA9IHY1aCB8IDA7XG4gICAgICAgIHRoaXMudjZsID0gdjZsIHwgMDtcbiAgICAgICAgdGhpcy52NmggPSB2NmggfCAwO1xuICAgICAgICB0aGlzLnY3bCA9IHY3bCB8IDA7XG4gICAgICAgIHRoaXMudjdoID0gdjdoIHwgMDtcbiAgICB9XG4gICAgY29tcHJlc3MobXNnLCBvZmZzZXQsIGlzTGFzdCkge1xuICAgICAgICB0aGlzLmdldCgpLmZvckVhY2goKHYsIGkpID0+IChCVUZbaV0gPSB2KSk7IC8vIEZpcnN0IGhhbGYgZnJvbSBzdGF0ZS5cbiAgICAgICAgQlVGLnNldChJViwgMTYpOyAvLyBTZWNvbmQgaGFsZiBmcm9tIElWLlxuICAgICAgICBsZXQgeyBoLCBsIH0gPSB1NjQuZnJvbUJpZyhCaWdJbnQodGhpcy5sZW5ndGgpKTtcbiAgICAgICAgQlVGWzI0XSA9IElWWzhdIF4gbDsgLy8gTG93IHdvcmQgb2YgdGhlIG9mZnNldC5cbiAgICAgICAgQlVGWzI1XSA9IElWWzldIF4gaDsgLy8gSGlnaCB3b3JkLlxuICAgICAgICAvLyBJbnZlcnQgYWxsIGJpdHMgZm9yIGxhc3QgYmxvY2tcbiAgICAgICAgaWYgKGlzTGFzdCkge1xuICAgICAgICAgICAgQlVGWzI4XSA9IH5CVUZbMjhdO1xuICAgICAgICAgICAgQlVGWzI5XSA9IH5CVUZbMjldO1xuICAgICAgICB9XG4gICAgICAgIGxldCBqID0gMDtcbiAgICAgICAgY29uc3QgcyA9IFNJR01BO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIEcxKDAsIDQsIDgsIDEyLCBtc2csIG9mZnNldCArIDIgKiBzW2orK10pO1xuICAgICAgICAgICAgRzIoMCwgNCwgOCwgMTIsIG1zZywgb2Zmc2V0ICsgMiAqIHNbaisrXSk7XG4gICAgICAgICAgICBHMSgxLCA1LCA5LCAxMywgbXNnLCBvZmZzZXQgKyAyICogc1tqKytdKTtcbiAgICAgICAgICAgIEcyKDEsIDUsIDksIDEzLCBtc2csIG9mZnNldCArIDIgKiBzW2orK10pO1xuICAgICAgICAgICAgRzEoMiwgNiwgMTAsIDE0LCBtc2csIG9mZnNldCArIDIgKiBzW2orK10pO1xuICAgICAgICAgICAgRzIoMiwgNiwgMTAsIDE0LCBtc2csIG9mZnNldCArIDIgKiBzW2orK10pO1xuICAgICAgICAgICAgRzEoMywgNywgMTEsIDE1LCBtc2csIG9mZnNldCArIDIgKiBzW2orK10pO1xuICAgICAgICAgICAgRzIoMywgNywgMTEsIDE1LCBtc2csIG9mZnNldCArIDIgKiBzW2orK10pO1xuICAgICAgICAgICAgRzEoMCwgNSwgMTAsIDE1LCBtc2csIG9mZnNldCArIDIgKiBzW2orK10pO1xuICAgICAgICAgICAgRzIoMCwgNSwgMTAsIDE1LCBtc2csIG9mZnNldCArIDIgKiBzW2orK10pO1xuICAgICAgICAgICAgRzEoMSwgNiwgMTEsIDEyLCBtc2csIG9mZnNldCArIDIgKiBzW2orK10pO1xuICAgICAgICAgICAgRzIoMSwgNiwgMTEsIDEyLCBtc2csIG9mZnNldCArIDIgKiBzW2orK10pO1xuICAgICAgICAgICAgRzEoMiwgNywgOCwgMTMsIG1zZywgb2Zmc2V0ICsgMiAqIHNbaisrXSk7XG4gICAgICAgICAgICBHMigyLCA3LCA4LCAxMywgbXNnLCBvZmZzZXQgKyAyICogc1tqKytdKTtcbiAgICAgICAgICAgIEcxKDMsIDQsIDksIDE0LCBtc2csIG9mZnNldCArIDIgKiBzW2orK10pO1xuICAgICAgICAgICAgRzIoMywgNCwgOSwgMTQsIG1zZywgb2Zmc2V0ICsgMiAqIHNbaisrXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52MGwgXj0gQlVGWzBdIF4gQlVGWzE2XTtcbiAgICAgICAgdGhpcy52MGggXj0gQlVGWzFdIF4gQlVGWzE3XTtcbiAgICAgICAgdGhpcy52MWwgXj0gQlVGWzJdIF4gQlVGWzE4XTtcbiAgICAgICAgdGhpcy52MWggXj0gQlVGWzNdIF4gQlVGWzE5XTtcbiAgICAgICAgdGhpcy52MmwgXj0gQlVGWzRdIF4gQlVGWzIwXTtcbiAgICAgICAgdGhpcy52MmggXj0gQlVGWzVdIF4gQlVGWzIxXTtcbiAgICAgICAgdGhpcy52M2wgXj0gQlVGWzZdIF4gQlVGWzIyXTtcbiAgICAgICAgdGhpcy52M2ggXj0gQlVGWzddIF4gQlVGWzIzXTtcbiAgICAgICAgdGhpcy52NGwgXj0gQlVGWzhdIF4gQlVGWzI0XTtcbiAgICAgICAgdGhpcy52NGggXj0gQlVGWzldIF4gQlVGWzI1XTtcbiAgICAgICAgdGhpcy52NWwgXj0gQlVGWzEwXSBeIEJVRlsyNl07XG4gICAgICAgIHRoaXMudjVoIF49IEJVRlsxMV0gXiBCVUZbMjddO1xuICAgICAgICB0aGlzLnY2bCBePSBCVUZbMTJdIF4gQlVGWzI4XTtcbiAgICAgICAgdGhpcy52NmggXj0gQlVGWzEzXSBeIEJVRlsyOV07XG4gICAgICAgIHRoaXMudjdsIF49IEJVRlsxNF0gXiBCVUZbMzBdO1xuICAgICAgICB0aGlzLnY3aCBePSBCVUZbMTVdIF4gQlVGWzMxXTtcbiAgICAgICAgQlVGLmZpbGwoMCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5idWZmZXIzMi5maWxsKDApO1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICB9XG59XG4vKipcbiAqIEJMQUtFMmIgLSBvcHRpbWl6ZWQgZm9yIDY0LWJpdCBwbGF0Zm9ybXMuIEpTIGRvZXNuJ3QgaGF2ZSB1aW50NjQsIHNvIGl0J3Mgc2xvd2VyIHRoYW4gQkxBS0Uycy5cbiAqIEBwYXJhbSBtc2cgLSBtZXNzYWdlIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKiBAcGFyYW0gb3B0cyAtIGRrTGVuLCBrZXksIHNhbHQsIHBlcnNvbmFsaXphdGlvblxuICovXG5leHBvcnQgY29uc3QgYmxha2UyYiA9IHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzKChvcHRzKSA9PiBuZXcgQkxBS0UyYihvcHRzKSk7XG4iLCJleHBvcnQgY29uc3QgY3J5cHRvID0ge1xuICAgIG5vZGU6IHVuZGVmaW5lZCxcbiAgICB3ZWI6IHR5cGVvZiBzZWxmID09PSAnb2JqZWN0JyAmJiAnY3J5cHRvJyBpbiBzZWxmID8gc2VsZi5jcnlwdG8gOiB1bmRlZmluZWQsXG59O1xuIiwiLyohIG5vYmxlLWhhc2hlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gVGhlIGltcG9ydCBoZXJlIGlzIHZpYSB0aGUgcGFja2FnZSBuYW1lLiBUaGlzIGlzIHRvIGVuc3VyZVxuLy8gdGhhdCBleHBvcnRzIG1hcHBpbmcvcmVzb2x1dGlvbiBkb2VzIGZhbGwgaW50byBwbGFjZS5cbmltcG9ydCB7IGNyeXB0byB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvY3J5cHRvJztcbi8vIENhc3QgYXJyYXkgdG8gZGlmZmVyZW50IHR5cGVcbmV4cG9ydCBjb25zdCB1OCA9IChhcnIpID0+IG5ldyBVaW50OEFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG5leHBvcnQgY29uc3QgdTMyID0gKGFycikgPT4gbmV3IFVpbnQzMkFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBNYXRoLmZsb29yKGFyci5ieXRlTGVuZ3RoIC8gNCkpO1xuLy8gQ2FzdCBhcnJheSB0byB2aWV3XG5leHBvcnQgY29uc3QgY3JlYXRlVmlldyA9IChhcnIpID0+IG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuLy8gVGhlIHJvdGF0ZSByaWdodCAoY2lyY3VsYXIgcmlnaHQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyXG5leHBvcnQgY29uc3Qgcm90ciA9ICh3b3JkLCBzaGlmdCkgPT4gKHdvcmQgPDwgKDMyIC0gc2hpZnQpKSB8ICh3b3JkID4+PiBzaGlmdCk7XG5leHBvcnQgY29uc3QgaXNMRSA9IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbMHgxMTIyMzM0NF0pLmJ1ZmZlcilbMF0gPT09IDB4NDQ7XG4vLyBUaGVyZSBpcyBhbG1vc3Qgbm8gYmlnIGVuZGlhbiBoYXJkd2FyZSwgYnV0IGpzIHR5cGVkIGFycmF5cyB1c2VzIHBsYXRmb3JtIHNwZWNpZmljIGVuZGlhbm5lc3MuXG4vLyBTbywganVzdCB0byBiZSBzdXJlIG5vdCB0byBjb3JydXB0IGFueXRoaW5nLlxuaWYgKCFpc0xFKVxuICAgIHRocm93IG5ldyBFcnJvcignTm9uIGxpdHRsZS1lbmRpYW4gaGFyZHdhcmUgaXMgbm90IHN1cHBvcnRlZCcpO1xuY29uc3QgaGV4ZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKHYsIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhkZSwgMHhhZCwgMHhiZSwgMHhlZl0pKVxuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleCh1aW50OGEpIHtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBpZiAoISh1aW50OGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdWludDhhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1t1aW50OGFbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdkZWFkYmVlZicpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdoZXhUb0J5dGVzOiBleHBlY3RlZCBzdHJpbmcsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgfVxuICAgIGlmIChoZXgubGVuZ3RoICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXhUb0J5dGVzOiByZWNlaXZlZCBpbnZhbGlkIHVucGFkZGVkIGhleCcpO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoaGV4Lmxlbmd0aCAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaiA9IGkgKiAyO1xuICAgICAgICBjb25zdCBoZXhCeXRlID0gaGV4LnNsaWNlKGosIGogKyAyKTtcbiAgICAgICAgY29uc3QgYnl0ZSA9IE51bWJlci5wYXJzZUludChoZXhCeXRlLCAxNik7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oYnl0ZSkgfHwgYnl0ZSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZSBzZXF1ZW5jZScpO1xuICAgICAgICBhcnJheVtpXSA9IGJ5dGU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8vIFRoZXJlIGlzIG5vIHNldEltbWVkaWF0ZSBpbiBicm93c2VyIGFuZCBzZXRUaW1lb3V0IGlzIHNsb3cuIEhvd2V2ZXIsIGNhbGwgdG8gYXN5bmMgZnVuY3Rpb24gd2lsbCByZXR1cm4gUHJvbWlzZVxuLy8gd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvbiBuZXh0IHNjaGVkdWxlciBxdWV1ZSBwcm9jZXNzaW5nIHN0ZXAgYW5kIHRoaXMgaXMgZXhhY3RseSB3aGF0IHdlIG5lZWQuXG5leHBvcnQgY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7IH07XG4vLyBSZXR1cm5zIGNvbnRyb2wgdG8gdGhyZWFkIGVhY2ggJ3RpY2snIG1zIHRvIGF2b2lkIGJsb2NraW5nXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXN5bmNMb29wKGl0ZXJzLCB0aWNrLCBjYikge1xuICAgIGxldCB0cyA9IERhdGUubm93KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyczsgaSsrKSB7XG4gICAgICAgIGNiKGkpO1xuICAgICAgICAvLyBEYXRlLm5vdygpIGlzIG5vdCBtb25vdG9uaWMsIHNvIGluIGNhc2UgaWYgY2xvY2sgZ29lcyBiYWNrd2FyZHMgd2UgcmV0dXJuIHJldHVybiBjb250cm9sIHRvb1xuICAgICAgICBjb25zdCBkaWZmID0gRGF0ZS5ub3coKSAtIHRzO1xuICAgICAgICBpZiAoZGlmZiA+PSAwICYmIGRpZmYgPCB0aWNrKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGF3YWl0IG5leHRUaWNrKCk7XG4gICAgICAgIHRzICs9IGRpZmY7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBpbnB1dCB0eXBlIGlzIFVpbnQ4QXJyYXkgKGdvdCAke3R5cGVvZiBkYXRhfSlgKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKlxuICogQ29uY2F0cyBVaW50OEFycmF5LXMgaW50byBvbmU7IGxpa2UgYEJ1ZmZlci5jb25jYXQoW2J1ZjEsIGJ1ZjJdKWBcbiAqIEBleGFtcGxlIGNvbmNhdEJ5dGVzKGJ1ZjEsIGJ1ZjIpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBpZiAoIWFycmF5cy5ldmVyeSgoYSkgPT4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgbGlzdCBleHBlY3RlZCcpO1xuICAgIGlmIChhcnJheXMubGVuZ3RoID09PSAxKVxuICAgICAgICByZXR1cm4gYXJyYXlzWzBdO1xuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5cy5yZWR1Y2UoKGEsIGFycikgPT4gYSArIGFyci5sZW5ndGgsIDApO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIHBhZCA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYXJyID0gYXJyYXlzW2ldO1xuICAgICAgICByZXN1bHQuc2V0KGFyciwgcGFkKTtcbiAgICAgICAgcGFkICs9IGFyci5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZVxuZXhwb3J0IGNsYXNzIEhhc2gge1xuICAgIC8vIFNhZmUgdmVyc2lvbiB0aGF0IGNsb25lcyBpbnRlcm5hbCBzdGF0ZVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxufVxuLy8gQ2hlY2sgaWYgb2JqZWN0IGRvZW5zJ3QgaGF2ZSBjdXN0b20gY29uc3RydWN0b3IgKGxpa2UgVWludDhBcnJheS9BcnJheSlcbmNvbnN0IGlzUGxhaW5PYmplY3QgPSAob2JqKSA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tPcHRzKGRlZmF1bHRzLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCAmJiAodHlwZW9mIG9wdHMgIT09ICdvYmplY3QnIHx8ICFpc1BsYWluT2JqZWN0KG9wdHMpKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT3B0aW9ucyBzaG91bGQgYmUgb2JqZWN0IG9yIHVuZGVmaW5lZCcpO1xuICAgIGNvbnN0IG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdHMsIG9wdHMpO1xuICAgIHJldHVybiBtZXJnZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yKGhhc2hDb25zdHJ1Y3Rvcikge1xuICAgIGNvbnN0IGhhc2hDID0gKG1lc3NhZ2UpID0+IGhhc2hDb25zdHJ1Y3RvcigpLnVwZGF0ZSh0b0J5dGVzKG1lc3NhZ2UpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29uc3RydWN0b3IoKTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9ICgpID0+IGhhc2hDb25zdHJ1Y3RvcigpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbi8qKlxuICogU2VjdXJlIFBSTkdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoID0gMzIpIHtcbiAgICBpZiAoY3J5cHRvLndlYikge1xuICAgICAgICByZXR1cm4gY3J5cHRvLndlYi5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY3J5cHRvLm5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGNyeXB0by5ub2RlLnJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoKS5idWZmZXIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGVudmlyb25tZW50IGRvZXNuJ3QgaGF2ZSByYW5kb21CeXRlcyBmdW5jdGlvblwiKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBEZW5vIH0gZnJvbSBcIkBkZW5vL3NoaW0tZGVuby10ZXN0XCI7XG5leHBvcnQgeyBEZW5vIH0gZnJvbSBcIkBkZW5vL3NoaW0tZGVuby10ZXN0XCI7XG5jb25zdCBkbnRHbG9iYWxzID0ge1xuICAgIERlbm8sXG59O1xuZXhwb3J0IGNvbnN0IGRudEdsb2JhbFRoaXMgPSBjcmVhdGVNZXJnZVByb3h5KGdsb2JhbFRoaXMsIGRudEdsb2JhbHMpO1xuLy8gZGVuby1saW50LWlnbm9yZSBiYW4tdHlwZXNcbmZ1bmN0aW9uIGNyZWF0ZU1lcmdlUHJveHkoYmFzZU9iaiwgZXh0T2JqKSB7XG4gICAgcmV0dXJuIG5ldyBQcm94eShiYXNlT2JqLCB7XG4gICAgICAgIGdldChfdGFyZ2V0LCBwcm9wLCBfcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIGlmIChwcm9wIGluIGV4dE9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBleHRPYmpbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZU9ialtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0KF90YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAocHJvcCBpbiBleHRPYmopIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZXh0T2JqW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmFzZU9ialtwcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIGRlbGV0ZVByb3BlcnR5KF90YXJnZXQsIHByb3ApIHtcbiAgICAgICAgICAgIGxldCBzdWNjZXNzID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAocHJvcCBpbiBleHRPYmopIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZXh0T2JqW3Byb3BdO1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3AgaW4gYmFzZU9iaikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBiYXNlT2JqW3Byb3BdO1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgICAgIH0sXG4gICAgICAgIG93bktleXMoX3RhcmdldCkge1xuICAgICAgICAgICAgY29uc3QgYmFzZUtleXMgPSBSZWZsZWN0Lm93bktleXMoYmFzZU9iaik7XG4gICAgICAgICAgICBjb25zdCBleHRLZXlzID0gUmVmbGVjdC5vd25LZXlzKGV4dE9iaik7XG4gICAgICAgICAgICBjb25zdCBleHRLZXlzU2V0ID0gbmV3IFNldChleHRLZXlzKTtcbiAgICAgICAgICAgIHJldHVybiBbLi4uYmFzZUtleXMuZmlsdGVyKChrKSA9PiAhZXh0S2V5c1NldC5oYXMoaykpLCAuLi5leHRLZXlzXTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVmaW5lUHJvcGVydHkoX3RhcmdldCwgcHJvcCwgZGVzYykge1xuICAgICAgICAgICAgaWYgKHByb3AgaW4gZXh0T2JqKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGV4dE9ialtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkoYmFzZU9iaiwgcHJvcCwgZGVzYyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKF90YXJnZXQsIHByb3ApIHtcbiAgICAgICAgICAgIGlmIChwcm9wIGluIGV4dE9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihleHRPYmosIHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2VPYmosIHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBoYXMoX3RhcmdldCwgcHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb3AgaW4gZXh0T2JqIHx8IHByb3AgaW4gYmFzZU9iajtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9kbnQuc2hpbXMuanMubWFwIiwidmFyIF9Db25maWdfZGlzY292ZXJ5VmFsdWU7XG5pbXBvcnQgeyBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0LCBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0IH0gZnJvbSBcInRzbGliXCI7XG5leHBvcnQgY2xhc3MgQ29uZmlnIHtcbiAgICBjb25zdHJ1Y3Rvcihpbml0RGlzY292ZXJ5VmFsdWUsIGFkZHJlc3NQcmVmaXgpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5pdERpc2NvdmVyeVZhbHVlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBpbml0RGlzY292ZXJ5VmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFkZHJlc3NQcmVmaXhcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGFkZHJlc3NQcmVmaXhcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRPRE86IGdldCByaWQgb2YgdGhpcyBndW5rXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIlJwY01ldGhvZHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiUnBjQ2FsbE1ldGhvZHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiUnBjU3Vic2NyaXB0aW9uTWV0aG9kc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJScGNFcnJvckRldGFpbHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgX0NvbmZpZ19kaXNjb3ZlcnlWYWx1ZS5zZXQodGhpcywgdm9pZCAwKTtcbiAgICB9XG4gICAgZ2V0IGRpc2NvdmVyeVZhbHVlKCkge1xuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZpZ19kaXNjb3ZlcnlWYWx1ZSwgXCJmXCIpKSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Db25maWdfZGlzY292ZXJ5VmFsdWUsIHRoaXMuaW5pdERpc2NvdmVyeVZhbHVlKCksIFwiZlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZmlnX2Rpc2NvdmVyeVZhbHVlLCBcImZcIik7XG4gICAgfVxufVxuX0NvbmZpZ19kaXNjb3ZlcnlWYWx1ZSA9IG5ldyBXZWFrTWFwKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2QuanMubWFwIiwiZXhwb3J0IHsgYmxha2UyYiB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL2JsYWtlMmJcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJsYWtlMmIuanMubWFwIiwiZXhwb3J0ICogZnJvbSBcInBhcml0eS1zY2FsZS1jb2RlY1wiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NhbGUuanMubWFwIiwiZXhwb3J0ICogZnJvbSBcIi4uLy4uL2RlcHNfMi9kZW5vLmxhbmQvc3RkQDAuMTI3LjAvYXN5bmMvbW9kLmpzXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3luYy5qcy5tYXAiLCJleHBvcnQgKiBmcm9tIFwiLi4vLi4vLi4vZGVwc18yL2Rlbm8ubGFuZC9zdGRAMC4xNTQuMC9lbmNvZGluZy9iYXNlNTguanNcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2U1OC5qcy5tYXAiLCJleHBvcnQgKiBmcm9tIFwiLi4vLi4vLi4vZGVwc18yL2Rlbm8ubGFuZC9zdGRAMC4xMjcuMC9lbmNvZGluZy9oZXguanNcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhleC5qcy5tYXAiLCJleHBvcnQgKiBmcm9tIFwiLi4vLi4vLi4vZGVwc18yL2Rlbm8ubGFuZC9zdGRAMC4xNTguMC90ZXN0aW5nL2Fzc2VydHMuanNcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzc2VydHMuanMubWFwIiwiLy8gQ29weXJpZ2h0IDIwMTgtMjAyMiB0aGUgRGVubyBhdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBNSVQgbGljZW5zZS5cbmltcG9ydCB7IGRlZmVycmVkIH0gZnJvbSBcIi4vZGVmZXJyZWQuanNcIjtcbmV4cG9ydCBjbGFzcyBEZWFkbGluZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcIkRlYWRsaW5lXCIpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkRlYWRsaW5lRXJyb3JcIjtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZSBhIHByb21pc2Ugd2hpY2ggd2lsbCBiZSByZWplY3RlZCB3aXRoIERlYWRsaW5lRXJyb3Igd2hlbiBhIGdpdmVuIGRlbGF5IGlzIGV4Y2VlZGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVhZGxpbmUocCwgZGVsYXkpIHtcbiAgICBjb25zdCBkID0gZGVmZXJyZWQoKTtcbiAgICBjb25zdCB0ID0gc2V0VGltZW91dCgoKSA9PiBkLnJlamVjdChuZXcgRGVhZGxpbmVFcnJvcigpKSwgZGVsYXkpO1xuICAgIHJldHVybiBQcm9taXNlLnJhY2UoW3AsIGRdKS5maW5hbGx5KCgpID0+IGNsZWFyVGltZW91dCh0KSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWFkbGluZS5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgMjAxOC0yMDIyIHRoZSBEZW5vIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIE1JVCBsaWNlbnNlLlxuLyoqXG4gKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIHRoZSBnaXZlbiBgZnVuY2BcbiAqIGJ5IGEgZ2l2ZW4gYHdhaXRgIHRpbWUgaW4gbWlsbGlzZWNvbmRzLiBJZiB0aGUgbWV0aG9kIGlzIGNhbGxlZFxuICogYWdhaW4gYmVmb3JlIHRoZSB0aW1lb3V0IGV4cGlyZXMsIHRoZSBwcmV2aW91cyBjYWxsIHdpbGwgYmVcbiAqIGFib3J0ZWQuXG4gKlxuICogYGBgXG4gKiBpbXBvcnQgeyBkZWJvdW5jZSB9IGZyb20gXCIuL2RlYm91bmNlLnRzXCI7XG4gKlxuICogY29uc3QgbG9nID0gZGVib3VuY2UoXG4gKiAgIChldmVudDogRGVuby5Gc0V2ZW50KSA9PlxuICogICAgIGNvbnNvbGUubG9nKFwiWyVzXSAlc1wiLCBldmVudC5raW5kLCBldmVudC5wYXRoc1swXSksXG4gKiAgIDIwMCxcbiAqICk7XG4gKlxuICogZm9yIGF3YWl0IChjb25zdCBldmVudCBvZiBEZW5vLndhdGNoRnMoXCIuL1wiKSkge1xuICogICBsb2coZXZlbnQpO1xuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIGZuICAgIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAqIEBwYXJhbSB3YWl0ICBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgdGhlIGZ1bmN0aW9uLlxuICovXG4vLyBkZW5vLWxpbnQtaWdub3JlIG5vLWV4cGxpY2l0LWFueVxuZXhwb3J0IGZ1bmN0aW9uIGRlYm91bmNlKGZuLCB3YWl0KSB7XG4gICAgbGV0IHRpbWVvdXQgPSBudWxsO1xuICAgIGxldCBmbHVzaCA9IG51bGw7XG4gICAgY29uc3QgZGVib3VuY2VkID0gKCguLi5hcmdzKSA9PiB7XG4gICAgICAgIGRlYm91bmNlZC5jbGVhcigpO1xuICAgICAgICBmbHVzaCA9ICgpID0+IHtcbiAgICAgICAgICAgIGRlYm91bmNlZC5jbGVhcigpO1xuICAgICAgICAgICAgZm4uY2FsbChkZWJvdW5jZWQsIC4uLmFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmbHVzaCwgd2FpdCk7XG4gICAgfSk7XG4gICAgZGVib3VuY2VkLmNsZWFyID0gKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHRpbWVvdXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgZmx1c2ggPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBkZWJvdW5jZWQuZmx1c2ggPSAoKSA9PiB7XG4gICAgICAgIGZsdXNoPy4oKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZWJvdW5jZWQsIFwicGVuZGluZ1wiLCB7XG4gICAgICAgIGdldDogKCkgPT4gdHlwZW9mIHRpbWVvdXQgPT09IFwibnVtYmVyXCIsXG4gICAgfSk7XG4gICAgcmV0dXJuIGRlYm91bmNlZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlYm91bmNlLmpzLm1hcCIsIi8qKiBDcmVhdGVzIGEgUHJvbWlzZSB3aXRoIHRoZSBgcmVqZWN0YCBhbmQgYHJlc29sdmVgIGZ1bmN0aW9uc1xuICogcGxhY2VkIGFzIG1ldGhvZHMgb24gdGhlIHByb21pc2Ugb2JqZWN0IGl0c2VsZi4gSXQgYWxsb3dzIHlvdSB0byBkbzpcbiAqXG4gKiBgYGB0c1xuICogICAgIGltcG9ydCB7IGRlZmVycmVkIH0gZnJvbSBcIi4vZGVmZXJyZWQudHNcIjtcbiAqXG4gKiAgICAgY29uc3QgcCA9IGRlZmVycmVkPG51bWJlcj4oKTtcbiAqICAgICAvLyAuLi5cbiAqICAgICBwLnJlc29sdmUoNDIpO1xuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZlcnJlZCgpIHtcbiAgICBsZXQgbWV0aG9kcztcbiAgICBsZXQgc3RhdGUgPSBcInBlbmRpbmdcIjtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBtZXRob2RzID0ge1xuICAgICAgICAgICAgYXN5bmMgcmVzb2x2ZSh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHZhbHVlO1xuICAgICAgICAgICAgICAgIHN0YXRlID0gXCJmdWxmaWxsZWRcIjtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBkZW5vLWxpbnQtaWdub3JlIG5vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgcmVqZWN0KHJlYXNvbikge1xuICAgICAgICAgICAgICAgIHN0YXRlID0gXCJyZWplY3RlZFwiO1xuICAgICAgICAgICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJzdGF0ZVwiLCB7IGdldDogKCkgPT4gc3RhdGUgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocHJvbWlzZSwgbWV0aG9kcyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZlcnJlZC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgMjAxOC0yMDIyIHRoZSBEZW5vIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIE1JVCBsaWNlbnNlLlxuLyogUmVzb2x2ZXMgYWZ0ZXIgdGhlIGdpdmVuIG51bWJlciBvZiBtaWxsaXNlY29uZHMuICovXG5leHBvcnQgZnVuY3Rpb24gZGVsYXkobXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2lnbmFsIH0gPSBvcHRpb25zO1xuICAgIGlmIChzaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBET01FeGNlcHRpb24oXCJEZWxheSB3YXMgYWJvcnRlZC5cIiwgXCJBYm9ydEVycm9yXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgYWJvcnQgPSAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoaSk7XG4gICAgICAgICAgICByZWplY3QobmV3IERPTUV4Y2VwdGlvbihcIkRlbGF5IHdhcyBhYm9ydGVkLlwiLCBcIkFib3J0RXJyb3JcIikpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBkb25lID0gKCkgPT4ge1xuICAgICAgICAgICAgc2lnbmFsPy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgYWJvcnQpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBpID0gc2V0VGltZW91dChkb25lLCBtcyk7XG4gICAgICAgIHNpZ25hbD8uYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0LCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWxheS5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgMjAxOC0yMDIyIHRoZSBEZW5vIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIE1JVCBsaWNlbnNlLlxuZXhwb3J0ICogZnJvbSBcIi4vZGVib3VuY2UuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2RlZmVycmVkLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9kZWxheS5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vbXV4X2FzeW5jX2l0ZXJhdG9yLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9wb29sLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi90ZWUuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2RlYWRsaW5lLmpzXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2QuanMubWFwIiwiLy8gQ29weXJpZ2h0IDIwMTgtMjAyMiB0aGUgRGVubyBhdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBNSVQgbGljZW5zZS5cbmltcG9ydCB7IGRlZmVycmVkIH0gZnJvbSBcIi4vZGVmZXJyZWQuanNcIjtcbi8qKiBUaGUgTXV4QXN5bmNJdGVyYXRvciBjbGFzcyBtdWx0aXBsZXhlcyBtdWx0aXBsZSBhc3luYyBpdGVyYXRvcnMgaW50byBhXG4gKiBzaW5nbGUgc3RyZWFtLiBJdCBjdXJyZW50bHkgbWFrZXMgYW4gYXNzdW1wdGlvbjpcbiAqIC0gVGhlIGZpbmFsIHJlc3VsdCAodGhlIHZhbHVlIHJldHVybmVkIGFuZCBub3QgeWllbGRlZCBmcm9tIHRoZSBpdGVyYXRvcilcbiAqICAgZG9lcyBub3QgbWF0dGVyOyBpZiB0aGVyZSBpcyBhbnksIGl0IGlzIGRpc2NhcmRlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIE11eEFzeW5jSXRlcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpdGVyYXRvckNvdW50XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ5aWVsZHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBkZW5vLWxpbnQtaWdub3JlIG5vLWV4cGxpY2l0LWFueVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0aHJvd3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzaWduYWxcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGRlZmVycmVkKClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFkZChpdGVyYWJsZSkge1xuICAgICAgICArK3RoaXMuaXRlcmF0b3JDb3VudDtcbiAgICAgICAgdGhpcy5jYWxsSXRlcmF0b3JOZXh0KGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpKTtcbiAgICB9XG4gICAgYXN5bmMgY2FsbEl0ZXJhdG9yTmV4dChpdGVyYXRvcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAtLXRoaXMuaXRlcmF0b3JDb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMueWllbGRzLnB1c2goeyBpdGVyYXRvciwgdmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dzLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaWduYWwucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBhc3luYyAqaXRlcmF0ZSgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuaXRlcmF0b3JDb3VudCA+IDApIHtcbiAgICAgICAgICAgIC8vIFNsZWVwIHVudGlsIGFueSBvZiB0aGUgd3JhcHBlZCBpdGVyYXRvcnMgeWllbGRzLlxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zaWduYWw7XG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgd2hpbGUgd2UncmUgbG9vcGluZyBvdmVyIGB5aWVsZHNgLCBuZXcgaXRlbXMgbWF5IGJlIGFkZGVkLlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnlpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaXRlcmF0b3IsIHZhbHVlIH0gPSB0aGlzLnlpZWxkc1tpXTtcbiAgICAgICAgICAgICAgICB5aWVsZCB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxJdGVyYXRvck5leHQoaXRlcmF0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudGhyb3dzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiB0aGlzLnRocm93cykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnRocm93cy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIGB5aWVsZHNgIGxpc3QgYW5kIHJlc2V0IHRoZSBgc2lnbmFsYCBwcm9taXNlLlxuICAgICAgICAgICAgdGhpcy55aWVsZHMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHRoaXMuc2lnbmFsID0gZGVmZXJyZWQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRlKCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXV4X2FzeW5jX2l0ZXJhdG9yLmpzLm1hcCIsIi8vIENvcHlyaWdodCAyMDE4LTIwMjIgdGhlIERlbm8gYXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gTUlUIGxpY2Vuc2UuXG4vKipcbiAqIHBvb2xlZE1hcCB0cmFuc2Zvcm1zIHZhbHVlcyBmcm9tIGFuIChhc3luYykgaXRlcmFibGUgaW50byBhbm90aGVyIGFzeW5jXG4gKiBpdGVyYWJsZS4gVGhlIHRyYW5zZm9ybXMgYXJlIGRvbmUgY29uY3VycmVudGx5LCB3aXRoIGEgbWF4IGNvbmN1cnJlbmN5XG4gKiBkZWZpbmVkIGJ5IHRoZSBwb29sTGltaXQuXG4gKlxuICogSWYgYW4gZXJyb3IgaXMgdGhyb3duIGZyb20gYGl0ZXJhYmxlRm5gLCBubyBuZXcgdHJhbnNmb3JtYXRpb25zIHdpbGwgYmVnaW4uXG4gKiBBbGwgY3VycmVudGx5IGV4ZWN1dGluZyB0cmFuc2Zvcm1hdGlvbnMgYXJlIGFsbG93ZWQgdG8gZmluaXNoIGFuZCBzdGlsbFxuICogeWllbGRlZCBvbiBzdWNjZXNzLiBBZnRlciB0aGF0LCB0aGUgcmVqZWN0aW9ucyBhbW9uZyB0aGVtIGFyZSBnYXRoZXJlZCBhbmRcbiAqIHRocm93biBieSB0aGUgaXRlcmF0b3IgaW4gYW4gYEFnZ3JlZ2F0ZUVycm9yYC5cbiAqXG4gKiBAcGFyYW0gcG9vbExpbWl0IFRoZSBtYXhpbXVtIGNvdW50IG9mIGl0ZW1zIGJlaW5nIHByb2Nlc3NlZCBjb25jdXJyZW50bHkuXG4gKiBAcGFyYW0gYXJyYXkgVGhlIGlucHV0IGFycmF5IGZvciBtYXBwaW5nLlxuICogQHBhcmFtIGl0ZXJhdG9yRm4gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGV2ZXJ5IGl0ZW0gb2YgdGhlIGFycmF5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcG9vbGVkTWFwKHBvb2xMaW1pdCwgYXJyYXksIGl0ZXJhdG9yRm4pIHtcbiAgICAvLyBDcmVhdGUgdGhlIGFzeW5jIGl0ZXJhYmxlIHRoYXQgaXMgcmV0dXJuZWQgZnJvbSB0aGlzIGZ1bmN0aW9uLlxuICAgIGNvbnN0IHJlcyA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICBhc3luYyB0cmFuc2Zvcm0ocCwgY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGF3YWl0IHApO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIC8vIFN0YXJ0IHByb2Nlc3NpbmcgaXRlbXMgZnJvbSB0aGUgaXRlcmF0b3JcbiAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCB3cml0ZXIgPSByZXMud3JpdGFibGUuZ2V0V3JpdGVyKCk7XG4gICAgICAgIGNvbnN0IGV4ZWN1dGluZyA9IFtdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBpdGVtIG9mIGFycmF5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gaXRlcmF0b3JGbihpdGVtKSk7XG4gICAgICAgICAgICAgICAgLy8gT25seSB3cml0ZSBvbiBzdWNjZXNzLiBJZiB3ZSBgd3JpdGVyLndyaXRlKClgIGEgcmVqZWN0ZWQgcHJvbWlzZSxcbiAgICAgICAgICAgICAgICAvLyB0aGF0IHdpbGwgZW5kIHRoZSBpdGVyYXRpb24uIFdlIGRvbid0IHdhbnQgdGhhdCB5ZXQuIEluc3RlYWQgbGV0IGl0XG4gICAgICAgICAgICAgICAgLy8gZmFpbCB0aGUgcmFjZSwgdGFraW5nIHVzIHRvIHRoZSBjYXRjaCBibG9jayB3aGVyZSBhbGwgY3VycmVudGx5XG4gICAgICAgICAgICAgICAgLy8gZXhlY3V0aW5nIGpvYnMgYXJlIGFsbG93ZWQgdG8gZmluaXNoIGFuZCBhbGwgcmVqZWN0aW9ucyBhbW9uZyB0aGVtXG4gICAgICAgICAgICAgICAgLy8gY2FuIGJlIHJlcG9ydGVkIHRvZ2V0aGVyLlxuICAgICAgICAgICAgICAgIHAudGhlbigodikgPT4gd3JpdGVyLndyaXRlKFByb21pc2UucmVzb2x2ZSh2KSkpLmNhdGNoKCgpID0+IHsgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZSA9IHAudGhlbigoKSA9PiBleGVjdXRpbmcuc3BsaWNlKGV4ZWN1dGluZy5pbmRleE9mKGUpLCAxKSk7XG4gICAgICAgICAgICAgICAgZXhlY3V0aW5nLnB1c2goZSk7XG4gICAgICAgICAgICAgICAgaWYgKGV4ZWN1dGluZy5sZW5ndGggPj0gcG9vbExpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UucmFjZShleGVjdXRpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdhaXQgdW50aWwgYWxsIG9uZ29pbmcgZXZlbnRzIGhhdmUgcHJvY2Vzc2VkLCB0aGVuIGNsb3NlIHRoZSB3cml0ZXIuXG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChleGVjdXRpbmcpO1xuICAgICAgICAgICAgd3JpdGVyLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoZXhlY3V0aW5nKSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09IFwicmVqZWN0ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChyZXN1bHQucmVhc29uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZXIud3JpdGUoUHJvbWlzZS5yZWplY3QobmV3IEFnZ3JlZ2F0ZUVycm9yKGVycm9ycywgXCJUaHJldyB3aGlsZSBtYXBwaW5nLlwiKSkpLmNhdGNoKCgpID0+IHsgfSk7XG4gICAgICAgIH1cbiAgICB9KSgpO1xuICAgIHJldHVybiByZXMucmVhZGFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb29sLmpzLm1hcCIsIi8vIENvcHlyaWdodCAyMDE4LTIwMjIgdGhlIERlbm8gYXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gTUlUIGxpY2Vuc2UuXG52YXIgX1F1ZXVlX3NvdXJjZSwgX1F1ZXVlX3F1ZXVlO1xuaW1wb3J0IHsgX19jbGFzc1ByaXZhdGVGaWVsZEdldCwgX19jbGFzc1ByaXZhdGVGaWVsZFNldCB9IGZyb20gXCJ0c2xpYlwiO1xuY2xhc3MgUXVldWUge1xuICAgIGNvbnN0cnVjdG9yKGl0ZXJhYmxlKSB7XG4gICAgICAgIF9RdWV1ZV9zb3VyY2Uuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9RdWV1ZV9xdWV1ZS5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaGVhZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkb25lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1F1ZXVlX3NvdXJjZSwgaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCksIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfUXVldWVfcXVldWUsIHtcbiAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBuZXh0OiB1bmRlZmluZWQsXG4gICAgICAgIH0sIFwiZlwiKTtcbiAgICAgICAgdGhpcy5oZWFkID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfUXVldWVfcXVldWUsIFwiZlwiKTtcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgfVxuICAgIGFzeW5jIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1F1ZXVlX3NvdXJjZSwgXCJmXCIpLm5leHQoKTtcbiAgICAgICAgaWYgKCFyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgY29uc3QgbmV4dE5vZGUgPSB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICBuZXh0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfUXVldWVfcXVldWUsIFwiZlwiKS5uZXh0ID0gbmV4dE5vZGU7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9RdWV1ZV9xdWV1ZSwgbmV4dE5vZGUsIFwiZlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5fUXVldWVfc291cmNlID0gbmV3IFdlYWtNYXAoKSwgX1F1ZXVlX3F1ZXVlID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogQnJhbmNoZXMgdGhlIGdpdmVuIGFzeW5jIGl0ZXJhYmxlIGludG8gdGhlIG4gYnJhbmNoZXMuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGB0c1xuICogICAgIGltcG9ydCB7IHRlZSB9IGZyb20gXCIuL3RlZS50c1wiO1xuICpcbiAqICAgICBjb25zdCBnZW4gPSBhc3luYyBmdW5jdGlvbiogZ2VuKCkge1xuICogICAgICAgeWllbGQgMTtcbiAqICAgICAgIHlpZWxkIDI7XG4gKiAgICAgICB5aWVsZCAzO1xuICogICAgIH1cbiAqXG4gKiAgICAgY29uc3QgW2JyYW5jaDEsIGJyYW5jaDJdID0gdGVlKGdlbigpKTtcbiAqXG4gKiAgICAgKGFzeW5jICgpID0+IHtcbiAqICAgICAgIGZvciBhd2FpdCAoY29uc3QgbiBvZiBicmFuY2gxKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKG4pOyAvLyA9PiAxLCAyLCAzXG4gKiAgICAgICB9XG4gKiAgICAgfSkoKTtcbiAqXG4gKiAgICAgKGFzeW5jICgpID0+IHtcbiAqICAgICAgIGZvciBhd2FpdCAoY29uc3QgbiBvZiBicmFuY2gyKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKG4pOyAvLyA9PiAxLCAyLCAzXG4gKiAgICAgICB9XG4gKiAgICAgfSkoKTtcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gdGVlKGl0ZXJhYmxlLCBuID0gMikge1xuICAgIGNvbnN0IHF1ZXVlID0gbmV3IFF1ZXVlKGl0ZXJhYmxlKTtcbiAgICBhc3luYyBmdW5jdGlvbiogZ2VuZXJhdG9yKCkge1xuICAgICAgICBsZXQgYnVmZmVyID0gcXVldWUuaGVhZDtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmIChidWZmZXIubmV4dCkge1xuICAgICAgICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5uZXh0O1xuICAgICAgICAgICAgICAgIHlpZWxkIGJ1ZmZlci52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHF1ZXVlLmRvbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBxdWV1ZS5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYnJhbmNoZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBuIH0pLm1hcCgoKSA9PiBnZW5lcmF0b3IoKSk7XG4gICAgcmV0dXJuIGJyYW5jaGVzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVlLmpzLm1hcCIsIi8vIFBvcnRlZCBmcm9tIEdvXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZ29sYW5nL2dvL2Jsb2IvZ28xLjEyLjUvc3JjL2VuY29kaW5nL2hleC9oZXguZ29cbi8vIENvcHlyaWdodCAyMDA5IFRoZSBHbyBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGVcbi8vIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZS5cbi8vIENvcHlyaWdodCAyMDE4LTIwMjIgdGhlIERlbm8gYXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gTUlUIGxpY2Vuc2UuXG5jb25zdCBoZXhUYWJsZSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShcIjAxMjM0NTY3ODlhYmNkZWZcIik7XG5mdW5jdGlvbiBlcnJJbnZhbGlkQnl0ZShieXRlKSB7XG4gICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYEludmFsaWQgYnl0ZSAnJHtTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGUpfSdgKTtcbn1cbmZ1bmN0aW9uIGVyckxlbmd0aCgpIHtcbiAgICByZXR1cm4gbmV3IFJhbmdlRXJyb3IoXCJPZGQgbGVuZ3RoIGhleCBzdHJpbmdcIik7XG59XG4vKiogQ29udmVydHMgYSBoZXggY2hhcmFjdGVyIGludG8gaXRzIHZhbHVlLiAqL1xuZnVuY3Rpb24gZnJvbUhleENoYXIoYnl0ZSkge1xuICAgIC8vICcwJyA8PSBieXRlICYmIGJ5dGUgPD0gJzknXG4gICAgaWYgKDQ4IDw9IGJ5dGUgJiYgYnl0ZSA8PSA1NylcbiAgICAgICAgcmV0dXJuIGJ5dGUgLSA0ODtcbiAgICAvLyAnYScgPD0gYnl0ZSAmJiBieXRlIDw9ICdmJ1xuICAgIGlmICg5NyA8PSBieXRlICYmIGJ5dGUgPD0gMTAyKVxuICAgICAgICByZXR1cm4gYnl0ZSAtIDk3ICsgMTA7XG4gICAgLy8gJ0EnIDw9IGJ5dGUgJiYgYnl0ZSA8PSAnRidcbiAgICBpZiAoNjUgPD0gYnl0ZSAmJiBieXRlIDw9IDcwKVxuICAgICAgICByZXR1cm4gYnl0ZSAtIDY1ICsgMTA7XG4gICAgdGhyb3cgZXJySW52YWxpZEJ5dGUoYnl0ZSk7XG59XG4vKiogRW5jb2RlcyBgc3JjYCBpbnRvIGBzcmMubGVuZ3RoICogMmAgYnl0ZXMuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlKHNyYykge1xuICAgIGNvbnN0IGRzdCA9IG5ldyBVaW50OEFycmF5KHNyYy5sZW5ndGggKiAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB2ID0gc3JjW2ldO1xuICAgICAgICBkc3RbaSAqIDJdID0gaGV4VGFibGVbdiA+PiA0XTtcbiAgICAgICAgZHN0W2kgKiAyICsgMV0gPSBoZXhUYWJsZVt2ICYgMHgwZl07XG4gICAgfVxuICAgIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIERlY29kZXMgYHNyY2AgaW50byBgc3JjLmxlbmd0aCAvIDJgIGJ5dGVzLlxuICogSWYgdGhlIGlucHV0IGlzIG1hbGZvcm1lZCwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGUoc3JjKSB7XG4gICAgY29uc3QgZHN0ID0gbmV3IFVpbnQ4QXJyYXkoc3JjLmxlbmd0aCAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBmcm9tSGV4Q2hhcihzcmNbaSAqIDJdKTtcbiAgICAgICAgY29uc3QgYiA9IGZyb21IZXhDaGFyKHNyY1tpICogMiArIDFdKTtcbiAgICAgICAgZHN0W2ldID0gKGEgPDwgNCkgfCBiO1xuICAgIH1cbiAgICBpZiAoc3JjLmxlbmd0aCAlIDIgPT0gMSkge1xuICAgICAgICAvLyBDaGVjayBmb3IgaW52YWxpZCBjaGFyIGJlZm9yZSByZXBvcnRpbmcgYmFkIGxlbmd0aCxcbiAgICAgICAgLy8gc2luY2UgdGhlIGludmFsaWQgY2hhciAoaWYgcHJlc2VudCkgaXMgYW4gZWFybGllciBwcm9ibGVtLlxuICAgICAgICBmcm9tSGV4Q2hhcihzcmNbZHN0Lmxlbmd0aCAqIDJdKTtcbiAgICAgICAgdGhyb3cgZXJyTGVuZ3RoKCk7XG4gICAgfVxuICAgIHJldHVybiBkc3Q7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZXguanMubWFwIiwiLy8gQ29weXJpZ2h0IDIwMTgtMjAyMiB0aGUgRGVubyBhdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBNSVQgbGljZW5zZS5cbi8vIGRlbm8tZm10LWlnbm9yZVxuY29uc3QgbWFwQmFzZTU4ID0ge1xuICAgIFwiMVwiOiAwLCBcIjJcIjogMSwgXCIzXCI6IDIsIFwiNFwiOiAzLCBcIjVcIjogNCwgXCI2XCI6IDUsIFwiN1wiOiA2LCBcIjhcIjogNywgXCI5XCI6IDgsIEE6IDksXG4gICAgQjogMTAsIEM6IDExLCBEOiAxMiwgRTogMTMsIEY6IDE0LCBHOiAxNSwgSDogMTYsIEo6IDE3LCBLOiAxOCwgTDogMTksIE06IDIwLFxuICAgIE46IDIxLCBQOiAyMiwgUTogMjMsIFI6IDI0LCBTOiAyNSwgVDogMjYsIFU6IDI3LCBWOiAyOCwgVzogMjksIFg6IDMwLCBZOiAzMSxcbiAgICBaOiAzMiwgYTogMzMsIGI6IDM0LCBjOiAzNSwgZDogMzYsIGU6IDM3LCBmOiAzOCwgZzogMzksIGg6IDQwLCBpOiA0MSwgajogNDIsXG4gICAgazogNDMsIG06IDQ0LCBuOiA0NSwgbzogNDYsIHA6IDQ3LCBxOiA0OCwgcjogNDksIHM6IDUwLCB0OiA1MSwgdTogNTIsIHY6IDUzLFxuICAgIHc6IDU0LCB4OiA1NSwgeTogNTYsIHo6IDU3XG59O1xuY29uc3QgYmFzZTU4YWxwaGFiZXQgPSBcIjEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpcIi5zcGxpdChcIlwiKTtcbi8qKlxuICogRW5jb2RlcyBhIGdpdmVuIFVpbnQ4QXJyYXksIEFycmF5QnVmZmVyIG9yIHN0cmluZyBpbnRvIGRyYWZ0LW1zcG90bnktYmFzZTU4LTAzIFJGQyBiYXNlNTggcmVwcmVzZW50YXRpb246XG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2lkL2RyYWZ0LW1zcG9ybnktYmFzZTU4LTAxLmh0bWwjcmZjLnNlY3Rpb24uMVxuICpcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXIgfCBzdHJpbmd9IGRhdGFcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBFbmNvZGVkIHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGUoZGF0YSkge1xuICAgIGNvbnN0IHVpbnQ4dERhdGEgPSB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIlxuICAgICAgICA/IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShkYXRhKVxuICAgICAgICA6IGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5XG4gICAgICAgICAgICA/IGRhdGFcbiAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gICAgbGV0IGxlbmd0aCA9IDA7XG4gICAgbGV0IHplcm9lcyA9IDA7XG4gICAgLy8gQ291bnRpbmcgbGVhZGluZyB6ZXJvZXNcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIHdoaWxlICh1aW50OHREYXRhW2luZGV4XSA9PT0gMCkge1xuICAgICAgICB6ZXJvZXMrKztcbiAgICAgICAgaW5kZXgrKztcbiAgICB9XG4gICAgY29uc3Qgbm90WmVyb1VpbnQ4RGF0YSA9IHVpbnQ4dERhdGEuc2xpY2UoaW5kZXgpO1xuICAgIGNvbnN0IHNpemUgPSBNYXRoLnJvdW5kKCh1aW50OHREYXRhLmxlbmd0aCAqIDEzOCkgLyAxMDAgKyAxKTtcbiAgICBjb25zdCBiNThFbmNvZGluZyA9IFtdO1xuICAgIG5vdFplcm9VaW50OERhdGEuZm9yRWFjaCgoYnl0ZSkgPT4ge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGxldCBjYXJyeSA9IGJ5dGU7XG4gICAgICAgIGZvciAobGV0IHJldmVyc2VfaXRlcmF0b3IgPSBzaXplIC0gMTsgKGNhcnJ5ID4gMCB8fCBpIDwgbGVuZ3RoKSAmJiByZXZlcnNlX2l0ZXJhdG9yICE9PSAtMTsgcmV2ZXJzZV9pdGVyYXRvci0tLCBpKyspIHtcbiAgICAgICAgICAgIGNhcnJ5ICs9IChiNThFbmNvZGluZ1tyZXZlcnNlX2l0ZXJhdG9yXSB8fCAwKSAqIDI1NjtcbiAgICAgICAgICAgIGI1OEVuY29kaW5nW3JldmVyc2VfaXRlcmF0b3JdID0gTWF0aC5yb3VuZChjYXJyeSAlIDU4KTtcbiAgICAgICAgICAgIGNhcnJ5ID0gTWF0aC5mbG9vcihjYXJyeSAvIDU4KTtcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggPSBpO1xuICAgIH0pO1xuICAgIGNvbnN0IHN0clJlc3VsdCA9IEFycmF5LmZyb20oe1xuICAgICAgICBsZW5ndGg6IGI1OEVuY29kaW5nLmxlbmd0aCArIHplcm9lcyxcbiAgICB9KTtcbiAgICBpZiAoemVyb2VzID4gMCkge1xuICAgICAgICBzdHJSZXN1bHQuZmlsbChcIjFcIiwgMCwgemVyb2VzKTtcbiAgICB9XG4gICAgYjU4RW5jb2RpbmcuZm9yRWFjaCgoYnl0ZVZhbHVlKSA9PiBzdHJSZXN1bHQucHVzaChiYXNlNThhbHBoYWJldFtieXRlVmFsdWVdKSk7XG4gICAgcmV0dXJuIHN0clJlc3VsdC5qb2luKFwiXCIpO1xufVxuLyoqXG4gKiBEZWNvZGVzIGEgZ2l2ZW4gYjU4IHN0cmluZyBhY2NvcmRpbmcgdG8gZHJhZnQtbXNwb3RueS1iYXNlNTgtMDMgUkZDIGJhc2U1OCByZXByZXNlbnRhdGlvbjpcbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaWQvZHJhZnQtbXNwb3JueS1iYXNlNTgtMDEuaHRtbCNyZmMuc2VjdGlvbi4xXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGI1OFxuICpcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBEZWNvZGVkIHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGUoYjU4KSB7XG4gICAgY29uc3Qgc3BsaXR0ZWRJbnB1dCA9IGI1OC50cmltKCkuc3BsaXQoXCJcIik7XG4gICAgbGV0IGxlbmd0aCA9IDA7XG4gICAgbGV0IG9uZXMgPSAwO1xuICAgIC8vIENvdW50aW5nIGxlYWRpbmcgb25lc1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgd2hpbGUgKHNwbGl0dGVkSW5wdXRbaW5kZXhdID09PSBcIjFcIikge1xuICAgICAgICBvbmVzKys7XG4gICAgICAgIGluZGV4Kys7XG4gICAgfVxuICAgIGNvbnN0IG5vdFplcm9EYXRhID0gc3BsaXR0ZWRJbnB1dC5zbGljZShpbmRleCk7XG4gICAgY29uc3Qgc2l6ZSA9IE1hdGgucm91bmQoKGI1OC5sZW5ndGggKiA3MzMpIC8gMTAwMCArIDEpO1xuICAgIGNvbnN0IG91dHB1dCA9IFtdO1xuICAgIG5vdFplcm9EYXRhLmZvckVhY2goKGNoYXIsIGlkeCkgPT4ge1xuICAgICAgICBsZXQgY2FycnkgPSBtYXBCYXNlNThbY2hhcl07XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgaWYgKGNhcnJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBiYXNlNTggY2hhciBhdCBpbmRleCAke2lkeH0gd2l0aCB2YWx1ZSAke2NoYXJ9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgcmV2ZXJzZV9pdGVyYXRvciA9IHNpemUgLSAxOyAoY2FycnkgPiAwIHx8IGkgPCBsZW5ndGgpICYmIHJldmVyc2VfaXRlcmF0b3IgIT09IDA7IC0tcmV2ZXJzZV9pdGVyYXRvciwgKytpKSB7XG4gICAgICAgICAgICBjYXJyeSArPSA1OCAqIChvdXRwdXRbcmV2ZXJzZV9pdGVyYXRvciAtIDFdIHx8IDApO1xuICAgICAgICAgICAgb3V0cHV0W3JldmVyc2VfaXRlcmF0b3IgLSAxXSA9IE1hdGgucm91bmQoY2FycnkgJSAyNTYpO1xuICAgICAgICAgICAgY2FycnkgPSBNYXRoLmZsb29yKGNhcnJ5IC8gMjU2KTtcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggPSBpO1xuICAgIH0pO1xuICAgIGNvbnN0IHZhbGlkT3V0cHV0ID0gb3V0cHV0LmZpbHRlcigoaXRlbSkgPT4gaXRlbSA/PyBmYWxzZSk7XG4gICAgaWYgKG9uZXMgPiAwKSB7XG4gICAgICAgIGNvbnN0IG9uZXNSZXN1bHQgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBvbmVzIH0pLmZpbGwoMCwgMCwgb25lcyk7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbLi4ub25lc1Jlc3VsdCwgLi4udmFsaWRPdXRwdXRdKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHZhbGlkT3V0cHV0KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2U1OC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgMjAxOC0yMDIyIHRoZSBEZW5vIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIE1JVCBsaWNlbnNlLlxuLy8gQSBtb2R1bGUgdG8gcHJpbnQgQU5TSSB0ZXJtaW5hbCBjb2xvcnMuIEluc3BpcmVkIGJ5IGNoYWxrLCBrbGV1ciwgYW5kIGNvbG9yc1xuLy8gb24gbnBtLlxuLyoqXG4gKiBTdHJpbmcgZm9ybWF0dGVycyBhbmQgdXRpbGl0aWVzIGZvciBkZWFsaW5nIHdpdGggQU5TSSBjb2xvciBjb2Rlcy5cbiAqXG4gKiBUaGlzIG1vZHVsZSBpcyBicm93c2VyIGNvbXBhdGlibGUuXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGJnQmx1ZSwgcmVkLCBib2xkIH0gZnJvbSBcImh0dHBzOi8vZGVuby5sYW5kL3N0ZEAkU1REX1ZFUlNJT04vZm10L2NvbG9ycy50c1wiO1xuICogY29uc29sZS5sb2coYmdCbHVlKHJlZChib2xkKFwiSGVsbG8gd29ybGQhXCIpKSkpO1xuICogYGBgXG4gKlxuICogVGhpcyBtb2R1bGUgc3VwcG9ydHMgYE5PX0NPTE9SYCBlbnZpcm9ubWVudGFsIHZhcmlhYmxlIGRpc2FibGluZyBhbnkgY29sb3JpbmdcbiAqIGlmIGBOT19DT0xPUmAgaXMgc2V0LlxuICpcbiAqIEBtb2R1bGVcbiAqL1xuLy8gZGVuby1saW50LWlnbm9yZSBuby1leHBsaWNpdC1hbnlcbmltcG9ydCAqIGFzIGRudFNoaW0gZnJvbSBcIi4uLy4uLy4uLy4uL19kbnQuc2hpbXMuanNcIjtcbmNvbnN0IHsgRGVubyB9ID0gZG50U2hpbS5kbnRHbG9iYWxUaGlzO1xuY29uc3Qgbm9Db2xvciA9IHR5cGVvZiBEZW5vPy5ub0NvbG9yID09PSBcImJvb2xlYW5cIlxuICAgID8gRGVuby5ub0NvbG9yXG4gICAgOiB0cnVlO1xubGV0IGVuYWJsZWQgPSAhbm9Db2xvcjtcbi8qKlxuICogU2V0IGNoYW5naW5nIHRleHQgY29sb3IgdG8gZW5hYmxlZCBvciBkaXNhYmxlZFxuICogQHBhcmFtIHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRDb2xvckVuYWJsZWQodmFsdWUpIHtcbiAgICBpZiAobm9Db2xvcikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVuYWJsZWQgPSB2YWx1ZTtcbn1cbi8qKiBHZXQgd2hldGhlciB0ZXh0IGNvbG9yIGNoYW5nZSBpcyBlbmFibGVkIG9yIGRpc2FibGVkLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvbG9yRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gZW5hYmxlZDtcbn1cbi8qKlxuICogQnVpbGRzIGNvbG9yIGNvZGVcbiAqIEBwYXJhbSBvcGVuXG4gKiBAcGFyYW0gY2xvc2VcbiAqL1xuZnVuY3Rpb24gY29kZShvcGVuLCBjbG9zZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIG9wZW46IGBcXHgxYlske29wZW4uam9pbihcIjtcIil9bWAsXG4gICAgICAgIGNsb3NlOiBgXFx4MWJbJHtjbG9zZX1tYCxcbiAgICAgICAgcmVnZXhwOiBuZXcgUmVnRXhwKGBcXFxceDFiXFxcXFske2Nsb3NlfW1gLCBcImdcIiksXG4gICAgfTtcbn1cbi8qKlxuICogQXBwbGllcyBjb2xvciBhbmQgYmFja2dyb3VuZCBiYXNlZCBvbiBjb2xvciBjb2RlIGFuZCBpdHMgYXNzb2NpYXRlZCB0ZXh0XG4gKiBAcGFyYW0gc3RyIHRleHQgdG8gYXBwbHkgY29sb3Igc2V0dGluZ3MgdG9cbiAqIEBwYXJhbSBjb2RlIGNvbG9yIGNvZGUgdG8gYXBwbHlcbiAqL1xuZnVuY3Rpb24gcnVuKHN0ciwgY29kZSkge1xuICAgIHJldHVybiBlbmFibGVkXG4gICAgICAgID8gYCR7Y29kZS5vcGVufSR7c3RyLnJlcGxhY2UoY29kZS5yZWdleHAsIGNvZGUub3Blbil9JHtjb2RlLmNsb3NlfWBcbiAgICAgICAgOiBzdHI7XG59XG4vKipcbiAqIFJlc2V0IHRoZSB0ZXh0IG1vZGlmaWVkXG4gKiBAcGFyYW0gc3RyIHRleHQgdG8gcmVzZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0KHN0cikge1xuICAgIHJldHVybiBydW4oc3RyLCBjb2RlKFswXSwgMCkpO1xufVxuLyoqXG4gKiBNYWtlIHRoZSB0ZXh0IGJvbGQuXG4gKiBAcGFyYW0gc3RyIHRleHQgdG8gbWFrZSBib2xkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBib2xkKHN0cikge1xuICAgIHJldHVybiBydW4oc3RyLCBjb2RlKFsxXSwgMjIpKTtcbn1cbi8qKlxuICogVGhlIHRleHQgZW1pdHMgb25seSBhIHNtYWxsIGFtb3VudCBvZiBsaWdodC5cbiAqIEBwYXJhbSBzdHIgdGV4dCB0byBkaW1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpbShzdHIpIHtcbiAgICByZXR1cm4gcnVuKHN0ciwgY29kZShbMl0sIDIyKSk7XG59XG4vKipcbiAqIE1ha2UgdGhlIHRleHQgaXRhbGljLlxuICogQHBhcmFtIHN0ciB0ZXh0IHRvIG1ha2UgaXRhbGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpdGFsaWMoc3RyKSB7XG4gICAgcmV0dXJuIHJ1bihzdHIsIGNvZGUoWzNdLCAyMykpO1xufVxuLyoqXG4gKiBNYWtlIHRoZSB0ZXh0IHVuZGVybGluZS5cbiAqIEBwYXJhbSBzdHIgdGV4dCB0byB1bmRlcmxpbmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVuZGVybGluZShzdHIpIHtcbiAgICByZXR1cm4gcnVuKHN0ciwgY29kZShbNF0sIDI0KSk7XG59XG4vKipcbiAqIEludmVydCBiYWNrZ3JvdW5kIGNvbG9yIGFuZCB0ZXh0IGNvbG9yLlxuICogQHBhcmFtIHN0ciB0ZXh0IHRvIGludmVydCBpdHMgY29sb3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmVyc2Uoc3RyKSB7XG4gICAgcmV0dXJuIHJ1bihzdHIsIGNvZGUoWzddLCAyNykpO1xufVxuLyoqXG4gKiBNYWtlIHRoZSB0ZXh0IGhpZGRlbi5cbiAqIEBwYXJhbSBzdHIgdGV4dCB0byBoaWRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoaWRkZW4oc3RyKSB7XG4gICAgcmV0dXJuIHJ1bihzdHIsIGNvZGUoWzhdLCAyOCkpO1xufVxuLyoqXG4gKiBQdXQgaG9yaXpvbnRhbCBsaW5lIHRocm91Z2ggdGhlIGNlbnRlciBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSBzdHIgdGV4dCB0byBzdHJpa2UgdGhyb3VnaFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaWtldGhyb3VnaChzdHIpIHtcbiAgICByZXR1cm4gcnVuKHN0ciwgY29kZShbOV0sIDI5KSk7XG59XG4vKipcbiAqIFNldCB0ZXh0IGNvbG9yIHRvIGJsYWNrLlxuICogQHBhcmFtIHN0ciB0ZXh0IHRvIG1ha2UgYmxhY2tcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJsYWNrKHN0cikge1xuICAgIHJldHVybiBydW4oc3RyLCBjb2RlKFszMF0sIDM5KSk7XG59XG4vKipcbiAqIFNldCB0ZXh0IGNvbG9yIHRvIHJlZC5cbiAqIEBwYXJhbSBzdHIgdGV4dCB0byBtYWtlIHJlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVkKHN0cikge1xuICAgIHJldHVybiBydW4oc3RyLCBjb2RlKFszMV0sIDM5KSk7XG59XG4vKipcbiAqIFNldCB0ZXh0IGNvbG9yIHRvIGdyZWVuLlxuICogQHBhcmFtIHN0ciB0ZXh0IHRvIG1ha2UgZ3JlZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdyZWVuKHN0cikge1xuICAgIHJldHVybiBydW4oc3RyLCBjb2RlKFszMl0sIDM5KSk7XG59XG4vKipcbiAqIFNldCB0ZXh0IGNvbG9yIHRvIHllbGxvdy5cbiAqIEBwYXJhbSBzdHIgdGV4dCB0byBtYWtlIHllbGxvd1xuICovXG5leHBvcnQgZnVuY3Rpb24geWVsbG93KHN0cikge1xuICAgIHJldHVybiBydW4oc3RyLCBjb2RlKFszM10sIDM5KSk7XG59XG4vKipcbiAqIFNldCB0ZXh0IGNvbG9yIHRvIGJsdWUuXG4gKiBAcGFyYW0gc3RyIHRleHQgdG8gbWFrZSBibHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBibHVlKHN0cikge1xuICAgIHJldHVybiBydW4oc3RyLCBjb2RlKFszNF0sIDM5KSk7XG59XG4vKipcbiAqIFNldCB0ZXh0IGNvbG9yIHRvIG1hZ2VudGEuXG4gKiBAcGFyYW0gc3RyIHRleHQgdG8gbWFrZSBtYWdlbnRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWdlbnRhKHN0cikge1xuICAgIHJldHVybiBydW4oc3RyLCBjb2RlKFszNV0sIDM5KSk7XG59XG4vKipcbiAqIFNldCB0ZXh0IGNvbG9yIHRvIGN5YW4uXG4gKiBAcGFyYW0gc3RyIHRleHQgdG8gbWFrZSBjeWFuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjeWFuKHN0cikge1xuICAgIHJldHVybiBydW4oc3RyLCBjb2RlKFszNl0sIDM5KSk7XG59XG4vKipcbiAqIFNldCB0ZXh0IGNvbG9yIHRvIHdoaXRlLlxuICogQHBhcmFtIHN0ciB0ZXh0IHRvIG1ha2Ugd2hpdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdoaXRlKHN0cikge1xuICAgIHJldHVybiBydW4oc3RyLCBjb2RlKFszN10sIDM5KSk7XG59XG4vKipcbiAqIFNldCB0ZXh0IGNvbG9yIHRvIGdyYXkuXG4gKiBAcGFyYW0gc3RyIHRleHQgdG8gbWFrZSBncmF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBncmF5KHN0cikge1xuICAgIHJldHVybiBicmlnaHRCbGFjayhzdHIpO1xufVxuLyoqXG4gKiBTZXQgdGV4dCBjb2xvciB0byBicmlnaHQgYmxhY2suXG4gKiBAcGFyYW0gc3RyIHRleHQgdG8gbWFrZSBicmlnaHQtYmxhY2tcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJyaWdodEJsYWNrKHN0cikge1xuICAgIHJldHVybiBydW4oc3RyLCBjb2RlKFs5MF0sIDM5KSk7XG59XG4vKipcbiAqIFNldCB0ZXh0IGNvbG9yIHRvIGJyaWdodCByZWQuXG4gKiBAcGFyYW0gc3RyIHRleHQgdG8gbWFrZSBicmlnaHQtcmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBicmlnaHRSZWQoc3RyKSB7XG4gICAgcmV0dXJuIHJ1bihzdHIsIGNvZGUoWzkxXSwgMzkpKTtcbn1cbi8qKlxuICogU2V0IHRleHQgY29sb3IgdG8gYnJpZ2h0IGdyZWVuLlxuICogQHBhcmFtIHN0ciB0ZXh0IHRvIG1ha2UgYnJpZ2h0LWdyZWVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBicmlnaHRHcmVlbihzdHIpIHtcbiAgICByZXR1cm4gcnVuKHN0ciwgY29kZShbOTJdLCAzOSkpO1xufVxuLyoqXG4gKiBTZXQgdGV4dCBjb2xvciB0byBicmlnaHQgeWVsbG93LlxuICogQHBhcmFtIHN0ciB0ZXh0IHRvIG1ha2UgYnJpZ2h0LXllbGxvd1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnJpZ2h0WWVsbG93KHN0cikge1xuICAgIHJldHVybiBydW4oc3RyLCBjb2RlKFs5M10sIDM5KSk7XG59XG4vKipcbiAqIFNldCB0ZXh0IGNvbG9yIHRvIGJyaWdodCBibHVlLlxuICogQHBhcmFtIHN0ciB0ZXh0IHRvIG1ha2UgYnJpZ2h0LWJsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJyaWdodEJsdWUoc3RyKSB7XG4gICAgcmV0dXJuIHJ1bihzdHIsIGNvZGUoWzk0XSwgMzkpKTtcbn1cbi8qKlxuICogU2V0IHRleHQgY29sb3IgdG8gYnJpZ2h0IG1hZ2VudGEuXG4gKiBAcGFyYW0gc3RyIHRleHQgdG8gbWFrZSBicmlnaHQtbWFnZW50YVxuICovXG5leHBvcnQgZnVuY3Rpb24gYnJpZ2h0TWFnZW50YShzdHIpIHtcbiAgICByZXR1cm4gcnVuKHN0ciwgY29kZShbOTVdLCAzOSkpO1xufVxuLyoqXG4gKiBTZXQgdGV4dCBjb2xvciB0byBicmlnaHQgY3lhbi5cbiAqIEBwYXJhbSBzdHIgdGV4dCB0byBtYWtlIGJyaWdodC1jeWFuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBicmlnaHRDeWFuKHN0cikge1xuICAgIHJldHVybiBydW4oc3RyLCBjb2RlKFs5Nl0sIDM5KSk7XG59XG4vKipcbiAqIFNldCB0ZXh0IGNvbG9yIHRvIGJyaWdodCB3aGl0ZS5cbiAqIEBwYXJhbSBzdHIgdGV4dCB0byBtYWtlIGJyaWdodC13aGl0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYnJpZ2h0V2hpdGUoc3RyKSB7XG4gICAgcmV0dXJuIHJ1bihzdHIsIGNvZGUoWzk3XSwgMzkpKTtcbn1cbi8qKlxuICogU2V0IGJhY2tncm91bmQgY29sb3IgdG8gYmxhY2suXG4gKiBAcGFyYW0gc3RyIHRleHQgdG8gbWFrZSBpdHMgYmFja2dyb3VuZCBibGFja1xuICovXG5leHBvcnQgZnVuY3Rpb24gYmdCbGFjayhzdHIpIHtcbiAgICByZXR1cm4gcnVuKHN0ciwgY29kZShbNDBdLCA0OSkpO1xufVxuLyoqXG4gKiBTZXQgYmFja2dyb3VuZCBjb2xvciB0byByZWQuXG4gKiBAcGFyYW0gc3RyIHRleHQgdG8gbWFrZSBpdHMgYmFja2dyb3VuZCByZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJnUmVkKHN0cikge1xuICAgIHJldHVybiBydW4oc3RyLCBjb2RlKFs0MV0sIDQ5KSk7XG59XG4vKipcbiAqIFNldCBiYWNrZ3JvdW5kIGNvbG9yIHRvIGdyZWVuLlxuICogQHBhcmFtIHN0ciB0ZXh0IHRvIG1ha2UgaXRzIGJhY2tncm91bmQgZ3JlZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJnR3JlZW4oc3RyKSB7XG4gICAgcmV0dXJuIHJ1bihzdHIsIGNvZGUoWzQyXSwgNDkpKTtcbn1cbi8qKlxuICogU2V0IGJhY2tncm91bmQgY29sb3IgdG8geWVsbG93LlxuICogQHBhcmFtIHN0ciB0ZXh0IHRvIG1ha2UgaXRzIGJhY2tncm91bmQgeWVsbG93XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiZ1llbGxvdyhzdHIpIHtcbiAgICByZXR1cm4gcnVuKHN0ciwgY29kZShbNDNdLCA0OSkpO1xufVxuLyoqXG4gKiBTZXQgYmFja2dyb3VuZCBjb2xvciB0byBibHVlLlxuICogQHBhcmFtIHN0ciB0ZXh0IHRvIG1ha2UgaXRzIGJhY2tncm91bmQgYmx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmdCbHVlKHN0cikge1xuICAgIHJldHVybiBydW4oc3RyLCBjb2RlKFs0NF0sIDQ5KSk7XG59XG4vKipcbiAqICBTZXQgYmFja2dyb3VuZCBjb2xvciB0byBtYWdlbnRhLlxuICogQHBhcmFtIHN0ciB0ZXh0IHRvIG1ha2UgaXRzIGJhY2tncm91bmQgbWFnZW50YVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmdNYWdlbnRhKHN0cikge1xuICAgIHJldHVybiBydW4oc3RyLCBjb2RlKFs0NV0sIDQ5KSk7XG59XG4vKipcbiAqIFNldCBiYWNrZ3JvdW5kIGNvbG9yIHRvIGN5YW4uXG4gKiBAcGFyYW0gc3RyIHRleHQgdG8gbWFrZSBpdHMgYmFja2dyb3VuZCBjeWFuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiZ0N5YW4oc3RyKSB7XG4gICAgcmV0dXJuIHJ1bihzdHIsIGNvZGUoWzQ2XSwgNDkpKTtcbn1cbi8qKlxuICogU2V0IGJhY2tncm91bmQgY29sb3IgdG8gd2hpdGUuXG4gKiBAcGFyYW0gc3RyIHRleHQgdG8gbWFrZSBpdHMgYmFja2dyb3VuZCB3aGl0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmdXaGl0ZShzdHIpIHtcbiAgICByZXR1cm4gcnVuKHN0ciwgY29kZShbNDddLCA0OSkpO1xufVxuLyoqXG4gKiBTZXQgYmFja2dyb3VuZCBjb2xvciB0byBicmlnaHQgYmxhY2suXG4gKiBAcGFyYW0gc3RyIHRleHQgdG8gbWFrZSBpdHMgYmFja2dyb3VuZCBicmlnaHQtYmxhY2tcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJnQnJpZ2h0QmxhY2soc3RyKSB7XG4gICAgcmV0dXJuIHJ1bihzdHIsIGNvZGUoWzEwMF0sIDQ5KSk7XG59XG4vKipcbiAqIFNldCBiYWNrZ3JvdW5kIGNvbG9yIHRvIGJyaWdodCByZWQuXG4gKiBAcGFyYW0gc3RyIHRleHQgdG8gbWFrZSBpdHMgYmFja2dyb3VuZCBicmlnaHQtcmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiZ0JyaWdodFJlZChzdHIpIHtcbiAgICByZXR1cm4gcnVuKHN0ciwgY29kZShbMTAxXSwgNDkpKTtcbn1cbi8qKlxuICogU2V0IGJhY2tncm91bmQgY29sb3IgdG8gYnJpZ2h0IGdyZWVuLlxuICogQHBhcmFtIHN0ciB0ZXh0IHRvIG1ha2UgaXRzIGJhY2tncm91bmQgYnJpZ2h0LWdyZWVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiZ0JyaWdodEdyZWVuKHN0cikge1xuICAgIHJldHVybiBydW4oc3RyLCBjb2RlKFsxMDJdLCA0OSkpO1xufVxuLyoqXG4gKiBTZXQgYmFja2dyb3VuZCBjb2xvciB0byBicmlnaHQgeWVsbG93LlxuICogQHBhcmFtIHN0ciB0ZXh0IHRvIG1ha2UgaXRzIGJhY2tncm91bmQgYnJpZ2h0LXllbGxvd1xuICovXG5leHBvcnQgZnVuY3Rpb24gYmdCcmlnaHRZZWxsb3coc3RyKSB7XG4gICAgcmV0dXJuIHJ1bihzdHIsIGNvZGUoWzEwM10sIDQ5KSk7XG59XG4vKipcbiAqIFNldCBiYWNrZ3JvdW5kIGNvbG9yIHRvIGJyaWdodCBibHVlLlxuICogQHBhcmFtIHN0ciB0ZXh0IHRvIG1ha2UgaXRzIGJhY2tncm91bmQgYnJpZ2h0LWJsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJnQnJpZ2h0Qmx1ZShzdHIpIHtcbiAgICByZXR1cm4gcnVuKHN0ciwgY29kZShbMTA0XSwgNDkpKTtcbn1cbi8qKlxuICogU2V0IGJhY2tncm91bmQgY29sb3IgdG8gYnJpZ2h0IG1hZ2VudGEuXG4gKiBAcGFyYW0gc3RyIHRleHQgdG8gbWFrZSBpdHMgYmFja2dyb3VuZCBicmlnaHQtbWFnZW50YVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmdCcmlnaHRNYWdlbnRhKHN0cikge1xuICAgIHJldHVybiBydW4oc3RyLCBjb2RlKFsxMDVdLCA0OSkpO1xufVxuLyoqXG4gKiBTZXQgYmFja2dyb3VuZCBjb2xvciB0byBicmlnaHQgY3lhbi5cbiAqIEBwYXJhbSBzdHIgdGV4dCB0byBtYWtlIGl0cyBiYWNrZ3JvdW5kIGJyaWdodC1jeWFuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiZ0JyaWdodEN5YW4oc3RyKSB7XG4gICAgcmV0dXJuIHJ1bihzdHIsIGNvZGUoWzEwNl0sIDQ5KSk7XG59XG4vKipcbiAqIFNldCBiYWNrZ3JvdW5kIGNvbG9yIHRvIGJyaWdodCB3aGl0ZS5cbiAqIEBwYXJhbSBzdHIgdGV4dCB0byBtYWtlIGl0cyBiYWNrZ3JvdW5kIGJyaWdodC13aGl0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmdCcmlnaHRXaGl0ZShzdHIpIHtcbiAgICByZXR1cm4gcnVuKHN0ciwgY29kZShbMTA3XSwgNDkpKTtcbn1cbi8qIFNwZWNpYWwgQ29sb3IgU2VxdWVuY2VzICovXG4vKipcbiAqIENsYW0gYW5kIHRydW5jYXRlIGNvbG9yIGNvZGVzXG4gKiBAcGFyYW0gblxuICogQHBhcmFtIG1heCBudW1iZXIgdG8gdHJ1bmNhdGUgdG9cbiAqIEBwYXJhbSBtaW4gbnVtYmVyIHRvIHRydW5jYXRlIGZyb21cbiAqL1xuZnVuY3Rpb24gY2xhbXBBbmRUcnVuY2F0ZShuLCBtYXggPSAyNTUsIG1pbiA9IDApIHtcbiAgICByZXR1cm4gTWF0aC50cnVuYyhNYXRoLm1heChNYXRoLm1pbihuLCBtYXgpLCBtaW4pKTtcbn1cbi8qKlxuICogU2V0IHRleHQgY29sb3IgdXNpbmcgcGFsZXR0ZWQgOGJpdCBjb2xvcnMuXG4gKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlIzgtYml0XG4gKiBAcGFyYW0gc3RyIHRleHQgY29sb3IgdG8gYXBwbHkgcGFsZXR0ZWQgOGJpdCBjb2xvcnMgdG9cbiAqIEBwYXJhbSBjb2xvciBjb2RlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZ2I4KHN0ciwgY29sb3IpIHtcbiAgICByZXR1cm4gcnVuKHN0ciwgY29kZShbMzgsIDUsIGNsYW1wQW5kVHJ1bmNhdGUoY29sb3IpXSwgMzkpKTtcbn1cbi8qKlxuICogU2V0IGJhY2tncm91bmQgY29sb3IgdXNpbmcgcGFsZXR0ZWQgOGJpdCBjb2xvcnMuXG4gKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlIzgtYml0XG4gKiBAcGFyYW0gc3RyIHRleHQgY29sb3IgdG8gYXBwbHkgcGFsZXR0ZWQgOGJpdCBiYWNrZ3JvdW5kIGNvbG9ycyB0b1xuICogQHBhcmFtIGNvbG9yIGNvZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJnUmdiOChzdHIsIGNvbG9yKSB7XG4gICAgcmV0dXJuIHJ1bihzdHIsIGNvZGUoWzQ4LCA1LCBjbGFtcEFuZFRydW5jYXRlKGNvbG9yKV0sIDQ5KSk7XG59XG4vKipcbiAqIFNldCB0ZXh0IGNvbG9yIHVzaW5nIDI0Yml0IHJnYi5cbiAqIGBjb2xvcmAgY2FuIGJlIGEgbnVtYmVyIGluIHJhbmdlIGAweDAwMDAwMGAgdG8gYDB4ZmZmZmZmYCBvclxuICogYW4gYFJnYmAuXG4gKlxuICogVG8gcHJvZHVjZSB0aGUgY29sb3IgbWFnZW50YTpcbiAqXG4gKiBgYGB0c1xuICogICAgICBpbXBvcnQgeyByZ2IyNCB9IGZyb20gXCIuL2NvbG9ycy50c1wiO1xuICogICAgICByZ2IyNChcImZvb1wiLCAweGZmMDBmZik7XG4gKiAgICAgIHJnYjI0KFwiZm9vXCIsIHtyOiAyNTUsIGc6IDAsIGI6IDI1NX0pO1xuICogYGBgXG4gKiBAcGFyYW0gc3RyIHRleHQgY29sb3IgdG8gYXBwbHkgMjRiaXQgcmdiIHRvXG4gKiBAcGFyYW0gY29sb3IgY29kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmdiMjQoc3RyLCBjb2xvcikge1xuICAgIGlmICh0eXBlb2YgY29sb3IgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIHJ1bihzdHIsIGNvZGUoWzM4LCAyLCAoY29sb3IgPj4gMTYpICYgMHhmZiwgKGNvbG9yID4+IDgpICYgMHhmZiwgY29sb3IgJiAweGZmXSwgMzkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJ1bihzdHIsIGNvZGUoW1xuICAgICAgICAzOCxcbiAgICAgICAgMixcbiAgICAgICAgY2xhbXBBbmRUcnVuY2F0ZShjb2xvci5yKSxcbiAgICAgICAgY2xhbXBBbmRUcnVuY2F0ZShjb2xvci5nKSxcbiAgICAgICAgY2xhbXBBbmRUcnVuY2F0ZShjb2xvci5iKSxcbiAgICBdLCAzOSkpO1xufVxuLyoqXG4gKiBTZXQgYmFja2dyb3VuZCBjb2xvciB1c2luZyAyNGJpdCByZ2IuXG4gKiBgY29sb3JgIGNhbiBiZSBhIG51bWJlciBpbiByYW5nZSBgMHgwMDAwMDBgIHRvIGAweGZmZmZmZmAgb3JcbiAqIGFuIGBSZ2JgLlxuICpcbiAqIFRvIHByb2R1Y2UgdGhlIGNvbG9yIG1hZ2VudGE6XG4gKlxuICogYGBgdHNcbiAqICAgICAgaW1wb3J0IHsgYmdSZ2IyNCB9IGZyb20gXCIuL2NvbG9ycy50c1wiO1xuICogICAgICBiZ1JnYjI0KFwiZm9vXCIsIDB4ZmYwMGZmKTtcbiAqICAgICAgYmdSZ2IyNChcImZvb1wiLCB7cjogMjU1LCBnOiAwLCBiOiAyNTV9KTtcbiAqIGBgYFxuICogQHBhcmFtIHN0ciB0ZXh0IGNvbG9yIHRvIGFwcGx5IDI0Yml0IHJnYiB0b1xuICogQHBhcmFtIGNvbG9yIGNvZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJnUmdiMjQoc3RyLCBjb2xvcikge1xuICAgIGlmICh0eXBlb2YgY29sb3IgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIHJ1bihzdHIsIGNvZGUoWzQ4LCAyLCAoY29sb3IgPj4gMTYpICYgMHhmZiwgKGNvbG9yID4+IDgpICYgMHhmZiwgY29sb3IgJiAweGZmXSwgNDkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJ1bihzdHIsIGNvZGUoW1xuICAgICAgICA0OCxcbiAgICAgICAgMixcbiAgICAgICAgY2xhbXBBbmRUcnVuY2F0ZShjb2xvci5yKSxcbiAgICAgICAgY2xhbXBBbmRUcnVuY2F0ZShjb2xvci5nKSxcbiAgICAgICAgY2xhbXBBbmRUcnVuY2F0ZShjb2xvci5iKSxcbiAgICBdLCA0OSkpO1xufVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYWxrL2Fuc2ktcmVnZXgvYmxvYi8wMmZhODkzZDYxOWQzZGE4NTQxMWFjYzhmZDRlMmVlYTBlOTVhOWQ5L2luZGV4LmpzXG5jb25zdCBBTlNJX1BBVFRFUk4gPSBuZXcgUmVnRXhwKFtcbiAgICBcIltcXFxcdTAwMUJcXFxcdTAwOUJdW1tcXFxcXSgpIzs/XSooPzooPzooPzooPzo7Wy1hLXpBLVpcXFxcZFxcXFwvIyYuOj0/JUB+X10rKSp8W2EtekEtWlxcXFxkXSsoPzo7Wy1hLXpBLVpcXFxcZFxcXFwvIyYuOj0/JUB+X10qKSopP1xcXFx1MDAwNylcIixcbiAgICBcIig/Oig/OlxcXFxkezEsNH0oPzo7XFxcXGR7MCw0fSkqKT9bXFxcXGRBLVBSLVRaY2YtbnEtdXk9Pjx+XSkpXCIsXG5dLmpvaW4oXCJ8XCIpLCBcImdcIik7XG4vKipcbiAqIFJlbW92ZSBBTlNJIGVzY2FwZSBjb2RlcyBmcm9tIHRoZSBzdHJpbmcuXG4gKiBAcGFyYW0gc3RyaW5nIHRvIHJlbW92ZSBBTlNJIGVzY2FwZSBjb2RlcyBmcm9tXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpcENvbG9yKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShBTlNJX1BBVFRFUk4sIFwiXCIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29sb3JzLmpzLm1hcCIsIi8vIENvcHlyaWdodCAyMDE4LTIwMjIgdGhlIERlbm8gYXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gTUlUIGxpY2Vuc2UuXG4vLyBUaGlzIG1vZHVsZSBpcyBicm93c2VyIGNvbXBhdGlibGUuXG5pbXBvcnQgeyBiZ0dyZWVuLCBiZ1JlZCwgYm9sZCwgZ3JheSwgZ3JlZW4sIHJlZCwgd2hpdGUsIH0gZnJvbSBcIi4uL2ZtdC9jb2xvcnMuanNcIjtcbmV4cG9ydCB2YXIgRGlmZlR5cGU7XG4oZnVuY3Rpb24gKERpZmZUeXBlKSB7XG4gICAgRGlmZlR5cGVbXCJyZW1vdmVkXCJdID0gXCJyZW1vdmVkXCI7XG4gICAgRGlmZlR5cGVbXCJjb21tb25cIl0gPSBcImNvbW1vblwiO1xuICAgIERpZmZUeXBlW1wiYWRkZWRcIl0gPSBcImFkZGVkXCI7XG59KShEaWZmVHlwZSB8fCAoRGlmZlR5cGUgPSB7fSkpO1xuY29uc3QgUkVNT1ZFRCA9IDE7XG5jb25zdCBDT01NT04gPSAyO1xuY29uc3QgQURERUQgPSAzO1xuZnVuY3Rpb24gY3JlYXRlQ29tbW9uKEEsIEIsIHJldmVyc2UpIHtcbiAgICBjb25zdCBjb21tb24gPSBbXTtcbiAgICBpZiAoQS5sZW5ndGggPT09IDAgfHwgQi5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWluKEEubGVuZ3RoLCBCLmxlbmd0aCk7IGkgKz0gMSkge1xuICAgICAgICBpZiAoQVtyZXZlcnNlID8gQS5sZW5ndGggLSBpIC0gMSA6IGldID09PSBCW3JldmVyc2UgPyBCLmxlbmd0aCAtIGkgLSAxIDogaV0pIHtcbiAgICAgICAgICAgIGNvbW1vbi5wdXNoKEFbcmV2ZXJzZSA/IEEubGVuZ3RoIC0gaSAtIDEgOiBpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY29tbW9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb21tb247XG59XG4vKipcbiAqIFJlbmRlcnMgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzXG4gKiBAcGFyYW0gQSBBY3R1YWwgdmFsdWVcbiAqIEBwYXJhbSBCIEV4cGVjdGVkIHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaWZmKEEsIEIpIHtcbiAgICBjb25zdCBwcmVmaXhDb21tb24gPSBjcmVhdGVDb21tb24oQSwgQik7XG4gICAgY29uc3Qgc3VmZml4Q29tbW9uID0gY3JlYXRlQ29tbW9uKEEuc2xpY2UocHJlZml4Q29tbW9uLmxlbmd0aCksIEIuc2xpY2UocHJlZml4Q29tbW9uLmxlbmd0aCksIHRydWUpLnJldmVyc2UoKTtcbiAgICBBID0gc3VmZml4Q29tbW9uLmxlbmd0aFxuICAgICAgICA/IEEuc2xpY2UocHJlZml4Q29tbW9uLmxlbmd0aCwgLXN1ZmZpeENvbW1vbi5sZW5ndGgpXG4gICAgICAgIDogQS5zbGljZShwcmVmaXhDb21tb24ubGVuZ3RoKTtcbiAgICBCID0gc3VmZml4Q29tbW9uLmxlbmd0aFxuICAgICAgICA/IEIuc2xpY2UocHJlZml4Q29tbW9uLmxlbmd0aCwgLXN1ZmZpeENvbW1vbi5sZW5ndGgpXG4gICAgICAgIDogQi5zbGljZShwcmVmaXhDb21tb24ubGVuZ3RoKTtcbiAgICBjb25zdCBzd2FwcGVkID0gQi5sZW5ndGggPiBBLmxlbmd0aDtcbiAgICBbQSwgQl0gPSBzd2FwcGVkID8gW0IsIEFdIDogW0EsIEJdO1xuICAgIGNvbnN0IE0gPSBBLmxlbmd0aDtcbiAgICBjb25zdCBOID0gQi5sZW5ndGg7XG4gICAgaWYgKCFNICYmICFOICYmICFzdWZmaXhDb21tb24ubGVuZ3RoICYmICFwcmVmaXhDb21tb24ubGVuZ3RoKVxuICAgICAgICByZXR1cm4gW107XG4gICAgaWYgKCFOKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAuLi5wcmVmaXhDb21tb24ubWFwKChjKSA9PiAoeyB0eXBlOiBEaWZmVHlwZS5jb21tb24sIHZhbHVlOiBjIH0pKSxcbiAgICAgICAgICAgIC4uLkEubWFwKChhKSA9PiAoe1xuICAgICAgICAgICAgICAgIHR5cGU6IHN3YXBwZWQgPyBEaWZmVHlwZS5hZGRlZCA6IERpZmZUeXBlLnJlbW92ZWQsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGEsXG4gICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAuLi5zdWZmaXhDb21tb24ubWFwKChjKSA9PiAoeyB0eXBlOiBEaWZmVHlwZS5jb21tb24sIHZhbHVlOiBjIH0pKSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgY29uc3Qgb2Zmc2V0ID0gTjtcbiAgICBjb25zdCBkZWx0YSA9IE0gLSBOO1xuICAgIGNvbnN0IHNpemUgPSBNICsgTiArIDE7XG4gICAgY29uc3QgZnAgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBzaXplIH0sICgpID0+ICh7IHk6IC0xLCBpZDogLTEgfSkpO1xuICAgIC8qKlxuICAgICAqIElORk86XG4gICAgICogVGhpcyBidWZmZXIgaXMgdXNlZCB0byBzYXZlIG1lbW9yeSBhbmQgaW1wcm92ZSBwZXJmb3JtYW5jZS5cbiAgICAgKiBUaGUgZmlyc3QgaGFsZiBpcyB1c2VkIHRvIHNhdmUgcm91dGUgYW5kIGxhc3QgaGFsZiBpcyB1c2VkIHRvIHNhdmUgZGlmZlxuICAgICAqIHR5cGUuXG4gICAgICogVGhpcyBpcyBiZWNhdXNlLCB3aGVuIEkga2VwdCBuZXcgdWludDhhcnJheSBhcmVhIHRvIHNhdmUgdHlwZSxwZXJmb3JtYW5jZVxuICAgICAqIHdvcnNlbmVkLlxuICAgICAqL1xuICAgIGNvbnN0IHJvdXRlcyA9IG5ldyBVaW50MzJBcnJheSgoTSAqIE4gKyBzaXplICsgMSkgKiAyKTtcbiAgICBjb25zdCBkaWZmVHlwZXNQdHJPZmZzZXQgPSByb3V0ZXMubGVuZ3RoIC8gMjtcbiAgICBsZXQgcHRyID0gMDtcbiAgICBsZXQgcCA9IC0xO1xuICAgIGZ1bmN0aW9uIGJhY2tUcmFjZShBLCBCLCBjdXJyZW50LCBzd2FwcGVkKSB7XG4gICAgICAgIGNvbnN0IE0gPSBBLmxlbmd0aDtcbiAgICAgICAgY29uc3QgTiA9IEIubGVuZ3RoO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IGEgPSBNIC0gMTtcbiAgICAgICAgbGV0IGIgPSBOIC0gMTtcbiAgICAgICAgbGV0IGogPSByb3V0ZXNbY3VycmVudC5pZF07XG4gICAgICAgIGxldCB0eXBlID0gcm91dGVzW2N1cnJlbnQuaWQgKyBkaWZmVHlwZXNQdHJPZmZzZXRdO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKCFqICYmICF0eXBlKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY29uc3QgcHJldiA9IGo7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gUkVNT1ZFRCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC51bnNoaWZ0KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogc3dhcHBlZCA/IERpZmZUeXBlLnJlbW92ZWQgOiBEaWZmVHlwZS5hZGRlZCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IEJbYl0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYiAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gQURERUQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudW5zaGlmdCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHN3YXBwZWQgPyBEaWZmVHlwZS5hZGRlZCA6IERpZmZUeXBlLnJlbW92ZWQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBBW2FdLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGEgLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC51bnNoaWZ0KHsgdHlwZTogRGlmZlR5cGUuY29tbW9uLCB2YWx1ZTogQVthXSB9KTtcbiAgICAgICAgICAgICAgICBhIC09IDE7XG4gICAgICAgICAgICAgICAgYiAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaiA9IHJvdXRlc1twcmV2XTtcbiAgICAgICAgICAgIHR5cGUgPSByb3V0ZXNbcHJldiArIGRpZmZUeXBlc1B0ck9mZnNldF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRlAoc2xpZGUsIGRvd24sIGssIE0pIHtcbiAgICAgICAgaWYgKHNsaWRlICYmIHNsaWRlLnkgPT09IC0xICYmIGRvd24gJiYgZG93bi55ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeTogMCwgaWQ6IDAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGRvd24gJiYgZG93bi55ID09PSAtMSkgfHxcbiAgICAgICAgICAgIGsgPT09IE0gfHxcbiAgICAgICAgICAgIChzbGlkZSAmJiBzbGlkZS55KSA+IChkb3duICYmIGRvd24ueSkgKyAxKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2ID0gc2xpZGUuaWQ7XG4gICAgICAgICAgICBwdHIrKztcbiAgICAgICAgICAgIHJvdXRlc1twdHJdID0gcHJldjtcbiAgICAgICAgICAgIHJvdXRlc1twdHIgKyBkaWZmVHlwZXNQdHJPZmZzZXRdID0gQURERUQ7XG4gICAgICAgICAgICByZXR1cm4geyB5OiBzbGlkZS55LCBpZDogcHRyIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2ID0gZG93bi5pZDtcbiAgICAgICAgICAgIHB0cisrO1xuICAgICAgICAgICAgcm91dGVzW3B0cl0gPSBwcmV2O1xuICAgICAgICAgICAgcm91dGVzW3B0ciArIGRpZmZUeXBlc1B0ck9mZnNldF0gPSBSRU1PVkVEO1xuICAgICAgICAgICAgcmV0dXJuIHsgeTogZG93bi55ICsgMSwgaWQ6IHB0ciB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNuYWtlKGssIHNsaWRlLCBkb3duLCBfb2Zmc2V0LCBBLCBCKSB7XG4gICAgICAgIGNvbnN0IE0gPSBBLmxlbmd0aDtcbiAgICAgICAgY29uc3QgTiA9IEIubGVuZ3RoO1xuICAgICAgICBpZiAoayA8IC1OIHx8IE0gPCBrKVxuICAgICAgICAgICAgcmV0dXJuIHsgeTogLTEsIGlkOiAtMSB9O1xuICAgICAgICBjb25zdCBmcCA9IGNyZWF0ZUZQKHNsaWRlLCBkb3duLCBrLCBNKTtcbiAgICAgICAgd2hpbGUgKGZwLnkgKyBrIDwgTSAmJiBmcC55IDwgTiAmJiBBW2ZwLnkgKyBrXSA9PT0gQltmcC55XSkge1xuICAgICAgICAgICAgY29uc3QgcHJldiA9IGZwLmlkO1xuICAgICAgICAgICAgcHRyKys7XG4gICAgICAgICAgICBmcC5pZCA9IHB0cjtcbiAgICAgICAgICAgIGZwLnkgKz0gMTtcbiAgICAgICAgICAgIHJvdXRlc1twdHJdID0gcHJldjtcbiAgICAgICAgICAgIHJvdXRlc1twdHIgKyBkaWZmVHlwZXNQdHJPZmZzZXRdID0gQ09NTU9OO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcDtcbiAgICB9XG4gICAgd2hpbGUgKGZwW2RlbHRhICsgb2Zmc2V0XS55IDwgTikge1xuICAgICAgICBwID0gcCArIDE7XG4gICAgICAgIGZvciAobGV0IGsgPSAtcDsgayA8IGRlbHRhOyArK2spIHtcbiAgICAgICAgICAgIGZwW2sgKyBvZmZzZXRdID0gc25ha2UoaywgZnBbayAtIDEgKyBvZmZzZXRdLCBmcFtrICsgMSArIG9mZnNldF0sIG9mZnNldCwgQSwgQik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgayA9IGRlbHRhICsgcDsgayA+IGRlbHRhOyAtLWspIHtcbiAgICAgICAgICAgIGZwW2sgKyBvZmZzZXRdID0gc25ha2UoaywgZnBbayAtIDEgKyBvZmZzZXRdLCBmcFtrICsgMSArIG9mZnNldF0sIG9mZnNldCwgQSwgQik7XG4gICAgICAgIH1cbiAgICAgICAgZnBbZGVsdGEgKyBvZmZzZXRdID0gc25ha2UoZGVsdGEsIGZwW2RlbHRhIC0gMSArIG9mZnNldF0sIGZwW2RlbHRhICsgMSArIG9mZnNldF0sIG9mZnNldCwgQSwgQik7XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICAgIC4uLnByZWZpeENvbW1vbi5tYXAoKGMpID0+ICh7IHR5cGU6IERpZmZUeXBlLmNvbW1vbiwgdmFsdWU6IGMgfSkpLFxuICAgICAgICAuLi5iYWNrVHJhY2UoQSwgQiwgZnBbZGVsdGEgKyBvZmZzZXRdLCBzd2FwcGVkKSxcbiAgICAgICAgLi4uc3VmZml4Q29tbW9uLm1hcCgoYykgPT4gKHsgdHlwZTogRGlmZlR5cGUuY29tbW9uLCB2YWx1ZTogYyB9KSksXG4gICAgXTtcbn1cbi8qKlxuICogUmVuZGVycyB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiB0aGUgYWN0dWFsIGFuZCBleHBlY3RlZCBzdHJpbmdzXG4gKiBQYXJ0aWFsbHkgaW5zcGlyZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20va3BkZWNrZXIvanNkaWZmXG4gKiBAcGFyYW0gQSBBY3R1YWwgc3RyaW5nXG4gKiBAcGFyYW0gQiBFeHBlY3RlZCBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpZmZzdHIoQSwgQikge1xuICAgIGZ1bmN0aW9uIHVuZXNjYXBlKHN0cmluZykge1xuICAgICAgICAvLyB1bmVzY2FwZSBpbnZpc2libGUgY2hhcmFjdGVycy5cbiAgICAgICAgLy8gcmVmOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcjZXNjYXBlX3NlcXVlbmNlc1xuICAgICAgICByZXR1cm4gc3RyaW5nXG4gICAgICAgICAgICAucmVwbGFjZUFsbChcIlxcYlwiLCBcIlxcXFxiXCIpXG4gICAgICAgICAgICAucmVwbGFjZUFsbChcIlxcZlwiLCBcIlxcXFxmXCIpXG4gICAgICAgICAgICAucmVwbGFjZUFsbChcIlxcdFwiLCBcIlxcXFx0XCIpXG4gICAgICAgICAgICAucmVwbGFjZUFsbChcIlxcdlwiLCBcIlxcXFx2XCIpXG4gICAgICAgICAgICAucmVwbGFjZUFsbCgvLyBkb2VzIG5vdCByZW1vdmUgbGluZSBicmVha3NcbiAgICAgICAgL1xcclxcbnxcXHJ8XFxuL2csIChzdHIpID0+IHN0ciA9PT0gXCJcXHJcIiA/IFwiXFxcXHJcIiA6IHN0ciA9PT0gXCJcXG5cIiA/IFwiXFxcXG5cXG5cIiA6IFwiXFxcXHJcXFxcblxcclxcblwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdG9rZW5pemUoc3RyaW5nLCB7IHdvcmREaWZmID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgICAgIGlmICh3b3JkRGlmZikge1xuICAgICAgICAgICAgLy8gU3BsaXQgc3RyaW5nIG9uIHdoaXRlc3BhY2Ugc3ltYm9sc1xuICAgICAgICAgICAgY29uc3QgdG9rZW5zID0gc3RyaW5nLnNwbGl0KC8oW15cXFNcXHJcXG5dK3xbKClbXFxde30nXCJcXHJcXG5dfFxcYikvKTtcbiAgICAgICAgICAgIC8vIEV4dGVuZGVkIExhdGluIGNoYXJhY3RlciBzZXRcbiAgICAgICAgICAgIGNvbnN0IHdvcmRzID0gL15bYS16QS1aXFx1e0MwfS1cXHV7RkZ9XFx1e0Q4fS1cXHV7RjZ9XFx1e0Y4fS1cXHV7MkM2fVxcdXsyQzh9LVxcdXsyRDd9XFx1ezJERX0tXFx1ezJGRn1cXHV7MUUwMH0tXFx1ezFFRkZ9XSskL3U7XG4gICAgICAgICAgICAvLyBKb2luIGJvdW5kYXJ5IHNwbGl0cyB0aGF0IHdlIGRvIG5vdCBjb25zaWRlciB0byBiZSBib3VuZGFyaWVzIGFuZCBtZXJnZSBlbXB0eSBzdHJpbmdzIHN1cnJvdW5kZWQgYnkgd29yZCBjaGFyc1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0b2tlbnNbaSArIDFdICYmIHRva2Vuc1tpICsgMl0gJiYgd29yZHMudGVzdCh0b2tlbnNbaV0pICYmXG4gICAgICAgICAgICAgICAgICAgIHdvcmRzLnRlc3QodG9rZW5zW2kgKyAyXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zW2ldICs9IHRva2Vuc1tpICsgMl07XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5zcGxpY2UoaSArIDEsIDIpO1xuICAgICAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRva2Vucy5maWx0ZXIoKHRva2VuKSA9PiB0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBTcGxpdCBzdHJpbmcgb24gbmV3IGxpbmVzIHN5bWJvbHNcbiAgICAgICAgICAgIGNvbnN0IHRva2VucyA9IFtdLCBsaW5lcyA9IHN0cmluZy5zcGxpdCgvKFxcbnxcXHJcXG4pLyk7XG4gICAgICAgICAgICAvLyBJZ25vcmUgZmluYWwgZW1wdHkgdG9rZW4gd2hlbiB0ZXh0IGVuZHMgd2l0aCBhIG5ld2xpbmVcbiAgICAgICAgICAgIGlmICghbGluZXNbbGluZXMubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgICAgICBsaW5lcy5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1lcmdlIHRoZSBjb250ZW50IGFuZCBsaW5lIHNlcGFyYXRvcnMgaW50byBzaW5nbGUgdG9rZW5zXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgJSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0gKz0gbGluZXNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaChsaW5lc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDcmVhdGUgZGV0YWlscyBieSBmaWx0ZXJpbmcgcmVsZXZhbnQgd29yZC1kaWZmIGZvciBjdXJyZW50IGxpbmVcbiAgICAvLyBhbmQgbWVyZ2UgXCJzcGFjZS1kaWZmXCIgaWYgc3Vycm91bmRlZCBieSB3b3JkLWRpZmYgZm9yIGNsZWFuZXIgZGlzcGxheXNcbiAgICBmdW5jdGlvbiBjcmVhdGVEZXRhaWxzKGxpbmUsIHRva2Vucykge1xuICAgICAgICByZXR1cm4gdG9rZW5zLmZpbHRlcigoeyB0eXBlIH0pID0+IHR5cGUgPT09IGxpbmUudHlwZSB8fCB0eXBlID09PSBEaWZmVHlwZS5jb21tb24pLm1hcCgocmVzdWx0LCBpLCB0KSA9PiB7XG4gICAgICAgICAgICBpZiAoKHJlc3VsdC50eXBlID09PSBEaWZmVHlwZS5jb21tb24pICYmICh0W2kgLSAxXSkgJiZcbiAgICAgICAgICAgICAgICAodFtpIC0gMV0/LnR5cGUgPT09IHRbaSArIDFdPy50eXBlKSAmJiAvXFxzKy8udGVzdChyZXN1bHQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnR5cGUgPSB0W2kgLSAxXS50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIENvbXB1dGUgbXVsdGktbGluZSBkaWZmXG4gICAgY29uc3QgZGlmZlJlc3VsdCA9IGRpZmYodG9rZW5pemUoYCR7dW5lc2NhcGUoQSl9XFxuYCksIHRva2VuaXplKGAke3VuZXNjYXBlKEIpfVxcbmApKTtcbiAgICBjb25zdCBhZGRlZCA9IFtdLCByZW1vdmVkID0gW107XG4gICAgZm9yIChjb25zdCByZXN1bHQgb2YgZGlmZlJlc3VsdCkge1xuICAgICAgICBpZiAocmVzdWx0LnR5cGUgPT09IERpZmZUeXBlLmFkZGVkKSB7XG4gICAgICAgICAgICBhZGRlZC5wdXNoKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBEaWZmVHlwZS5yZW1vdmVkKSB7XG4gICAgICAgICAgICByZW1vdmVkLnB1c2gocmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDb21wdXRlIHdvcmQtZGlmZlxuICAgIGNvbnN0IGFMaW5lcyA9IGFkZGVkLmxlbmd0aCA8IHJlbW92ZWQubGVuZ3RoID8gYWRkZWQgOiByZW1vdmVkO1xuICAgIGNvbnN0IGJMaW5lcyA9IGFMaW5lcyA9PT0gcmVtb3ZlZCA/IGFkZGVkIDogcmVtb3ZlZDtcbiAgICBmb3IgKGNvbnN0IGEgb2YgYUxpbmVzKSB7XG4gICAgICAgIGxldCB0b2tlbnMgPSBbXSwgYjtcbiAgICAgICAgLy8gU2VhcmNoIGFub3RoZXIgZGlmZiBsaW5lIHdpdGggYXQgbGVhc3Qgb25lIGNvbW1vbiB0b2tlblxuICAgICAgICB3aGlsZSAoYkxpbmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgYiA9IGJMaW5lcy5zaGlmdCgpO1xuICAgICAgICAgICAgdG9rZW5zID0gZGlmZih0b2tlbml6ZShhLnZhbHVlLCB7IHdvcmREaWZmOiB0cnVlIH0pLCB0b2tlbml6ZShiPy52YWx1ZSA/PyBcIlwiLCB7IHdvcmREaWZmOiB0cnVlIH0pKTtcbiAgICAgICAgICAgIGlmICh0b2tlbnMuc29tZSgoeyB0eXBlLCB2YWx1ZSB9KSA9PiB0eXBlID09PSBEaWZmVHlwZS5jb21tb24gJiYgdmFsdWUudHJpbSgpLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZWdpc3RlciB3b3JkLWRpZmYgZGV0YWlsc1xuICAgICAgICBhLmRldGFpbHMgPSBjcmVhdGVEZXRhaWxzKGEsIHRva2Vucyk7XG4gICAgICAgIGlmIChiKSB7XG4gICAgICAgICAgICBiLmRldGFpbHMgPSBjcmVhdGVEZXRhaWxzKGIsIHRva2Vucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpZmZSZXN1bHQ7XG59XG4vKipcbiAqIENvbG9ycyB0aGUgb3V0cHV0IG9mIGFzc2VydGlvbiBkaWZmc1xuICogQHBhcmFtIGRpZmZUeXBlIERpZmZlcmVuY2UgdHlwZSwgZWl0aGVyIGFkZGVkIG9yIHJlbW92ZWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29sb3IoZGlmZlR5cGUsIHsgYmFja2dyb3VuZCA9IGZhbHNlIH0gPSB7fSkge1xuICAgIC8vIFRPRE8oQGxpdHRsZWRpdnkpOiBSZW1vdmUgdGhpcyB3aGVuIHdlIGNhbiBkZXRlY3RcbiAgICAvLyB0cnVlIGNvbG9yIHRlcm1pbmFscy5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZGVub2xhbmQvZGVub19zdGQvaXNzdWVzLzI1NzVcbiAgICBiYWNrZ3JvdW5kID0gZmFsc2U7XG4gICAgc3dpdGNoIChkaWZmVHlwZSkge1xuICAgICAgICBjYXNlIERpZmZUeXBlLmFkZGVkOlxuICAgICAgICAgICAgcmV0dXJuIChzKSA9PiBiYWNrZ3JvdW5kID8gYmdHcmVlbih3aGl0ZShzKSkgOiBncmVlbihib2xkKHMpKTtcbiAgICAgICAgY2FzZSBEaWZmVHlwZS5yZW1vdmVkOlxuICAgICAgICAgICAgcmV0dXJuIChzKSA9PiBiYWNrZ3JvdW5kID8gYmdSZWQod2hpdGUocykpIDogcmVkKGJvbGQocykpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHdoaXRlO1xuICAgIH1cbn1cbi8qKlxuICogUHJlZml4ZXMgYCtgIG9yIGAtYCBpbiBkaWZmIG91dHB1dFxuICogQHBhcmFtIGRpZmZUeXBlIERpZmZlcmVuY2UgdHlwZSwgZWl0aGVyIGFkZGVkIG9yIHJlbW92ZWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlU2lnbihkaWZmVHlwZSkge1xuICAgIHN3aXRjaCAoZGlmZlR5cGUpIHtcbiAgICAgICAgY2FzZSBEaWZmVHlwZS5hZGRlZDpcbiAgICAgICAgICAgIHJldHVybiBcIisgICBcIjtcbiAgICAgICAgY2FzZSBEaWZmVHlwZS5yZW1vdmVkOlxuICAgICAgICAgICAgcmV0dXJuIFwiLSAgIFwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFwiICAgIFwiO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBidWlsZE1lc3NhZ2UoZGlmZlJlc3VsdCwgeyBzdHJpbmdEaWZmID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgY29uc3QgbWVzc2FnZXMgPSBbXSwgZGlmZk1lc3NhZ2VzID0gW107XG4gICAgbWVzc2FnZXMucHVzaChcIlwiKTtcbiAgICBtZXNzYWdlcy5wdXNoKFwiXCIpO1xuICAgIG1lc3NhZ2VzLnB1c2goYCAgICAke2dyYXkoYm9sZChcIltEaWZmXVwiKSl9ICR7cmVkKGJvbGQoXCJBY3R1YWxcIikpfSAvICR7Z3JlZW4oYm9sZChcIkV4cGVjdGVkXCIpKX1gKTtcbiAgICBtZXNzYWdlcy5wdXNoKFwiXCIpO1xuICAgIG1lc3NhZ2VzLnB1c2goXCJcIik7XG4gICAgZGlmZlJlc3VsdC5mb3JFYWNoKChyZXN1bHQpID0+IHtcbiAgICAgICAgY29uc3QgYyA9IGNyZWF0ZUNvbG9yKHJlc3VsdC50eXBlKTtcbiAgICAgICAgY29uc3QgbGluZSA9IHJlc3VsdC5kZXRhaWxzPy5tYXAoKGRldGFpbCkgPT4gZGV0YWlsLnR5cGUgIT09IERpZmZUeXBlLmNvbW1vblxuICAgICAgICAgICAgPyBjcmVhdGVDb2xvcihkZXRhaWwudHlwZSwgeyBiYWNrZ3JvdW5kOiB0cnVlIH0pKGRldGFpbC52YWx1ZSlcbiAgICAgICAgICAgIDogZGV0YWlsLnZhbHVlKS5qb2luKFwiXCIpID8/IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgZGlmZk1lc3NhZ2VzLnB1c2goYyhgJHtjcmVhdGVTaWduKHJlc3VsdC50eXBlKX0ke2xpbmV9YCkpO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VzLnB1c2goLi4uKHN0cmluZ0RpZmYgPyBbZGlmZk1lc3NhZ2VzLmpvaW4oXCJcIildIDogZGlmZk1lc3NhZ2VzKSk7XG4gICAgbWVzc2FnZXMucHVzaChcIlwiKTtcbiAgICByZXR1cm4gbWVzc2FnZXM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fZGlmZi5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgMjAxOC0yMDIyIHRoZSBEZW5vIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIE1JVCBsaWNlbnNlLlxuLy8gVGhpcyBtb2R1bGUgaXMgYnJvd3NlciBjb21wYXRpYmxlLlxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgaW5wdXQgaW50byBhIHN0cmluZy4gT2JqZWN0cywgU2V0cyBhbmQgTWFwcyBhcmUgc29ydGVkIHNvIGFzIHRvXG4gKiBtYWtlIHRlc3RzIGxlc3MgZmxha3lcbiAqIEBwYXJhbSB2IFZhbHVlIHRvIGJlIGZvcm1hdHRlZFxuICovXG5pbXBvcnQgKiBhcyBkbnRTaGltIGZyb20gXCIuLi8uLi8uLi8uLi9fZG50LnNoaW1zLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0KHYpIHtcbiAgICAvLyBkZW5vLWxpbnQtaWdub3JlIG5vLWV4cGxpY2l0LWFueVxuICAgIGNvbnN0IHsgRGVubyB9ID0gZG50U2hpbS5kbnRHbG9iYWxUaGlzO1xuICAgIHJldHVybiB0eXBlb2YgRGVubz8uaW5zcGVjdCA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgID8gRGVuby5pbnNwZWN0KHYsIHtcbiAgICAgICAgICAgIGRlcHRoOiBJbmZpbml0eSxcbiAgICAgICAgICAgIHNvcnRlZDogdHJ1ZSxcbiAgICAgICAgICAgIHRyYWlsaW5nQ29tbWE6IHRydWUsXG4gICAgICAgICAgICBjb21wYWN0OiBmYWxzZSxcbiAgICAgICAgICAgIGl0ZXJhYmxlTGltaXQ6IEluZmluaXR5LFxuICAgICAgICAgICAgLy8gZ2V0dGVycyBzaG91bGQgYmUgdHJ1ZSBpbiBhc3NlcnRFcXVhbHMuXG4gICAgICAgICAgICBnZXR0ZXJzOiB0cnVlLFxuICAgICAgICB9KVxuICAgICAgICA6IGBcIiR7U3RyaW5nKHYpLnJlcGxhY2UoLyg/PVtcIlxcXFxdKS9nLCBcIlxcXFxcIil9XCJgO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X2Zvcm1hdC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgMjAxOC0yMDIyIHRoZSBEZW5vIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIE1JVCBsaWNlbnNlLlxuLyoqIEEgbGlicmFyeSBvZiBhc3NlcnRpb24gZnVuY3Rpb25zLlxuICpcbiAqIFRoaXMgbW9kdWxlIGlzIGJyb3dzZXIgY29tcGF0aWJsZSwgYnV0IGRvIG5vdCByZWx5IG9uIGdvb2QgZm9ybWF0dGluZyBvZlxuICogdmFsdWVzIGZvciBBc3NlcnRpb25FcnJvciBtZXNzYWdlcyBpbiBicm93c2Vycy5cbiAqXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCB7IHJlZCwgc3RyaXBDb2xvciB9IGZyb20gXCIuLi9mbXQvY29sb3JzLmpzXCI7XG5pbXBvcnQgeyBidWlsZE1lc3NhZ2UsIGRpZmYsIGRpZmZzdHIgfSBmcm9tIFwiLi9fZGlmZi5qc1wiO1xuaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSBcIi4vX2Zvcm1hdC5qc1wiO1xuY29uc3QgQ0FOX05PVF9ESVNQTEFZID0gXCJbQ2Fubm90IGRpc3BsYXldXCI7XG5leHBvcnQgY2xhc3MgQXNzZXJ0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJBc3NlcnRpb25FcnJvclwiXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzS2V5ZWRDb2xsZWN0aW9uKHgpIHtcbiAgICByZXR1cm4gW1N5bWJvbC5pdGVyYXRvciwgXCJzaXplXCJdLmV2ZXJ5KChrKSA9PiBrIGluIHgpO1xufVxuLyoqXG4gKiBEZWVwIGVxdWFsaXR5IGNvbXBhcmlzb24gdXNlZCBpbiBhc3NlcnRpb25zXG4gKiBAcGFyYW0gYyBhY3R1YWwgdmFsdWVcbiAqIEBwYXJhbSBkIGV4cGVjdGVkIHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbChjLCBkKSB7XG4gICAgY29uc3Qgc2VlbiA9IG5ldyBNYXAoKTtcbiAgICByZXR1cm4gKGZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAgICAgICAvLyBIYXZlIHRvIHJlbmRlciBSZWdFeHAgJiBEYXRlIGZvciBzdHJpbmcgY29tcGFyaXNvblxuICAgICAgICAvLyB1bmxlc3MgaXQncyBtaXN0cmVhdGVkIGFzIG9iamVjdFxuICAgICAgICBpZiAoYSAmJlxuICAgICAgICAgICAgYiAmJlxuICAgICAgICAgICAgKChhIGluc3RhbmNlb2YgUmVnRXhwICYmIGIgaW5zdGFuY2VvZiBSZWdFeHApIHx8XG4gICAgICAgICAgICAgICAgKGEgaW5zdGFuY2VvZiBVUkwgJiYgYiBpbnN0YW5jZW9mIFVSTCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBEYXRlICYmIGIgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICBjb25zdCBhVGltZSA9IGEuZ2V0VGltZSgpO1xuICAgICAgICAgICAgY29uc3QgYlRpbWUgPSBiLmdldFRpbWUoKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBOYU4gZXF1YWxpdHkgbWFudWFsbHkgc2luY2UgTmFOIGlzIG5vdFxuICAgICAgICAgICAgLy8gZXF1YWwgdG8gaXRzZWxmLlxuICAgICAgICAgICAgaWYgKE51bWJlci5pc05hTihhVGltZSkgJiYgTnVtYmVyLmlzTmFOKGJUaW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFUaW1lID09PSBiVGltZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGEgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIGIgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIuaXNOYU4oYSkgJiYgTnVtYmVyLmlzTmFOKGIpIHx8IGEgPT09IGI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdC5pcyhhLCBiKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEgJiYgdHlwZW9mIGEgPT09IFwib2JqZWN0XCIgJiYgYiAmJiB0eXBlb2YgYiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWYgKGEgJiYgYiAmJiAhY29uc3RydWN0b3JzRXF1YWwoYSwgYikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYSBpbnN0YW5jZW9mIFdlYWtNYXAgfHwgYiBpbnN0YW5jZW9mIFdlYWtNYXApIHtcbiAgICAgICAgICAgICAgICBpZiAoIShhIGluc3RhbmNlb2YgV2Vha01hcCAmJiBiIGluc3RhbmNlb2YgV2Vha01hcCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2Fubm90IGNvbXBhcmUgV2Vha01hcCBpbnN0YW5jZXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYSBpbnN0YW5jZW9mIFdlYWtTZXQgfHwgYiBpbnN0YW5jZW9mIFdlYWtTZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShhIGluc3RhbmNlb2YgV2Vha1NldCAmJiBiIGluc3RhbmNlb2YgV2Vha1NldCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2Fubm90IGNvbXBhcmUgV2Vha1NldCBpbnN0YW5jZXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2Vlbi5nZXQoYSkgPT09IGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhhIHx8IHt9KS5sZW5ndGggIT09IE9iamVjdC5rZXlzKGIgfHwge30pLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlZW4uc2V0KGEsIGIpO1xuICAgICAgICAgICAgaWYgKGlzS2V5ZWRDb2xsZWN0aW9uKGEpICYmIGlzS2V5ZWRDb2xsZWN0aW9uKGIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHVubWF0Y2hlZEVudHJpZXMgPSBhLnNpemU7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbYUtleSwgYVZhbHVlXSBvZiBhLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtiS2V5LCBiVmFsdWVdIG9mIGIuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBHaXZlbiB0aGF0IE1hcCBrZXlzIGNhbiBiZSByZWZlcmVuY2VzLCB3ZSBuZWVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiB0byBlbnN1cmUgdGhhdCB0aGV5IGFyZSBhbHNvIGRlZXBseSBlcXVhbCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChhS2V5ID09PSBhVmFsdWUgJiYgYktleSA9PT0gYlZhbHVlICYmIGNvbXBhcmUoYUtleSwgYktleSkpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNvbXBhcmUoYUtleSwgYktleSkgJiYgY29tcGFyZShhVmFsdWUsIGJWYWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5tYXRjaGVkRW50cmllcy0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB1bm1hdGNoZWRFbnRyaWVzID09PSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWVyZ2VkID0geyAuLi5hLCAuLi5iIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBbXG4gICAgICAgICAgICAgICAgLi4uT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobWVyZ2VkKSxcbiAgICAgICAgICAgICAgICAuLi5PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG1lcmdlZCksXG4gICAgICAgICAgICBdKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjb21wYXJlKGEgJiYgYVtrZXldLCBiICYmIGJba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKChrZXkgaW4gYSkgJiYgKCEoa2V5IGluIGIpKSkgfHwgKChrZXkgaW4gYikgJiYgKCEoa2V5IGluIGEpKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhIGluc3RhbmNlb2YgV2Vha1JlZiB8fCBiIGluc3RhbmNlb2YgV2Vha1JlZikge1xuICAgICAgICAgICAgICAgIGlmICghKGEgaW5zdGFuY2VvZiBXZWFrUmVmICYmIGIgaW5zdGFuY2VvZiBXZWFrUmVmKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJlKGEuZGVyZWYoKSwgYi5kZXJlZigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KShjLCBkKTtcbn1cbi8vIGRlbm8tbGludC1pZ25vcmUgYmFuLXR5cGVzXG5mdW5jdGlvbiBjb25zdHJ1Y3RvcnNFcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIGEuY29uc3RydWN0b3IgPT09IGIuY29uc3RydWN0b3IgfHxcbiAgICAgICAgYS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0ICYmICFiLmNvbnN0cnVjdG9yIHx8XG4gICAgICAgICFhLmNvbnN0cnVjdG9yICYmIGIuY29uc3RydWN0b3IgPT09IE9iamVjdDtcbn1cbi8qKiBNYWtlIGFuIGFzc2VydGlvbiwgZXJyb3Igd2lsbCBiZSB0aHJvd24gaWYgYGV4cHJgIGRvZXMgbm90IGhhdmUgdHJ1dGh5IHZhbHVlLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydChleHByLCBtc2cgPSBcIlwiKSB7XG4gICAgaWYgKCFleHByKSB7XG4gICAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihtc2cpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRGYWxzZShleHByLCBtc2cgPSBcIlwiKSB7XG4gICAgaWYgKGV4cHIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKG1zZyk7XG4gICAgfVxufVxuLyoqXG4gKiBNYWtlIGFuIGFzc2VydGlvbiB0aGF0IGBhY3R1YWxgIGFuZCBgZXhwZWN0ZWRgIGFyZSBlcXVhbCwgZGVlcGx5LiBJZiBub3RcbiAqIGRlZXBseSBlcXVhbCwgdGhlbiB0aHJvdy5cbiAqXG4gKiBUeXBlIHBhcmFtZXRlciBjYW4gYmUgc3BlY2lmaWVkIHRvIGVuc3VyZSB2YWx1ZXMgdW5kZXIgY29tcGFyaXNvbiBoYXZlIHRoZSBzYW1lIHR5cGUuXG4gKiBGb3IgZXhhbXBsZTpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBhc3NlcnRFcXVhbHMgfSBmcm9tIFwiLi9hc3NlcnRzLnRzXCI7XG4gKlxuICogYXNzZXJ0RXF1YWxzPG51bWJlcj4oMSwgMilcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0RXF1YWxzKGFjdHVhbCwgZXhwZWN0ZWQsIG1zZykge1xuICAgIGlmIChlcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBtZXNzYWdlID0gXCJcIjtcbiAgICBjb25zdCBhY3R1YWxTdHJpbmcgPSBmb3JtYXQoYWN0dWFsKTtcbiAgICBjb25zdCBleHBlY3RlZFN0cmluZyA9IGZvcm1hdChleHBlY3RlZCk7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3RyaW5nRGlmZiA9ICh0eXBlb2YgYWN0dWFsID09PSBcInN0cmluZ1wiKSAmJlxuICAgICAgICAgICAgKHR5cGVvZiBleHBlY3RlZCA9PT0gXCJzdHJpbmdcIik7XG4gICAgICAgIGNvbnN0IGRpZmZSZXN1bHQgPSBzdHJpbmdEaWZmXG4gICAgICAgICAgICA/IGRpZmZzdHIoYWN0dWFsLCBleHBlY3RlZClcbiAgICAgICAgICAgIDogZGlmZihhY3R1YWxTdHJpbmcuc3BsaXQoXCJcXG5cIiksIGV4cGVjdGVkU3RyaW5nLnNwbGl0KFwiXFxuXCIpKTtcbiAgICAgICAgY29uc3QgZGlmZk1zZyA9IGJ1aWxkTWVzc2FnZShkaWZmUmVzdWx0LCB7IHN0cmluZ0RpZmYgfSkuam9pbihcIlxcblwiKTtcbiAgICAgICAgbWVzc2FnZSA9IGBWYWx1ZXMgYXJlIG5vdCBlcXVhbDpcXG4ke2RpZmZNc2d9YDtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICBtZXNzYWdlID0gYFxcbiR7cmVkKENBTl9OT1RfRElTUExBWSl9ICsgXFxuXFxuYDtcbiAgICB9XG4gICAgaWYgKG1zZykge1xuICAgICAgICBtZXNzYWdlID0gbXNnO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IobWVzc2FnZSk7XG59XG4vKipcbiAqIE1ha2UgYW4gYXNzZXJ0aW9uIHRoYXQgYGFjdHVhbGAgYW5kIGBleHBlY3RlZGAgYXJlIG5vdCBlcXVhbCwgZGVlcGx5LlxuICogSWYgbm90IHRoZW4gdGhyb3cuXG4gKlxuICogVHlwZSBwYXJhbWV0ZXIgY2FuIGJlIHNwZWNpZmllZCB0byBlbnN1cmUgdmFsdWVzIHVuZGVyIGNvbXBhcmlzb24gaGF2ZSB0aGUgc2FtZSB0eXBlLlxuICogRm9yIGV4YW1wbGU6XG4gKiBgYGB0c1xuICogaW1wb3J0IHsgYXNzZXJ0Tm90RXF1YWxzIH0gZnJvbSBcIi4vYXNzZXJ0cy50c1wiO1xuICpcbiAqIGFzc2VydE5vdEVxdWFsczxudW1iZXI+KDEsIDIpXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydE5vdEVxdWFscyhhY3R1YWwsIGV4cGVjdGVkLCBtc2cpIHtcbiAgICBpZiAoIWVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGFjdHVhbFN0cmluZztcbiAgICBsZXQgZXhwZWN0ZWRTdHJpbmc7XG4gICAgdHJ5IHtcbiAgICAgICAgYWN0dWFsU3RyaW5nID0gU3RyaW5nKGFjdHVhbCk7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgYWN0dWFsU3RyaW5nID0gXCJbQ2Fubm90IGRpc3BsYXldXCI7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGV4cGVjdGVkU3RyaW5nID0gU3RyaW5nKGV4cGVjdGVkKTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICBleHBlY3RlZFN0cmluZyA9IFwiW0Nhbm5vdCBkaXNwbGF5XVwiO1xuICAgIH1cbiAgICBpZiAoIW1zZykge1xuICAgICAgICBtc2cgPSBgYWN0dWFsOiAke2FjdHVhbFN0cmluZ30gZXhwZWN0ZWQgbm90IHRvIGJlOiAke2V4cGVjdGVkU3RyaW5nfWA7XG4gICAgfVxuICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihtc2cpO1xufVxuLyoqXG4gKiBNYWtlIGFuIGFzc2VydGlvbiB0aGF0IGBhY3R1YWxgIGFuZCBgZXhwZWN0ZWRgIGFyZSBzdHJpY3RseSBlcXVhbC4gSWZcbiAqIG5vdCB0aGVuIHRocm93LlxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBhc3NlcnRTdHJpY3RFcXVhbHMgfSBmcm9tIFwiLi9hc3NlcnRzLnRzXCI7XG4gKlxuICogYXNzZXJ0U3RyaWN0RXF1YWxzKDEsIDIpXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFN0cmljdEVxdWFscyhhY3R1YWwsIGV4cGVjdGVkLCBtc2cpIHtcbiAgICBpZiAoT2JqZWN0LmlzKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IG1lc3NhZ2U7XG4gICAgaWYgKG1zZykge1xuICAgICAgICBtZXNzYWdlID0gbXNnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgYWN0dWFsU3RyaW5nID0gZm9ybWF0KGFjdHVhbCk7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkU3RyaW5nID0gZm9ybWF0KGV4cGVjdGVkKTtcbiAgICAgICAgaWYgKGFjdHVhbFN0cmluZyA9PT0gZXhwZWN0ZWRTdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IHdpdGhPZmZzZXQgPSBhY3R1YWxTdHJpbmdcbiAgICAgICAgICAgICAgICAuc3BsaXQoXCJcXG5cIilcbiAgICAgICAgICAgICAgICAubWFwKChsKSA9PiBgICAgICR7bH1gKVxuICAgICAgICAgICAgICAgIC5qb2luKFwiXFxuXCIpO1xuICAgICAgICAgICAgbWVzc2FnZSA9XG4gICAgICAgICAgICAgICAgYFZhbHVlcyBoYXZlIHRoZSBzYW1lIHN0cnVjdHVyZSBidXQgYXJlIG5vdCByZWZlcmVuY2UtZXF1YWw6XFxuXFxuJHtyZWQod2l0aE9mZnNldCl9XFxuYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5nRGlmZiA9ICh0eXBlb2YgYWN0dWFsID09PSBcInN0cmluZ1wiKSAmJlxuICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGV4cGVjdGVkID09PSBcInN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkaWZmUmVzdWx0ID0gc3RyaW5nRGlmZlxuICAgICAgICAgICAgICAgICAgICA/IGRpZmZzdHIoYWN0dWFsLCBleHBlY3RlZClcbiAgICAgICAgICAgICAgICAgICAgOiBkaWZmKGFjdHVhbFN0cmluZy5zcGxpdChcIlxcblwiKSwgZXhwZWN0ZWRTdHJpbmcuc3BsaXQoXCJcXG5cIikpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpZmZNc2cgPSBidWlsZE1lc3NhZ2UoZGlmZlJlc3VsdCwgeyBzdHJpbmdEaWZmIH0pLmpvaW4oXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBWYWx1ZXMgYXJlIG5vdCBzdHJpY3RseSBlcXVhbDpcXG4ke2RpZmZNc2d9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYFxcbiR7cmVkKENBTl9OT1RfRElTUExBWSl9ICsgXFxuXFxuYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IobWVzc2FnZSk7XG59XG4vKipcbiAqIE1ha2UgYW4gYXNzZXJ0aW9uIHRoYXQgYGFjdHVhbGAgYW5kIGBleHBlY3RlZGAgYXJlIG5vdCBzdHJpY3RseSBlcXVhbC5cbiAqIElmIHRoZSB2YWx1ZXMgYXJlIHN0cmljdGx5IGVxdWFsIHRoZW4gdGhyb3cuXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGFzc2VydE5vdFN0cmljdEVxdWFscyB9IGZyb20gXCIuL2Fzc2VydHMudHNcIjtcbiAqXG4gKiBhc3NlcnROb3RTdHJpY3RFcXVhbHMoMSwgMSlcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0Tm90U3RyaWN0RXF1YWxzKGFjdHVhbCwgZXhwZWN0ZWQsIG1zZykge1xuICAgIGlmICghT2JqZWN0LmlzKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKG1zZyA/PyBgRXhwZWN0ZWQgXCJhY3R1YWxcIiB0byBiZSBzdHJpY3RseSB1bmVxdWFsIHRvOiAke2Zvcm1hdChhY3R1YWwpfVxcbmApO1xufVxuLyoqXG4gKiBNYWtlIGFuIGFzc2VydGlvbiB0aGF0IGBhY3R1YWxgIGFuZCBgZXhwZWN0ZWRgIGFyZSBhbG1vc3QgZXF1YWwgbnVtYmVycyB0aHJvdWdoXG4gKiBhIGdpdmVuIHRvbGVyYW5jZS4gSXQgY2FuIGJlIHVzZWQgdG8gdGFrZSBpbnRvIGFjY291bnQgSUVFRS03NTQgZG91YmxlLXByZWNpc2lvblxuICogZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gbGltaXRhdGlvbnMuXG4gKiBJZiB0aGUgdmFsdWVzIGFyZSBub3QgYWxtb3N0IGVxdWFsIHRoZW4gdGhyb3cuXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGFzc2VydEFsbW9zdEVxdWFscywgYXNzZXJ0VGhyb3dzIH0gZnJvbSBcIi4vYXNzZXJ0cy50c1wiO1xuICpcbiAqIGFzc2VydEFsbW9zdEVxdWFscygwLjEsIDAuMik7XG4gKlxuICogLy8gVXNpbmcgYSBjdXN0b20gdG9sZXJhbmNlIHZhbHVlXG4gKiBhc3NlcnRBbG1vc3RFcXVhbHMoMC4xICsgMC4yLCAwLjMsIDFlLTE2KTtcbiAqIGFzc2VydFRocm93cygoKSA9PiBhc3NlcnRBbG1vc3RFcXVhbHMoMC4xICsgMC4yLCAwLjMsIDFlLTE3KSk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEFsbW9zdEVxdWFscyhhY3R1YWwsIGV4cGVjdGVkLCB0b2xlcmFuY2UgPSAxZS03LCBtc2cpIHtcbiAgICBpZiAoT2JqZWN0LmlzKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGVsdGEgPSBNYXRoLmFicyhleHBlY3RlZCAtIGFjdHVhbCk7XG4gICAgaWYgKGRlbHRhIDw9IHRvbGVyYW5jZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGYgPSAobikgPT4gTnVtYmVyLmlzSW50ZWdlcihuKSA/IG4gOiBuLnRvRXhwb25lbnRpYWwoKTtcbiAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IobXNnID8/XG4gICAgICAgIGBhY3R1YWw6IFwiJHtmKGFjdHVhbCl9XCIgZXhwZWN0ZWQgdG8gYmUgY2xvc2UgdG8gXCIke2YoZXhwZWN0ZWQpfVwiOiBcXFxuZGVsdGEgXCIke2YoZGVsdGEpfVwiIGlzIGdyZWF0ZXIgdGhhbiBcIiR7Zih0b2xlcmFuY2UpfVwiYCk7XG59XG4vKipcbiAqIE1ha2UgYW4gYXNzZXJ0aW9uIHRoYXQgYG9iamAgaXMgYW4gaW5zdGFuY2Ugb2YgYHR5cGVgLlxuICogSWYgbm90IHRoZW4gdGhyb3cuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRJbnN0YW5jZU9mKGFjdHVhbCwgZXhwZWN0ZWRUeXBlLCBtc2cgPSBcIlwiKSB7XG4gICAgaWYgKCFtc2cpIHtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRUeXBlU3RyID0gZXhwZWN0ZWRUeXBlLm5hbWU7XG4gICAgICAgIGxldCBhY3R1YWxUeXBlU3RyID0gXCJcIjtcbiAgICAgICAgaWYgKGFjdHVhbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgYWN0dWFsVHlwZVN0ciA9IFwibnVsbFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFjdHVhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhY3R1YWxUeXBlU3RyID0gXCJ1bmRlZmluZWRcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYWN0dWFsID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBhY3R1YWxUeXBlU3RyID0gYWN0dWFsLmNvbnN0cnVjdG9yPy5uYW1lID8/IFwiT2JqZWN0XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhY3R1YWxUeXBlU3RyID0gdHlwZW9mIGFjdHVhbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwZWN0ZWRUeXBlU3RyID09IGFjdHVhbFR5cGVTdHIpIHtcbiAgICAgICAgICAgIG1zZyA9IGBFeHBlY3RlZCBvYmplY3QgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgXCIke2V4cGVjdGVkVHlwZVN0cn1cIi5gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFjdHVhbFR5cGVTdHIgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBtc2cgPVxuICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBvYmplY3QgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgXCIke2V4cGVjdGVkVHlwZVN0cn1cIiBidXQgd2FzIG5vdCBhbiBpbnN0YW5jZWQgb2JqZWN0LmA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtc2cgPVxuICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBvYmplY3QgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgXCIke2V4cGVjdGVkVHlwZVN0cn1cIiBidXQgd2FzIFwiJHthY3R1YWxUeXBlU3RyfVwiLmA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXNzZXJ0KGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkVHlwZSwgbXNnKTtcbn1cbi8qKlxuICogTWFrZSBhbiBhc3NlcnRpb24gdGhhdCBgb2JqYCBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgYHR5cGVgLlxuICogSWYgc28sIHRoZW4gdGhyb3cuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnROb3RJbnN0YW5jZU9mKGFjdHVhbCwgXG4vLyBkZW5vLWxpbnQtaWdub3JlIG5vLWV4cGxpY2l0LWFueVxudW5leHBlY3RlZFR5cGUsIG1zZyA9IGBFeHBlY3RlZCBvYmplY3QgdG8gbm90IGJlIGFuIGluc3RhbmNlIG9mIFwiJHt0eXBlb2YgdW5leHBlY3RlZFR5cGV9XCJgKSB7XG4gICAgYXNzZXJ0RmFsc2UoYWN0dWFsIGluc3RhbmNlb2YgdW5leHBlY3RlZFR5cGUsIG1zZyk7XG59XG4vKipcbiAqIE1ha2UgYW4gYXNzZXJ0aW9uIHRoYXQgYWN0dWFsIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZC5cbiAqIElmIG5vdCB0aGVuIHRocm93LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0RXhpc3RzKGFjdHVhbCwgbXNnKSB7XG4gICAgaWYgKGFjdHVhbCA9PT0gdW5kZWZpbmVkIHx8IGFjdHVhbCA9PT0gbnVsbCkge1xuICAgICAgICBpZiAoIW1zZykge1xuICAgICAgICAgICAgbXNnID0gYGFjdHVhbDogXCIke2FjdHVhbH1cIiBleHBlY3RlZCB0byBub3QgYmUgbnVsbCBvciB1bmRlZmluZWRgO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihtc2cpO1xuICAgIH1cbn1cbi8qKlxuICogTWFrZSBhbiBhc3NlcnRpb24gdGhhdCBhY3R1YWwgaW5jbHVkZXMgZXhwZWN0ZWQuIElmIG5vdFxuICogdGhlbiB0aHJvdy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFN0cmluZ0luY2x1ZGVzKGFjdHVhbCwgZXhwZWN0ZWQsIG1zZykge1xuICAgIGlmICghYWN0dWFsLmluY2x1ZGVzKGV4cGVjdGVkKSkge1xuICAgICAgICBpZiAoIW1zZykge1xuICAgICAgICAgICAgbXNnID0gYGFjdHVhbDogXCIke2FjdHVhbH1cIiBleHBlY3RlZCB0byBjb250YWluOiBcIiR7ZXhwZWN0ZWR9XCJgO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihtc2cpO1xuICAgIH1cbn1cbi8qKlxuICogTWFrZSBhbiBhc3NlcnRpb24gdGhhdCBgYWN0dWFsYCBpbmNsdWRlcyB0aGUgYGV4cGVjdGVkYCB2YWx1ZXMuXG4gKiBJZiBub3QgdGhlbiBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAqXG4gKiBUeXBlIHBhcmFtZXRlciBjYW4gYmUgc3BlY2lmaWVkIHRvIGVuc3VyZSB2YWx1ZXMgdW5kZXIgY29tcGFyaXNvbiBoYXZlIHRoZSBzYW1lIHR5cGUuXG4gKiBGb3IgZXhhbXBsZTpcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgYXNzZXJ0QXJyYXlJbmNsdWRlcyB9IGZyb20gXCIuL2Fzc2VydHMudHNcIjtcbiAqXG4gKiBhc3NlcnRBcnJheUluY2x1ZGVzPG51bWJlcj4oWzEsIDJdLCBbMl0pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEFycmF5SW5jbHVkZXMoYWN0dWFsLCBleHBlY3RlZCwgbXNnKSB7XG4gICAgY29uc3QgbWlzc2luZyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwZWN0ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYWN0dWFsLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoZXF1YWwoZXhwZWN0ZWRbaV0sIGFjdHVhbFtqXSkpIHtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgbWlzc2luZy5wdXNoKGV4cGVjdGVkW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobWlzc2luZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIW1zZykge1xuICAgICAgICBtc2cgPSBgYWN0dWFsOiBcIiR7Zm9ybWF0KGFjdHVhbCl9XCIgZXhwZWN0ZWQgdG8gaW5jbHVkZTogXCIke2Zvcm1hdChleHBlY3RlZCl9XCJcXG5taXNzaW5nOiAke2Zvcm1hdChtaXNzaW5nKX1gO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IobXNnKTtcbn1cbi8qKlxuICogTWFrZSBhbiBhc3NlcnRpb24gdGhhdCBgYWN0dWFsYCBtYXRjaCBSZWdFeHAgYGV4cGVjdGVkYC4gSWYgbm90XG4gKiB0aGVuIHRocm93LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0TWF0Y2goYWN0dWFsLCBleHBlY3RlZCwgbXNnKSB7XG4gICAgaWYgKCFleHBlY3RlZC50ZXN0KGFjdHVhbCkpIHtcbiAgICAgICAgaWYgKCFtc2cpIHtcbiAgICAgICAgICAgIG1zZyA9IGBhY3R1YWw6IFwiJHthY3R1YWx9XCIgZXhwZWN0ZWQgdG8gbWF0Y2g6IFwiJHtleHBlY3RlZH1cImA7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKG1zZyk7XG4gICAgfVxufVxuLyoqXG4gKiBNYWtlIGFuIGFzc2VydGlvbiB0aGF0IGBhY3R1YWxgIG5vdCBtYXRjaCBSZWdFeHAgYGV4cGVjdGVkYC4gSWYgbWF0Y2hcbiAqIHRoZW4gdGhyb3cuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnROb3RNYXRjaChhY3R1YWwsIGV4cGVjdGVkLCBtc2cpIHtcbiAgICBpZiAoZXhwZWN0ZWQudGVzdChhY3R1YWwpKSB7XG4gICAgICAgIGlmICghbXNnKSB7XG4gICAgICAgICAgICBtc2cgPSBgYWN0dWFsOiBcIiR7YWN0dWFsfVwiIGV4cGVjdGVkIHRvIG5vdCBtYXRjaDogXCIke2V4cGVjdGVkfVwiYDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IobXNnKTtcbiAgICB9XG59XG4vKipcbiAqIE1ha2UgYW4gYXNzZXJ0aW9uIHRoYXQgYGFjdHVhbGAgb2JqZWN0IGlzIGEgc3Vic2V0IG9mIGBleHBlY3RlZGAgb2JqZWN0LCBkZWVwbHkuXG4gKiBJZiBub3QsIHRoZW4gdGhyb3cuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRPYmplY3RNYXRjaChcbi8vIGRlbm8tbGludC1pZ25vcmUgbm8tZXhwbGljaXQtYW55XG5hY3R1YWwsIGV4cGVjdGVkKSB7XG4gICAgZnVuY3Rpb24gZmlsdGVyKGEsIGIpIHtcbiAgICAgICAgY29uc3Qgc2VlbiA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIHJldHVybiBmbihhLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gZm4oYSwgYikge1xuICAgICAgICAgICAgLy8gUHJldmVudCBpbmZpbml0ZSBsb29wIHdpdGggY2lyY3VsYXIgcmVmZXJlbmNlcyB3aXRoIHNhbWUgZmlsdGVyXG4gICAgICAgICAgICBpZiAoKHNlZW4uaGFzKGEpKSAmJiAoc2Vlbi5nZXQoYSkgPT09IGIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWVuLnNldChhLCBiKTtcbiAgICAgICAgICAgIC8vIEZpbHRlciBrZXlzIGFuZCBzeW1ib2xzIHdoaWNoIGFyZSBwcmVzZW50IGluIGJvdGggYWN0dWFsIGFuZCBleHBlY3RlZFxuICAgICAgICAgICAgY29uc3QgZmlsdGVyZWQgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGVudHJpZXMgPSBbXG4gICAgICAgICAgICAgICAgLi4uT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYSksXG4gICAgICAgICAgICAgICAgLi4uT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhhKSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAuZmlsdGVyKChrZXkpID0+IGtleSBpbiBiKVxuICAgICAgICAgICAgICAgIC5tYXAoKGtleSkgPT4gW2tleSwgYVtrZXldXSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgLy8gT24gYXJyYXkgcmVmZXJlbmNlcywgYnVpbGQgYSBmaWx0ZXJlZCBhcnJheSBhbmQgZmlsdGVyIG5lc3RlZCBvYmplY3RzIGluc2lkZVxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWJzZXQgPSBiW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHN1YnNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkW2tleV0gPSBmbih7IC4uLnZhbHVlIH0sIHsgLi4uc3Vic2V0IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIE9uIHJlZ2V4cCByZWZlcmVuY2VzLCBrZWVwIHZhbHVlIGFzIGl0IHRvIGF2b2lkIGxvb3NpbmcgcGF0dGVybiBhbmQgZmxhZ3NcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH0gLy8gT24gbmVzdGVkIG9iamVjdHMgcmVmZXJlbmNlcywgYnVpbGQgYSBmaWx0ZXJlZCBvYmplY3QgcmVjdXJzaXZlbHlcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3Vic2V0ID0gYltrZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHR5cGVvZiBzdWJzZXQgPT09IFwib2JqZWN0XCIpICYmIChzdWJzZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGJvdGggb3BlcmFuZHMgYXJlIG1hcHMsIGJ1aWxkIGEgZmlsdGVyZWQgbWFwIHdpdGggY29tbW9uIGtleXMgYW5kIGZpbHRlciBuZXN0ZWQgb2JqZWN0cyBpbnNpZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodmFsdWUgaW5zdGFuY2VvZiBNYXApICYmIChzdWJzZXQgaW5zdGFuY2VvZiBNYXApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWRba2V5XSA9IG5ldyBNYXAoWy4uLnZhbHVlXS5maWx0ZXIoKFtrXSkgPT4gc3Vic2V0LmhhcyhrKSkubWFwKChbaywgdl0pID0+IFtrLCB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiA/IGZuKHYsIHN1YnNldC5nZXQoaykpIDogdl0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gYm90aCBvcGVyYW5kcyBhcmUgc2V0LCBidWlsZCBhIGZpbHRlcmVkIHNldCB3aXRoIGNvbW1vbiB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodmFsdWUgaW5zdGFuY2VvZiBTZXQpICYmIChzdWJzZXQgaW5zdGFuY2VvZiBTZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWRba2V5XSA9IG5ldyBTZXQoWy4uLnZhbHVlXS5maWx0ZXIoKHYpID0+IHN1YnNldC5oYXModikpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkW2tleV0gPSBmbih2YWx1ZSwgc3Vic2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbHRlcmVkW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXNzZXJ0RXF1YWxzKFxuICAgIC8vIGdldCB0aGUgaW50ZXJzZWN0aW9uIG9mIFwiYWN0dWFsXCIgYW5kIFwiZXhwZWN0ZWRcIlxuICAgIC8vIHNpZGUgZWZmZWN0OiBhbGwgdGhlIGluc3RhbmNlcycgY29uc3RydWN0b3IgZmllbGQgaXMgXCJPYmplY3RcIiBub3cuXG4gICAgZmlsdGVyKGFjdHVhbCwgZXhwZWN0ZWQpLCBcbiAgICAvLyBzZXQgKG5lc3RlZCkgaW5zdGFuY2VzJyBjb25zdHJ1Y3RvciBmaWVsZCB0byBiZSBcIk9iamVjdFwiIHdpdGhvdXQgY2hhbmdpbmcgZXhwZWN0ZWQgdmFsdWUuXG4gICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9kZW5vbGFuZC9kZW5vX3N0ZC9wdWxsLzE0MTlcbiAgICBmaWx0ZXIoZXhwZWN0ZWQsIGV4cGVjdGVkKSk7XG59XG4vKipcbiAqIEZvcmNlZnVsbHkgdGhyb3dzIGEgZmFpbGVkIGFzc2VydGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gZmFpbChtc2cpIHtcbiAgICBhc3NlcnQoZmFsc2UsIGBGYWlsZWQgYXNzZXJ0aW9uJHttc2cgPyBgOiAke21zZ31gIDogXCIuXCJ9YCk7XG59XG4vKipcbiAqIE1ha2UgYW4gYXNzZXJ0aW9uIHRoYXQgYGVycm9yYCBpcyBhbiBgRXJyb3JgLlxuICogSWYgbm90IHRoZW4gYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gKiBBbiBlcnJvciBjbGFzcyBhbmQgYSBzdHJpbmcgdGhhdCBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlXG4gKiBlcnJvciBtZXNzYWdlIGNhbiBhbHNvIGJlIGFzc2VydGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0SXNFcnJvcihlcnJvciwgXG4vLyBkZW5vLWxpbnQtaWdub3JlIG5vLWV4cGxpY2l0LWFueVxuRXJyb3JDbGFzcywgbXNnSW5jbHVkZXMsIG1zZykge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yID09PSBmYWxzZSkge1xuICAgICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IoYEV4cGVjdGVkIFwiZXJyb3JcIiB0byBiZSBhbiBFcnJvciBvYmplY3QuYCk7XG4gICAgfVxuICAgIGlmIChFcnJvckNsYXNzICYmICEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvckNsYXNzKSkge1xuICAgICAgICBtc2cgPSBgRXhwZWN0ZWQgZXJyb3IgdG8gYmUgaW5zdGFuY2Ugb2YgXCIke0Vycm9yQ2xhc3MubmFtZX1cIiwgYnV0IHdhcyBcIiR7dHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiID8gZXJyb3I/LmNvbnN0cnVjdG9yPy5uYW1lIDogXCJbbm90IGFuIG9iamVjdF1cIn1cIiR7bXNnID8gYDogJHttc2d9YCA6IFwiLlwifWA7XG4gICAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihtc2cpO1xuICAgIH1cbiAgICBpZiAobXNnSW5jbHVkZXMgJiYgKCEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikgfHxcbiAgICAgICAgIXN0cmlwQ29sb3IoZXJyb3IubWVzc2FnZSkuaW5jbHVkZXMoc3RyaXBDb2xvcihtc2dJbmNsdWRlcykpKSkge1xuICAgICAgICBtc2cgPSBgRXhwZWN0ZWQgZXJyb3IgbWVzc2FnZSB0byBpbmNsdWRlIFwiJHttc2dJbmNsdWRlc31cIiwgYnV0IGdvdCBcIiR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIltub3QgYW4gRXJyb3JdXCJ9XCIke21zZyA/IGA6ICR7bXNnfWAgOiBcIi5cIn1gO1xuICAgICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IobXNnKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0VGhyb3dzKGZuLCBlcnJvckNsYXNzT3JDYWxsYmFja09yTXNnLCBtc2dJbmNsdWRlc09yTXNnLCBtc2cpIHtcbiAgICAvLyBkZW5vLWxpbnQtaWdub3JlIG5vLWV4cGxpY2l0LWFueVxuICAgIGxldCBFcnJvckNsYXNzID0gdW5kZWZpbmVkO1xuICAgIGxldCBtc2dJbmNsdWRlcyA9IHVuZGVmaW5lZDtcbiAgICBsZXQgZXJyb3JDYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgICBsZXQgZXJyO1xuICAgIGlmICh0eXBlb2YgZXJyb3JDbGFzc09yQ2FsbGJhY2tPck1zZyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoZXJyb3JDbGFzc09yQ2FsbGJhY2tPck1zZyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBlcnJvckNsYXNzT3JDYWxsYmFja09yTXNnLnByb3RvdHlwZSBpbnN0YW5jZW9mIEVycm9yIHx8XG4gICAgICAgICAgICBlcnJvckNsYXNzT3JDYWxsYmFja09yTXNnLnByb3RvdHlwZSA9PT0gRXJyb3IucHJvdG90eXBlKSB7XG4gICAgICAgICAgICAvLyBkZW5vLWxpbnQtaWdub3JlIG5vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgRXJyb3JDbGFzcyA9IGVycm9yQ2xhc3NPckNhbGxiYWNrT3JNc2c7XG4gICAgICAgICAgICBtc2dJbmNsdWRlcyA9IG1zZ0luY2x1ZGVzT3JNc2c7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlcnJvckNhbGxiYWNrID0gZXJyb3JDbGFzc09yQ2FsbGJhY2tPck1zZztcbiAgICAgICAgICAgIG1zZyA9IG1zZ0luY2x1ZGVzT3JNc2c7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1zZyA9IGVycm9yQ2xhc3NPckNhbGxiYWNrT3JNc2c7XG4gICAgfVxuICAgIGxldCBkb2VzVGhyb3cgPSBmYWxzZTtcbiAgICBjb25zdCBtc2dUb0FwcGVuZFRvRXJyb3IgPSBtc2cgPyBgOiAke21zZ31gIDogXCIuXCI7XG4gICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChFcnJvckNsYXNzIHx8IGVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihcIkEgbm9uLUVycm9yIG9iamVjdCB3YXMgdGhyb3duLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydElzRXJyb3IoZXJyb3IsIEVycm9yQ2xhc3MsIG1zZ0luY2x1ZGVzLCBtc2cpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlcnJvckNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBlcnJvckNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlcnIgPSBlcnJvcjtcbiAgICAgICAgZG9lc1Rocm93ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFkb2VzVGhyb3cpIHtcbiAgICAgICAgbXNnID0gYEV4cGVjdGVkIGZ1bmN0aW9uIHRvIHRocm93JHttc2dUb0FwcGVuZFRvRXJyb3J9YDtcbiAgICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKG1zZyk7XG4gICAgfVxuICAgIHJldHVybiBlcnI7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXNzZXJ0UmVqZWN0cyhmbiwgZXJyb3JDbGFzc09yQ2FsbGJhY2tPck1zZywgbXNnSW5jbHVkZXNPck1zZywgbXNnKSB7XG4gICAgLy8gZGVuby1saW50LWlnbm9yZSBuby1leHBsaWNpdC1hbnlcbiAgICBsZXQgRXJyb3JDbGFzcyA9IHVuZGVmaW5lZDtcbiAgICBsZXQgbXNnSW5jbHVkZXMgPSB1bmRlZmluZWQ7XG4gICAgbGV0IGVycm9yQ2FsbGJhY2sgPSB1bmRlZmluZWQ7XG4gICAgbGV0IGVycjtcbiAgICBpZiAodHlwZW9mIGVycm9yQ2xhc3NPckNhbGxiYWNrT3JNc2cgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKGVycm9yQ2xhc3NPckNhbGxiYWNrT3JNc2cgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgZXJyb3JDbGFzc09yQ2FsbGJhY2tPck1zZy5wcm90b3R5cGUgaW5zdGFuY2VvZiBFcnJvciB8fFxuICAgICAgICAgICAgZXJyb3JDbGFzc09yQ2FsbGJhY2tPck1zZy5wcm90b3R5cGUgPT09IEVycm9yLnByb3RvdHlwZSkge1xuICAgICAgICAgICAgLy8gZGVuby1saW50LWlnbm9yZSBuby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIEVycm9yQ2xhc3MgPSBlcnJvckNsYXNzT3JDYWxsYmFja09yTXNnO1xuICAgICAgICAgICAgbXNnSW5jbHVkZXMgPSBtc2dJbmNsdWRlc09yTXNnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXJyb3JDYWxsYmFjayA9IGVycm9yQ2xhc3NPckNhbGxiYWNrT3JNc2c7XG4gICAgICAgICAgICBtc2cgPSBtc2dJbmNsdWRlc09yTXNnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBtc2cgPSBlcnJvckNsYXNzT3JDYWxsYmFja09yTXNnO1xuICAgIH1cbiAgICBsZXQgZG9lc1Rocm93ID0gZmFsc2U7XG4gICAgbGV0IGlzUHJvbWlzZVJldHVybmVkID0gZmFsc2U7XG4gICAgY29uc3QgbXNnVG9BcHBlbmRUb0Vycm9yID0gbXNnID8gYDogJHttc2d9YCA6IFwiLlwiO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBvc3NpYmxlUHJvbWlzZSA9IGZuKCk7XG4gICAgICAgIGlmIChwb3NzaWJsZVByb21pc2UgJiZcbiAgICAgICAgICAgIHR5cGVvZiBwb3NzaWJsZVByb21pc2UgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIHR5cGVvZiBwb3NzaWJsZVByb21pc2UudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBpc1Byb21pc2VSZXR1cm5lZCA9IHRydWU7XG4gICAgICAgICAgICBhd2FpdCBwb3NzaWJsZVByb21pc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmICghaXNQcm9taXNlUmV0dXJuZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihgRnVuY3Rpb24gdGhyb3dzIHdoZW4gZXhwZWN0ZWQgdG8gcmVqZWN0JHttc2dUb0FwcGVuZFRvRXJyb3J9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEVycm9yQ2xhc3MgfHwgZXJyb3JDYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKFwiQSBub24tRXJyb3Igb2JqZWN0IHdhcyByZWplY3RlZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRJc0Vycm9yKGVycm9yLCBFcnJvckNsYXNzLCBtc2dJbmNsdWRlcywgbXNnKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3JDYWxsYmFjayA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBlcnJvckNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlcnIgPSBlcnJvcjtcbiAgICAgICAgZG9lc1Rocm93ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFkb2VzVGhyb3cpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKGBFeHBlY3RlZCBmdW5jdGlvbiB0byByZWplY3Qke21zZ1RvQXBwZW5kVG9FcnJvcn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycjtcbn1cbi8qKiBVc2UgdGhpcyB0byBzdHViIG91dCBtZXRob2RzIHRoYXQgd2lsbCB0aHJvdyB3aGVuIGludm9rZWQuICovXG5leHBvcnQgZnVuY3Rpb24gdW5pbXBsZW1lbnRlZChtc2cpIHtcbiAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IobXNnIHx8IFwidW5pbXBsZW1lbnRlZFwiKTtcbn1cbi8qKiBVc2UgdGhpcyB0byBhc3NlcnQgdW5yZWFjaGFibGUgY29kZS4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bnJlYWNoYWJsZSgpIHtcbiAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IoXCJ1bnJlYWNoYWJsZVwiKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzc2VydHMuanMubWFwIiwiaW1wb3J0ICogYXMgTSBmcm9tIFwiLi4vLi4vZnJhbWVfbWV0YWRhdGEvbW9kLmpzXCI7XG5pbXBvcnQgeyBhdG9tRmFjdG9yeSB9IGZyb20gXCIuLi9zeXMvQXRvbS5qc1wiO1xuZXhwb3J0IGNvbnN0ICRleHRyaW5zaWMgPSBhdG9tRmFjdG9yeShcIkV4dHJpbnNpY0NvZGVjXCIsIChkZXJpdmVDb2RlYywgbWV0YWRhdGEsIHNpZ24sIHByZWZpeCkgPT4ge1xuICAgIHJldHVybiBNLiRleHRyaW5zaWMoe1xuICAgICAgICBkZXJpdmVDb2RlYyxcbiAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgIHNpZ246IHNpZ24sXG4gICAgICAgIHByZWZpeDogcHJlZml4LFxuICAgIH0pO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD0kRXh0cmluc2ljLmpzLm1hcCIsImltcG9ydCAqIGFzIE0gZnJvbSBcIi4uLy4uL2ZyYW1lX21ldGFkYXRhL21vZC5qc1wiO1xuaW1wb3J0IHsgYXRvbUZhY3RvcnkgfSBmcm9tIFwiLi4vc3lzL0F0b20uanNcIjtcbmV4cG9ydCBjb25zdCAka2V5ID0gYXRvbUZhY3RvcnkoXCJLZXlDb2RlY1wiLCAoZGVyaXZlQ29kZWMsIHBhbGxldCwgc3RvcmFnZUVudHJ5KSA9PiB7XG4gICAgcmV0dXJuIE0uJHN0b3JhZ2VLZXkoe1xuICAgICAgICBkZXJpdmVDb2RlYyxcbiAgICAgICAgcGFsbGV0LFxuICAgICAgICBzdG9yYWdlRW50cnksXG4gICAgfSk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPSRLZXkuanMubWFwIiwiaW1wb3J0ICogYXMgTSBmcm9tIFwiLi4vLi4vZnJhbWVfbWV0YWRhdGEvbW9kLmpzXCI7XG5pbXBvcnQgeyBhdG9tRmFjdG9yeSB9IGZyb20gXCIuLi9zeXMvQXRvbS5qc1wiO1xuZXhwb3J0IGNvbnN0ICRzdG9yYWdlS2V5ID0gYXRvbUZhY3RvcnkoXCIkU3RvcmFnZUtleVwiLCAoZGVyaXZlQ29kZWMsIHBhbGxldCwgc3RvcmFnZUVudHJ5KSA9PiB7XG4gICAgcmV0dXJuIE0uJHN0b3JhZ2VLZXkoe1xuICAgICAgICBkZXJpdmVDb2RlYyxcbiAgICAgICAgcGFsbGV0LFxuICAgICAgICBzdG9yYWdlRW50cnksXG4gICAgfSk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPSRTdG9yYWdlS2V5LmpzLm1hcCIsImltcG9ydCB7IGF0b21GYWN0b3J5IH0gZnJvbSBcIi4uL3N5cy9BdG9tLmpzXCI7XG5leHBvcnQgY29uc3QgY29kZWMgPSBhdG9tRmFjdG9yeShcIkNvZGVjXCIsIChkZXJpdmVDb2RlYywgdHkpID0+IHtcbiAgICByZXR1cm4gZGVyaXZlQ29kZWModHkpO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db2RlYy5qcy5tYXAiLCJpbXBvcnQgKiBhcyBVIGZyb20gXCIuLi8uLi91dGlsL21vZC5qc1wiO1xuaW1wb3J0IHsgYXRvbSB9IGZyb20gXCIuLi9zeXMvQXRvbS5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZWQoY29kZWMsIGVuY29kZWQsIGtleSkge1xuICAgIHJldHVybiBhdG9tKFwiRGVjb2RlZFwiLCBbY29kZWMsIGVuY29kZWQsIGtleV0sIFxuICAgIC8vIFRPRE86IGNyZWF0ZSBgV3JhcGAgdXRpbCDigJPigJMgdGhpcyBpcyBjdXJyZW50bHkgbmVjZXNzYXJ5IGFzIHRoZSBkZWNvZGVkIHZhbHVlIGlzIGB1bmtub3duYCxcbiAgICAvLyB3aGljaOKAk+KAk2xlZnQgdG9wLWxldmVs4oCT4oCTdW5pZmllcyB3aXRoIGVycm9yIHR5cGVzLlxuICAgIChjb2RlYywgZW5jb2RlZCwga2V5KSA9PiB7XG4gICAgICAgIHJldHVybiB7IFtrZXldOiBjb2RlYy5kZWNvZGUoVS5oZXguZGVjb2RlKGVuY29kZWQpKSB9O1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGVjb2RlZC5qcy5tYXAiLCJpbXBvcnQgKiBhcyBNIGZyb20gXCIuLi8uLi9mcmFtZV9tZXRhZGF0YS9tb2QuanNcIjtcbmltcG9ydCB7IGF0b21GYWN0b3J5IH0gZnJvbSBcIi4uL3N5cy9BdG9tLmpzXCI7XG5leHBvcnQgY29uc3QgZGVyaXZlQ29kZWMgPSBhdG9tRmFjdG9yeShcIkRlcml2ZUNvZGVjXCIsIChtZXRhZGF0YSkgPT4ge1xuICAgIHJldHVybiBNLkRlcml2ZUNvZGVjKG1ldGFkYXRhLnR5cyk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURlcml2ZUNvZGVjLmpzLm1hcCIsImltcG9ydCAqIGFzIE0gZnJvbSBcIi4uLy4uL2ZyYW1lX21ldGFkYXRhL21vZC5qc1wiO1xuaW1wb3J0ICogYXMgVSBmcm9tIFwiLi4vLi4vdXRpbC9tb2QuanNcIjtcbmltcG9ydCB7IGF0b21GYWN0b3J5IH0gZnJvbSBcIi4uL3N5cy9BdG9tLmpzXCI7XG5pbXBvcnQgeyBycGNDYWxsIH0gZnJvbSBcIi4vUnBjQ2FsbC5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIG1ldGFkYXRhKGNvbmZpZywgLi4uW2Jsb2NrSGFzaF0pIHtcbiAgICBjb25zdCBjYWxsID0gcnBjQ2FsbChjb25maWcsIFwic3RhdGVfZ2V0TWV0YWRhdGFcIiwgW2Jsb2NrSGFzaF0pO1xuICAgIHJldHVybiBwYXJzZU1ldGFkYXRhKGNhbGwpO1xufVxuZXhwb3J0IGNvbnN0IHBhcnNlTWV0YWRhdGEgPSBhdG9tRmFjdG9yeShcIk1ldGFkYXRhXCIsIChjYWxsKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIE0uZnJvbVByZWZpeGVkSGV4KGNhbGwucmVzdWx0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNZXRhZGF0YURlY29kZUVycm9yKGUpO1xuICAgIH1cbn0pO1xuZXhwb3J0IGNvbnN0IHBhbGxldE1ldGFkYXRhID0gYXRvbUZhY3RvcnkoXCJQYWxsZXRNZXRhZGF0YVwiLCAobWV0YWRhdGEsIHBhbGxldE5hbWUpID0+IHtcbiAgICByZXR1cm4gTS5nZXRQYWxsZXQobWV0YWRhdGEsIHBhbGxldE5hbWUpO1xufSk7XG5leHBvcnQgY29uc3QgZW50cnlNZXRhZGF0YSA9IGF0b21GYWN0b3J5KFwiRW50cnlNZXRhZGF0YVwiLCAocGFsbGV0TWV0YWRhdGEsIGVudHJ5TmFtZSkgPT4ge1xuICAgIHJldHVybiBNLmdldEVudHJ5KHBhbGxldE1ldGFkYXRhLCBlbnRyeU5hbWUpO1xufSk7XG5leHBvcnQgY2xhc3MgTWV0YWRhdGFEZWNvZGVFcnJvciBleHRlbmRzIFUuRXJyb3JDdG9yKFwiTWV0YWRhdGFEZWNvZGVcIikge1xuICAgIC8vIFRPRE86IHJlcGxhY2Ugd2l0aCBpbnRlcm5hbCBzY2FsZSBlcnJvciAmIGVuc3VyZSBhcHByb3ByaWF0ZSB0cmFjZSBpbmZvXG4gICAgY29uc3RydWN0b3Ioc2NhbGVFcnJvcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzY2FsZUVycm9yXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBzY2FsZUVycm9yXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1ldGFkYXRhLmpzLm1hcCIsImltcG9ydCB7IGF0b20gfSBmcm9tIFwiLi4vc3lzL0F0b20uanNcIjtcbmltcG9ydCB7IFJwY0Vycm9yIH0gZnJvbSBcIi4vY29tbW9uLmpzXCI7XG5pbXBvcnQgeyBycGNDbGllbnQgfSBmcm9tIFwiLi9ScGNDbGllbnQuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBycGNDYWxsKGNvbmZpZywgbWV0aG9kTmFtZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIGF0b20oXCJScGNDYWxsXCIsIFtycGNDbGllbnQoY29uZmlnKSwgbWV0aG9kTmFtZSwgLi4ucGFyYW1zXSwgYXN5bmMgKGNsaWVudCwgbWV0aG9kTmFtZSwgLi4ucGFyYW1zKSA9PiB7XG4gICAgICAgIC8vIFRPRE86IGNsZWFuIHVwIHR5cGluZ3NcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2xpZW50LmNhbGwobWV0aG9kTmFtZSwgcGFyYW1zKTtcbiAgICAgICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBScGNFcnJvcih7XG4gICAgICAgICAgICAgICAgLi4ucmVzdWx0LmVycm9yLFxuICAgICAgICAgICAgICAgIGF0dGVtcHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBzaG91bGQgdGhpcyBlZmZlY3QgaW1wbGljaXRseSBpbmRleCBpbnRvIGByZXN1bHRgP1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UnBjQ2FsbC5qcy5tYXAiLCJpbXBvcnQgKiBhcyBycGMgZnJvbSBcIi4uLy4uL3JwYy9tb2QuanNcIjtcbmltcG9ydCB7IGF0b20gfSBmcm9tIFwiLi4vc3lzL0F0b20uanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBycGNDbGllbnQoY29uZmlnKSB7XG4gICAgcmV0dXJuIGF0b20oXCJScGNDbGllbnRcIiwgW2NvbmZpZ10sIChjb25maWcpID0+IHtcbiAgICAgICAgcmV0dXJuIHJwYy5zdGRDbGllbnQoY29uZmlnKTtcbiAgICB9LCBhc3luYyAoY2xpZW50KSA9PiB7XG4gICAgICAgIGF3YWl0IGNsaWVudC5jbG9zZSgpO1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UnBjQ2xpZW50LmpzLm1hcCIsImltcG9ydCAqIGFzIFUgZnJvbSBcIi4uLy4uL3V0aWwvbW9kLmpzXCI7XG5pbXBvcnQgeyBhdG9tIH0gZnJvbSBcIi4uL3N5cy9BdG9tLmpzXCI7XG5pbXBvcnQgeyBScGNFcnJvciB9IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuaW1wb3J0IHsgcnBjQ2xpZW50IH0gZnJvbSBcIi4vUnBjQ2xpZW50LmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gcnBjU3Vic2NyaXB0aW9uKGNvbmZpZywgbWV0aG9kTmFtZSwgcGFyYW1zLCBjcmVhdGVMaXN0ZW5lciwgY2xlYW51cCkge1xuICAgIHJldHVybiBhdG9tKFwiUnBjU3Vic2NyaXB0aW9uXCIsIFtycGNDbGllbnQoY29uZmlnKSwgbWV0aG9kTmFtZSwgLi4ucGFyYW1zXSwgYXN5bmMgZnVuY3Rpb24gKGNsaWVudCwgbWV0aG9kTmFtZSwgLi4ucGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNsaWVudC5zdWJzY3JpYmUobWV0aG9kTmFtZSwgcGFyYW1zLCBjcmVhdGVMaXN0ZW5lciwgY2xlYW51cFxuICAgICAgICAgICAgPyAoeCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1bihjbGVhbnVwKHgucmVzdWx0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChyZXN1bHQ/LmVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJwY0Vycm9yKHtcbiAgICAgICAgICAgICAgICAuLi5yZXN1bHQuZXJyb3IsXG4gICAgICAgICAgICAgICAgYXR0ZW1wdDoge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2ROYW1lLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IGNsZWFuIHVwIHR5cGluZ3Mg4oCT4oCTIHNob3VsZCBpbXBsaWNpdGx5IG5hcnJvdyB0byBgdW5kZWZpbmVkYFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xufVxuZXhwb3J0IGNsYXNzIFJwY1N1YnNjcmlwdGlvbkVycm9yIGV4dGVuZHMgVS5FcnJvckN0b3IoXCJScGNTdWJzY3JpcHRpb25cIikge1xuICAgIGNvbnN0cnVjdG9yKGVycm9yKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVycm9yXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBlcnJvclxuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ScGNTdWJzY3JpcHRpb24uanMubWFwIiwiaW1wb3J0ICogYXMgc3lzIGZyb20gXCIuLi9zeXMvbW9kLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gc2VsZWN0KHZhbCwgZmllbGQpIHtcbiAgICByZXR1cm4gc3lzLmF0b20oXCJTZWxlY3RcIiwgW3ZhbCwgZmllbGRdLCAodmFsLCBmaWVsZCkgPT4ge1xuICAgICAgICByZXR1cm4gdmFsW2ZpZWxkXTtcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNlbGVjdC5qcy5tYXAiLCJpbXBvcnQgKiBhcyBVIGZyb20gXCIuLi8uLi91dGlsL21vZC5qc1wiO1xuaW1wb3J0IHsgYXRvbUZhY3RvcnkgfSBmcm9tIFwiLi4vc3lzL0F0b20uanNcIjtcbmV4cG9ydCBjb25zdCBzdG9yYWdlS2V5ID0gYXRvbUZhY3RvcnkoXCJTdG9yYWdlS2V5XCIsICgkc3RvcmFnZUtleSwgLi4ua2V5cykgPT4ge1xuICAgIHJldHVybiBVLmhleC5lbmNvZGUoJHN0b3JhZ2VLZXkuZW5jb2RlKGtleXMpKTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RvcmFnZUtleS5qcy5tYXAiLCJpbXBvcnQgeyBhdG9tIH0gZnJvbSBcIi4uL3N5cy9tb2QuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiB3cmFwKHRhcmdldCwga2V5KSB7XG4gICAgcmV0dXJuIGF0b20oXCJXcmFwXCIsIFt0YXJnZXQsIGtleV0sICh0YXJnZXQsIGtleSkgPT4ge1xuICAgICAgICByZXR1cm4geyBba2V5XTogdGFyZ2V0IH07XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1XcmFwLmpzLm1hcCIsImltcG9ydCAqIGFzIFUgZnJvbSBcIi4uLy4uL3V0aWwvbW9kLmpzXCI7XG5leHBvcnQgY2xhc3MgUnBjRXJyb3IgZXh0ZW5kcyBVLkVycm9yQ3RvcihcIlJwY0NhbGxcIikge1xuICAgIGNvbnN0cnVjdG9yKHsgY29kZSwgbWVzc2FnZSwgYXR0ZW1wdCB9KSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF0dGVtcHRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgdGhpcy5hdHRlbXB0ID0gYXR0ZW1wdDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tb24uanMubWFwIiwiZXhwb3J0ICogZnJvbSBcIi4vJEV4dHJpbnNpYy5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vJEtleS5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vJFN0b3JhZ2VLZXkuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL0NvZGVjLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9EZWNvZGVkLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9EZXJpdmVDb2RlYy5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vTWV0YWRhdGEuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL1JwY0NhbGwuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL1JwY0NsaWVudC5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vUnBjU3Vic2NyaXB0aW9uLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9TZWxlY3QuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL1N0b3JhZ2VLZXkuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL1dyYXAuanNcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZC5qcy5tYXAiLCJleHBvcnQgKiBmcm9tIFwiLi9hdG9tcy9tb2QuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3N0ZC9tb2QuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3N5cy9tb2QuanNcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZC5qcy5tYXAiLCJleHBvcnQgKiBmcm9tIFwiLi9yZWFkQmxvY2suanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3JlYWRFbnRyeS5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vcmVhZEtleVBhZ2UuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3N1Ym1pdEFuZFdhdGNoRXh0cmluc2ljLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi93YXRjaEJsb2Nrcy5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vd2F0Y2hFbnRyeS5qc1wiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kLmpzLm1hcCIsImltcG9ydCAqIGFzIFUgZnJvbSBcIi4uLy4uL3V0aWwvbW9kLmpzXCI7XG5pbXBvcnQgKiBhcyBhIGZyb20gXCIuLi9hdG9tcy9tb2QuanNcIjtcbmltcG9ydCAqIGFzIHN5cyBmcm9tIFwiLi4vc3lzL21vZC5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRCbG9jayhjb25maWcsIC4uLltibG9ja0hhc2hdKSB7XG4gICAgY29uc3QgbWV0YWRhdGFfID0gYS5tZXRhZGF0YShjb25maWcsIGJsb2NrSGFzaCk7XG4gICAgY29uc3QgJGV4dHJpbnNpYyA9IGEuJGV4dHJpbnNpYyhhLmRlcml2ZUNvZGVjKG1ldGFkYXRhXyksIG1ldGFkYXRhXyk7XG4gICAgY29uc3QgY2FsbCA9IGEucnBjQ2FsbChjb25maWcsIFwiY2hhaW5fZ2V0QmxvY2tcIiwgW2Jsb2NrSGFzaF0pO1xuICAgIGNvbnN0IGRlY29kZWQgPSBzeXMuYW5vbihbJGV4dHJpbnNpYywgY2FsbF0sICgkZXh0cmluc2ljLCBjYWxsKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgYmxvY2s6IHsgZXh0cmluc2ljcywgaGVhZGVyIH0sIGp1c3RpZmljYXRpb25zIH0gPSBjYWxsLnJlc3VsdDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGp1c3RpZmljYXRpb25zLFxuICAgICAgICAgICAgYmxvY2s6IHtcbiAgICAgICAgICAgICAgICBoZWFkZXIsXG4gICAgICAgICAgICAgICAgZXh0cmluc2ljczogZXh0cmluc2ljcy5tYXAoKGV4dHJpbnNpYykgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJGV4dHJpbnNpYy5kZWNvZGUoVS5oZXguZGVjb2RlKGV4dHJpbnNpYykpO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gYS53cmFwKGRlY29kZWQsIFwiYmxvY2tcIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFkQmxvY2suanMubWFwIiwiaW1wb3J0ICogYXMgYSBmcm9tIFwiLi4vYXRvbXMvbW9kLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gcmVhZEVudHJ5KGNvbmZpZywgcGFsbGV0TmFtZSwgZW50cnlOYW1lLCBrZXlzLCAuLi5bYmxvY2tIYXNoXSkge1xuICAgIGNvbnN0IG1ldGFkYXRhXyA9IGEubWV0YWRhdGEoY29uZmlnLCBibG9ja0hhc2gpO1xuICAgIGNvbnN0IGRlcml2ZUNvZGVjXyA9IGEuZGVyaXZlQ29kZWMobWV0YWRhdGFfKTtcbiAgICBjb25zdCBwYWxsZXRNZXRhZGF0YV8gPSBhLnBhbGxldE1ldGFkYXRhKG1ldGFkYXRhXywgcGFsbGV0TmFtZSk7XG4gICAgY29uc3QgZW50cnlNZXRhZGF0YV8gPSBhLmVudHJ5TWV0YWRhdGEocGFsbGV0TWV0YWRhdGFfLCBlbnRyeU5hbWUpO1xuICAgIGNvbnN0ICRzdG9yYWdlS2V5ID0gYS4kc3RvcmFnZUtleShkZXJpdmVDb2RlY18sIHBhbGxldE1ldGFkYXRhXywgZW50cnlNZXRhZGF0YV8pO1xuICAgIGNvbnN0IHN0b3JhZ2VLZXkgPSBhLnN0b3JhZ2VLZXkoJHN0b3JhZ2VLZXksIC4uLmtleXMpO1xuICAgIGNvbnN0IHN0b3JhZ2VDYWxsID0gYS5ycGNDYWxsKGNvbmZpZywgXCJzdGF0ZV9nZXRTdG9yYWdlXCIsIFtzdG9yYWdlS2V5LCBibG9ja0hhc2hdKTtcbiAgICBjb25zdCBlbnRyeVZhbHVlVHlwZUkgPSBhLnNlbGVjdChlbnRyeU1ldGFkYXRhXywgXCJ2YWx1ZVwiKTtcbiAgICBjb25zdCAkZW50cnkgPSBhLmNvZGVjKGRlcml2ZUNvZGVjXywgZW50cnlWYWx1ZVR5cGVJKTtcbiAgICBjb25zdCByZXN1bHRIZXggPSBhLnNlbGVjdChzdG9yYWdlQ2FsbCwgXCJyZXN1bHRcIik7XG4gICAgcmV0dXJuIGEuZGVjb2RlZCgkZW50cnksIHJlc3VsdEhleCwgXCJ2YWx1ZVwiKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWRFbnRyeS5qcy5tYXAiLCJpbXBvcnQgKiBhcyBVIGZyb20gXCIuLi8uLi91dGlsL21vZC5qc1wiO1xuaW1wb3J0ICogYXMgYSBmcm9tIFwiLi4vYXRvbXMvbW9kLmpzXCI7XG5pbXBvcnQgKiBhcyBzeXMgZnJvbSBcIi4uL3N5cy9tb2QuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiByZWFkS2V5UGFnZShjb25maWcsIHBhbGxldE5hbWUsIGVudHJ5TmFtZSwgY291bnQsIC4uLltzdGFydCwgYmxvY2tIYXNoXSkge1xuICAgIGNvbnN0IG1ldGFkYXRhID0gYS5tZXRhZGF0YShjb25maWcsIGJsb2NrSGFzaCk7XG4gICAgY29uc3QgZGVyaXZlQ29kZWMgPSBhLmRlcml2ZUNvZGVjKG1ldGFkYXRhKTtcbiAgICBjb25zdCBwYWxsZXRNZXRhZGF0YSA9IGEucGFsbGV0TWV0YWRhdGEobWV0YWRhdGEsIHBhbGxldE5hbWUpO1xuICAgIGNvbnN0IGVudHJ5TWV0YWRhdGEgPSBzeXMuYW5vbihbYS5lbnRyeU1ldGFkYXRhKHBhbGxldE1ldGFkYXRhLCBlbnRyeU5hbWUpXSwgKGVudHJ5TWV0YWRhdGEpID0+IHtcbiAgICAgICAgaWYgKGVudHJ5TWV0YWRhdGEudHlwZSAhPT0gXCJNYXBcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWFkaW5nS2V5c09mTm9uTWFwRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW50cnlNZXRhZGF0YTtcbiAgICB9KTtcbiAgICBjb25zdCAkc3RvcmFnZUtleSA9IGEuJHN0b3JhZ2VLZXkoZGVyaXZlQ29kZWMsIHBhbGxldE1ldGFkYXRhLCBlbnRyeU1ldGFkYXRhKTtcbiAgICBjb25zdCBzdGFydEtleSA9IHN0YXJ0ID8gYS5zdG9yYWdlS2V5KCRzdG9yYWdlS2V5LCBzdGFydCkgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgc3RvcmFnZUtleSA9IGEuc3RvcmFnZUtleSgkc3RvcmFnZUtleSk7XG4gICAgY29uc3QgY2FsbCA9IGEucnBjQ2FsbChjb25maWcsIFwic3RhdGVfZ2V0S2V5c1BhZ2VkXCIsIFtzdG9yYWdlS2V5LCBjb3VudCwgc3RhcnRLZXksIGJsb2NrSGFzaF0pO1xuICAgIGNvbnN0ICRrZXkgPSBhLiRrZXkoZGVyaXZlQ29kZWMsIHBhbGxldE1ldGFkYXRhLCBlbnRyeU1ldGFkYXRhKTtcbiAgICBjb25zdCBrZXlzRW5jb2RlZCA9IGEuc2VsZWN0KGNhbGwsIFwicmVzdWx0XCIpO1xuICAgIGNvbnN0IGtleXNEZWNvZGVkID0gc3lzLmFub24oWyRrZXksIGtleXNFbmNvZGVkXSwgKCRrZXksIGtleXNFbmNvZGVkKSA9PiB7XG4gICAgICAgIHJldHVybiBrZXlzRW5jb2RlZC5tYXAoKGtleUVuY29kZWQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAka2V5LmRlY29kZShVLmhleC5kZWNvZGUoa2V5RW5jb2RlZCkpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gYS53cmFwKGtleXNEZWNvZGVkLCBcImtleXNcIik7XG59XG5leHBvcnQgY2xhc3MgUmVhZGluZ0tleXNPZk5vbk1hcEVycm9yIGV4dGVuZHMgVS5FcnJvckN0b3IoXCJSZWFkaW5nS2V5c09mTm9uTWFwXCIpIHtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWRLZXlQYWdlLmpzLm1hcCIsImltcG9ydCB7IHVuaW1wbGVtZW50ZWQgfSBmcm9tIFwiLi4vLi4vZGVwcy9zdGQvdGVzdGluZy9hc3NlcnRzLmpzXCI7XG5pbXBvcnQgKiBhcyBzczU4IGZyb20gXCIuLi8uLi9zczU4L21vZC5qc1wiO1xuaW1wb3J0ICogYXMgVSBmcm9tIFwiLi4vLi4vdXRpbC9tb2QuanNcIjtcbmltcG9ydCAqIGFzIGEgZnJvbSBcIi4uL2F0b21zL21vZC5qc1wiO1xuaW1wb3J0ICogYXMgc3lzIGZyb20gXCIuLi9zeXMvbW9kLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gc2VuZEFuZFdhdGNoRXh0cmluc2ljKHByb3BzKSB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSBhLm1ldGFkYXRhKHByb3BzLmNvbmZpZyk7XG4gICAgY29uc3QgZGVyaXZlQ29kZWMgPSBhLmRlcml2ZUNvZGVjKG1ldGFkYXRhKTtcbiAgICBjb25zdCAkZXh0cmluc2ljID0gYS4kZXh0cmluc2ljKGRlcml2ZUNvZGVjLCBtZXRhZGF0YSwgcHJvcHMuc2lnbiwgcHJvcHMuY29uZmlnLmFkZHJlc3NQcmVmaXgpO1xuICAgIGNvbnN0IHJ1bnRpbWVWZXJzaW9uID0gYS5ycGNDYWxsKHByb3BzLmNvbmZpZywgXCJzdGF0ZV9nZXRSdW50aW1lVmVyc2lvblwiLCBbXSk7XG4gICAgY29uc3Qgc2VuZGVyU3M1OCA9IHN5cy5hbm9uKFtwcm9wcy5zZW5kZXJdLCAoc2VuZGVyKSA9PiB7XG4gICAgICAgIHJldHVybiAoKCkgPT4ge1xuICAgICAgICAgICAgc3dpdGNoIChzZW5kZXIudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJJZFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzczU4LmVuY29kZShwcm9wcy5jb25maWcuYWRkcmVzc1ByZWZpeCwgc2VuZGVyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogb3RoZXIgdHlwZXNcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgIHVuaW1wbGVtZW50ZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgfSk7XG4gICAgY29uc3QgYWNjb3VudE5leHRJbmRleCA9IGEucnBjQ2FsbChwcm9wcy5jb25maWcsIFwic3lzdGVtX2FjY291bnROZXh0SW5kZXhcIiwgW3NlbmRlclNzNThdKTtcbiAgICBjb25zdCBnZW5lc2lzSGFzaCA9IHN5cy5hbm9uKFthLnJwY0NhbGwocHJvcHMuY29uZmlnLCBcImNoYWluX2dldEJsb2NrSGFzaFwiLCBbMF0pXSwgKHsgcmVzdWx0IH0pID0+IHtcbiAgICAgICAgcmV0dXJuIFUuaGV4LmRlY29kZShyZXN1bHQpO1xuICAgIH0pO1xuICAgIGNvbnN0IGNoZWNrcG9pbnRIYXNoID0gcHJvcHMuY2hlY2twb2ludFxuICAgICAgICA/IHN5cy5hbm9uKFtwcm9wcy5jaGVja3BvaW50XSwgKHYpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBVLmhleC5kZWNvZGUodik7XG4gICAgICAgIH0pXG4gICAgICAgIDogZ2VuZXNpc0hhc2g7XG4gICAgY29uc3QgZXh0cmluc2ljSGV4ID0gc3lzLmFub24oW1xuICAgICAgICAkZXh0cmluc2ljLFxuICAgICAgICBwcm9wcy5zZW5kZXIsXG4gICAgICAgIHByb3BzLm1ldGhvZE5hbWUsXG4gICAgICAgIHByb3BzLnBhbGxldE5hbWUsXG4gICAgICAgIHJ1bnRpbWVWZXJzaW9uLFxuICAgICAgICBhY2NvdW50TmV4dEluZGV4LFxuICAgICAgICBnZW5lc2lzSGFzaCxcbiAgICAgICAgcHJvcHMuYXJncyxcbiAgICAgICAgY2hlY2twb2ludEhhc2gsXG4gICAgICAgIHByb3BzLnRpcCxcbiAgICAgICAgcHJvcHMubW9ydGFsaXR5LFxuICAgIF0sIGFzeW5jICgkZXh0cmluc2ljLCBzZW5kZXIsIG1ldGhvZE5hbWUsIHBhbGxldE5hbWUsIHsgcmVzdWx0OiB7IHNwZWNWZXJzaW9uLCB0cmFuc2FjdGlvblZlcnNpb24gfSB9LCB7IHJlc3VsdDogbm9uY2UgfSwgZ2VuZXNpc0hhc2gsIGFyZ3MsIGNoZWNrcG9pbnQsIHRpcCwgbW9ydGFsaXR5KSA9PiB7XG4gICAgICAgIGNvbnN0IGV4dHJpbnNpY0J5dGVzID0gYXdhaXQgJGV4dHJpbnNpYy5lbmNvZGVBc3luYyh7XG4gICAgICAgICAgICBwcm90b2NvbFZlcnNpb246IDQsXG4gICAgICAgICAgICBwYWxsZXROYW1lLFxuICAgICAgICAgICAgbWV0aG9kTmFtZSxcbiAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICBzaWduYXR1cmU6IHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBzZW5kZXIsXG4gICAgICAgICAgICAgICAgZXh0cmE6IFtcbiAgICAgICAgICAgICAgICAgICAgbW9ydGFsaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIk1vcnRhbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtb3J0YWxpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHsgdHlwZTogXCJJbW1vcnRhbFwiIH0sXG4gICAgICAgICAgICAgICAgICAgIG5vbmNlLFxuICAgICAgICAgICAgICAgICAgICB0aXAgfHwgMCxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGFkZGl0aW9uYWw6IFtzcGVjVmVyc2lvbiwgdHJhbnNhY3Rpb25WZXJzaW9uLCBjaGVja3BvaW50LCBnZW5lc2lzSGFzaF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFUuaGV4LmVuY29kZShleHRyaW5zaWNCeXRlcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGEucnBjU3Vic2NyaXB0aW9uKHByb3BzLmNvbmZpZywgXCJhdXRob3Jfc3VibWl0QW5kV2F0Y2hFeHRyaW5zaWNcIiwgW2V4dHJpbnNpY0hleF0sIHByb3BzLmNyZWF0ZVdhdGNoSGFuZGxlciwgKG9rKSA9PiB7XG4gICAgICAgIHJldHVybiBhLnJwY0NhbGwocHJvcHMuY29uZmlnLCBcImF1dGhvcl91bndhdGNoRXh0cmluc2ljXCIsIFtvay5yZXN1bHRdKTtcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1Ym1pdEFuZFdhdGNoRXh0cmluc2ljLmpzLm1hcCIsImltcG9ydCAqIGFzIFUgZnJvbSBcIi4uLy4uL3V0aWwvbW9kLmpzXCI7XG5pbXBvcnQgKiBhcyBhIGZyb20gXCIuLi9hdG9tcy9tb2QuanNcIjtcbmltcG9ydCB7IHJlYWRCbG9jayB9IGZyb20gXCIuL3JlYWRCbG9jay5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHdhdGNoQmxvY2tzKGNvbmZpZywgY3JlYXRlV2F0Y2hIYW5kbGVyKSB7XG4gICAgcmV0dXJuIGEucnBjU3Vic2NyaXB0aW9uKGNvbmZpZywgXCJjaGFpbl9zdWJzY3JpYmVOZXdIZWFkc1wiLCBbXSwgKHN0b3ApID0+IHtcbiAgICAgICAgY29uc3Qgd2F0Y2hIYW5kbGVyID0gY3JlYXRlV2F0Y2hIYW5kbGVyKHN0b3ApO1xuICAgICAgICByZXR1cm4gYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYmxvY2tOdW0gPSByZXN1bHQucGFyYW1zLnJlc3VsdC5udW1iZXI7XG4gICAgICAgICAgICBjb25zdCBibG9ja0hhc2ggPSBhXG4gICAgICAgICAgICAgICAgLnJwY0NhbGwoY29uZmlnLCBcImNoYWluX2dldEJsb2NrSGFzaFwiLCBbYmxvY2tOdW1dKVxuICAgICAgICAgICAgICAgIC5zZWxlY3QoXCJyZXN1bHRcIik7XG4gICAgICAgICAgICBjb25zdCBibG9jayA9IFUudGhyb3dJZkVycm9yKFxuICAgICAgICAgICAgLy8gU1RPUCBUSElTIE1BRE5FU1NcbiAgICAgICAgICAgIGF3YWl0IHJlYWRCbG9jayhjb25maWcsIGJsb2NrSGFzaCkucnVuKCkpO1xuICAgICAgICAgICAgd2F0Y2hIYW5kbGVyKGJsb2NrLmJsb2NrKTtcbiAgICAgICAgfTtcbiAgICB9LCAob2spID0+IHtcbiAgICAgICAgcmV0dXJuIGEucnBjQ2FsbChjb25maWcsIFwiY2hhaW5fdW5zdWJzY3JpYmVOZXdIZWFkXCIsIFtvay5yZXN1bHRdKTtcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdhdGNoQmxvY2tzLmpzLm1hcCIsImltcG9ydCAqIGFzIFUgZnJvbSBcIi4uLy4uL3V0aWwvbW9kLmpzXCI7XG5pbXBvcnQgKiBhcyBhIGZyb20gXCIuLi9hdG9tcy9tb2QuanNcIjtcbmltcG9ydCAqIGFzIHN5cyBmcm9tIFwiLi4vc3lzL21vZC5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHdhdGNoRW50cnkoY29uZmlnLCBwYWxsZXROYW1lLCBlbnRyeU5hbWUsIGtleXMsIGNyZWF0ZVdhdGNoSGFuZGxlcikge1xuICAgIGNvbnN0IG1ldGFkYXRhXyA9IGEubWV0YWRhdGEoY29uZmlnKTtcbiAgICBjb25zdCBkZXJpdmVDb2RlY18gPSBhLmRlcml2ZUNvZGVjKG1ldGFkYXRhXyk7XG4gICAgY29uc3QgcGFsbGV0TWV0YWRhdGFfID0gYS5wYWxsZXRNZXRhZGF0YShtZXRhZGF0YV8sIHBhbGxldE5hbWUpO1xuICAgIGNvbnN0IGVudHJ5TWV0YWRhdGFfID0gYS5lbnRyeU1ldGFkYXRhKHBhbGxldE1ldGFkYXRhXywgZW50cnlOYW1lKTtcbiAgICBjb25zdCAkc3RvcmFnZUtleSA9IGEuJHN0b3JhZ2VLZXkoZGVyaXZlQ29kZWNfLCBwYWxsZXRNZXRhZGF0YV8sIGVudHJ5TWV0YWRhdGFfKTtcbiAgICBjb25zdCBlbnRyeVZhbHVlVHlwZUkgPSBhLnNlbGVjdChlbnRyeU1ldGFkYXRhXywgXCJ2YWx1ZVwiKTtcbiAgICBjb25zdCAkZW50cnkgPSBhLmNvZGVjKGRlcml2ZUNvZGVjXywgZW50cnlWYWx1ZVR5cGVJKTtcbiAgICBjb25zdCBzdG9yYWdlS2V5cyA9IGtleXMubGVuZ3RoID09PSAwXG4gICAgICAgID8gc3lzLmFub24oW2Euc3RvcmFnZUtleSgkc3RvcmFnZUtleSldLCAodikgPT4gW3ZdKVxuICAgICAgICA6IHN5cy5hbm9uKFthLnN0b3JhZ2VLZXkoJHN0b3JhZ2VLZXksIGtleXMpXSwgKHYpID0+IFt2XSk7XG4gICAgcmV0dXJuIHN5cy5pbnRvKFskZW50cnldLCAoJGVudHJ5Q29kZWMpID0+IHtcbiAgICAgICAgY29uc3Qgd2F0Y2hJbml0ID0gVS5tYXBDcmVhdGVXYXRjaEhhbmRsZXIoY3JlYXRlV2F0Y2hIYW5kbGVyLCAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2UucGFyYW1zLnJlc3VsdC5jaGFuZ2VzLm1hcCgoW2tleSwgdmFsXSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBba2V5LCB2YWwgPyAkZW50cnlDb2RlYy5kZWNvZGUoVS5oZXguZGVjb2RlKHZhbCkpIDogdW5kZWZpbmVkXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGEucnBjU3Vic2NyaXB0aW9uKGNvbmZpZywgXCJzdGF0ZV9zdWJzY3JpYmVTdG9yYWdlXCIsIFtzdG9yYWdlS2V5c10sIHdhdGNoSW5pdCwgKG9rKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYS5ycGNDYWxsKGNvbmZpZywgXCJzdGF0ZV91bnN1YnNjcmliZVN0b3JhZ2VcIiwgW29rLnJlc3VsdF0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdhdGNoRW50cnkuanMubWFwIiwiaW1wb3J0IHsgc2VsZWN0IH0gZnJvbSBcIi4uL2F0b21zL1NlbGVjdC5qc1wiO1xuaW1wb3J0IHsgRWZmZWN0IH0gZnJvbSBcIi4vRWZmZWN0LmpzXCI7XG5pbXBvcnQgeyBrZXkgfSBmcm9tIFwiLi9rZXkuanNcIjtcbmltcG9ydCB7IHJ1biB9IGZyb20gXCIuL3J1bi5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGF0b20oZnFuLCBhcmdzLCBpbXBsLCBleGl0KSB7XG4gICAgcmV0dXJuIG5ldyBBdG9tKGZxbiwgYXJncywgaW1wbCwgZXhpdCk7XG59XG5leHBvcnQgY2xhc3MgQXRvbSBleHRlbmRzIEVmZmVjdCB7XG4gICAgY29uc3RydWN0b3IoZnFuLCBhcmdzLCBpbXBsLCBleGl0KSB7XG4gICAgICAgIHN1cGVyKGZxbik7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFyZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGFyZ3NcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImltcGxcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGltcGxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV4aXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGV4aXRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlbGVjdChmaWVsZCkge1xuICAgICAgICByZXR1cm4gc2VsZWN0KHRoaXMsIGZpZWxkKTtcbiAgICB9XG4gICAgcnVuKCkge1xuICAgICAgICByZXR1cm4gcnVuKHRoaXMpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBhdG9tRmFjdG9yeShmcW4sIGltcGwsIGV4aXQpIHtcbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdG9tKGZxbiwgYXJncywgaW1wbCwgZXhpdCk7XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhbm9uKGFyZ3MsIGltcGwsIGV4aXQpIHtcbiAgICByZXR1cm4gbmV3IEF0b20oa2V5KGltcGwpLCBhcmdzLCBpbXBsLCBleGl0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpbnRvKGFyZ3MsIGludG8pIHtcbiAgICByZXR1cm4gbmV3IEF0b20oXCJNYXBcIiwgYXJncywgYXN5bmMgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgbmV4dCA9IGF3YWl0IGludG8uYmluZCh0aGlzKSguLi5hcmdzKTtcbiAgICAgICAgaWYgKG5leHQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucnVuKG5leHQpO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFsbCguLi5lZmZlY3RzKSB7XG4gICAgcmV0dXJuIG5ldyBBdG9tKFwiQWxsXCIsIGVmZmVjdHMsICguLi5yZXNvbHZlZCkgPT4ge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZWQ7XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BdG9tLmpzLm1hcCIsImV4cG9ydCBjbGFzcyBFZmZlY3Qge1xuICAgIGNvbnN0cnVjdG9yKGZxbikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmcW5cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZxblxuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FZmZlY3QuanMubWFwIiwiaW1wb3J0IHsgQXRvbSB9IGZyb20gXCIuL0F0b20uanNcIjtcbmxldCBpID0gMDsgLy8gVE9ETzogbWFrZSBmcW4gb3B0aW9uYWxcbmNvbnN0IHJlZktleXMgPSBuZXcgTWFwKCk7XG5leHBvcnQgZnVuY3Rpb24ga2V5KHZhbCkge1xuICAgIGxldCByZWZLZXkgPSByZWZLZXlzLmdldCh2YWwpO1xuICAgIGlmIChyZWZLZXkpIHtcbiAgICAgICAgcmV0dXJuIHJlZktleTtcbiAgICB9XG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIEF0b20pIHtcbiAgICAgICAgcmVmS2V5ID0gYCR7dmFsLmZxbn0oJHt2YWwuYXJncy5tYXAoa2V5KX0pYDtcbiAgICAgICAgcmVmS2V5cy5zZXQodmFsLCByZWZLZXkpO1xuICAgICAgICByZXR1cm4gcmVmS2V5O1xuICAgIH1cbiAgICByZWZLZXkgPSBgXyR7aSsrfWA7XG4gICAgcmVmS2V5cy5zZXQodmFsLCByZWZLZXkpO1xuICAgIHJldHVybiByZWZLZXk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZXkuanMubWFwIiwiZXhwb3J0ICogZnJvbSBcIi4vQXRvbS5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vRWZmZWN0LmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9ydW4uanNcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZC5qcy5tYXAiLCJ2YXIgX1J1bnRpbWVfY2FjaGUsIF9hO1xuaW1wb3J0IHsgX19jbGFzc1ByaXZhdGVGaWVsZEdldCB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgQXRvbSB9IGZyb20gXCIuL0F0b20uanNcIjtcbmltcG9ydCB7IGtleSB9IGZyb20gXCIuL2tleS5qc1wiO1xuZXhwb3J0IGNvbnN0IHsgcnVuIH0gPSAobmV3IChfYSA9IGNsYXNzIFJ1bnRpbWUge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIF9SdW50aW1lX2NhY2hlLnNldCh0aGlzLCBuZXcgTWFwKCkpOyAvLyBUT0RPOiBzZXQgbWF4IHNpemUgLyB1c2UgTFJVXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJydW5cIiwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBhc3luYyAocm9vdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXBlbmRlbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGVhbnVwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGVhbnVwUGVuZGluZyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm9vdFJlc3VsdCA9IGF3YWl0IHRoaXMudmlzaXQocm9vdCwgZGVwZW5kZW50cywgY2xlYW51cCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBkZXBlbmRlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYyA9IGNsZWFudXAuZ2V0KGspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFudXBQZW5kaW5nLnB1c2goKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgYygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChjbGVhbnVwUGVuZGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm9vdFJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZpc2l0XCIsIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogKHZhbCwgZGVwZW5kZW50cywgY2xlYW51cCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrID0ga2V5KHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9SdW50aW1lX2NhY2hlLCBcImZcIikuaGFzKGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfUnVudGltZV9jYWNoZSwgXCJmXCIpLmdldChrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgQXRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IHZhbC5hcmdzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3NQZW5kaW5nID0gUHJvbWlzZS5hbGwoYXJncy5tYXAoKGFyZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdChhcmcsIGRlcGVuZGVudHMsIGNsZWFudXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwZW5kaW5nID0gYXJnc1BlbmRpbmcudGhlbigoYXJnc1Jlc29sdmVkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWwuaW1wbC5iaW5kKHRoaXMpKC4uLmFyZ3NSZXNvbHZlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfUnVudGltZV9jYWNoZSwgXCJmXCIpLnNldChrLCBwZW5kaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLmZvckVhY2goKGFyZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJnIGluc3RhbmNlb2YgQXRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGREZXBlbmRlbnQoZGVwZW5kZW50cywgcGVuZGluZywgYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkID0gYXdhaXQgcGVuZGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyByZXNvbHZlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbC5leGl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFwcGxpZWQgPSAoKSA9PiB2YWwuZXhpdChyZXNvbHZlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFudXAuc2V0KHZhbCwgYXBwbGllZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1J1bnRpbWVfY2FjaGUsIFwiZlwiKS5kZWxldGUoayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFkZERlcGVuZGVudFwiLCB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IChkZXBlbmRlbnRzLCBkZXBlbmRlbmN5LCBkZXBlbmRlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGUgPSBkZXBlbmRlbnRzLmdldChkZXBlbmRlbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wdXNoKGRlcGVuZGVuY3kpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IFtkZXBlbmRlbmN5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcGVuZGVudHMuc2V0KGRlcGVuZGVudCwgZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgX1J1bnRpbWVfY2FjaGUgPSBuZXcgV2Vha01hcCgpLFxuICAgIF9hKSgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJ1bi5qcy5tYXAiLCJpbXBvcnQgKiBhcyAkIGZyb20gXCIuLi9kZXBzL3NjYWxlLmpzXCI7XG5pbXBvcnQgeyAkZXJhIH0gZnJvbSBcIi4vRXJhLmpzXCI7XG5pbXBvcnQgeyBUeVZpc2l0b3IgfSBmcm9tIFwiLi9UeVZpc2l0b3IuanNcIjtcbi8qKlxuICogQWxsIGRlcml2ZWQgY29kZWNzIGZvciBaU1RzIHdpbGwgdXNlIHRoaXMgZXhhY3QgY29kZWMsXG4gKiBzbyBgZGVyaXZlZENvZGVjID09PSAkbnVsbGAgaXMgdHJ1ZSBpZmYgdGhlIHR5cGUgaXMgYSBaU1QuXG4gKi9cbmV4cG9ydCBjb25zdCAkbnVsbCA9ICQuZHVtbXkobnVsbCk7XG4vLyBUT0RPOiB0dXBsZS9hcnJheSBlbGVtZW50IHNraXAgb3B0aW1pemF0aW9uXG5leHBvcnQgZnVuY3Rpb24gRGVyaXZlQ29kZWModHlzKSB7XG4gICAgY29uc3QgdmlzaXRvciA9IG5ldyBUeVZpc2l0b3IodHlzLCB7XG4gICAgICAgIHVuaXRTdHJ1Y3QoKSB7XG4gICAgICAgICAgICByZXR1cm4gJG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIHdyYXBwZXJTdHJ1Y3QoX3R5LCBpbm5lcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXQoaW5uZXIpO1xuICAgICAgICB9LFxuICAgICAgICB0dXBsZVN0cnVjdChfdHksIG1lbWJlcnMpIHtcbiAgICAgICAgICAgIHJldHVybiAkLnR1cGxlKC4uLm1lbWJlcnMubWFwKCh4KSA9PiB0aGlzLnZpc2l0KHgpKSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9iamVjdFN0cnVjdCh0eSkge1xuICAgICAgICAgICAgcmV0dXJuICQub2JqZWN0KC4uLnR5LmZpZWxkcy5tYXAoKHgpID0+IFt4Lm5hbWUsIHRoaXMudmlzaXQoeC50eSldKSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbihfdHksIHNvbWUpIHtcbiAgICAgICAgICAgIHJldHVybiAkLm9wdGlvbih0aGlzLnZpc2l0KHNvbWUpKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzdWx0KF90eSwgb2ssIGVycikge1xuICAgICAgICAgICAgcmV0dXJuICQucmVzdWx0KHRoaXMudmlzaXQob2spLCAkLmluc3RhbmNlKENoYWluRXJyb3IsIFtcInZhbHVlXCIsIHRoaXMudmlzaXQoZXJyKV0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgbmV2ZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gJC5uZXZlcjtcbiAgICAgICAgfSxcbiAgICAgICAgc3RyaW5nVW5pb24odHkpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lbWJlcnMgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyBpbmRleCwgbmFtZSB9IG9mIHR5Lm1lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICBtZW1iZXJzW2luZGV4XSA9IG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJC5zdHJpbmdVbmlvbihtZW1iZXJzKTtcbiAgICAgICAgfSxcbiAgICAgICAgdGFnZ2VkVW5pb24odHkpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lbWJlcnMgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyBmaWVsZHMsIG5hbWU6IHR5cGUsIGluZGV4IH0gb2YgdHkubWVtYmVycykge1xuICAgICAgICAgICAgICAgIGxldCBtZW1iZXI7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbWVtYmVyID0gW3R5cGVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWVsZHNbMF0ubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFR1cGxlIHZhcmlhbnRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgJHZhbHVlID0gZmllbGRzLmxlbmd0aCA9PT0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnZpc2l0KGZpZWxkc1swXS50eSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogJC50dXBsZSguLi5maWVsZHMubWFwKChmKSA9PiB0aGlzLnZpc2l0KGYudHkpKSk7XG4gICAgICAgICAgICAgICAgICAgIG1lbWJlciA9IFt0eXBlLCBbXCJ2YWx1ZVwiLCAkdmFsdWVdXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9iamVjdCB2YXJpYW50XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lbWJlckZpZWxkcyA9IGZpZWxkcy5tYXAoKGZpZWxkLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkLm5hbWUgfHwgaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmRlZmVycmVkKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXQoZmllbGQudHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG1lbWJlciA9IFt0eXBlLCAuLi5tZW1iZXJGaWVsZHNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZW1iZXJzW2luZGV4XSA9IG1lbWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkLnRhZ2dlZFVuaW9uKFwidHlwZVwiLCBtZW1iZXJzKTtcbiAgICAgICAgfSxcbiAgICAgICAgdWludDhBcnJheSgpIHtcbiAgICAgICAgICAgIHJldHVybiAkLnVpbnQ4QXJyYXk7XG4gICAgICAgIH0sXG4gICAgICAgIGFycmF5KHR5KSB7XG4gICAgICAgICAgICByZXR1cm4gJC5hcnJheSh0aGlzLnZpc2l0KHR5LnR5cGVQYXJhbSkpO1xuICAgICAgICB9LFxuICAgICAgICBzaXplZFVpbnQ4QXJyYXkodHkpIHtcbiAgICAgICAgICAgIHJldHVybiAkLnNpemVkVWludDhBcnJheSh0eS5sZW4pO1xuICAgICAgICB9LFxuICAgICAgICBzaXplZEFycmF5KHR5KSB7XG4gICAgICAgICAgICByZXR1cm4gJC5zaXplZEFycmF5KHRoaXMudmlzaXQodHkudHlwZVBhcmFtKSwgdHkubGVuKTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJpbWl0aXZlKHR5KSB7XG4gICAgICAgICAgICBpZiAodHkua2luZCA9PT0gXCJjaGFyXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuICQuc3RyO1xuICAgICAgICAgICAgcmV0dXJuICRbdHkua2luZF07XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBhY3QodHkpIHtcbiAgICAgICAgICAgIGNvbnN0IGlubmVyID0gdGhpcy52aXNpdCh0eS50eXBlUGFyYW0pO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhY3RDb2RlY1Zpc2l0b3IudmlzaXQoaW5uZXIpO1xuICAgICAgICB9LFxuICAgICAgICBiaXRTZXF1ZW5jZSgpIHtcbiAgICAgICAgICAgIHJldHVybiAkLmJpdFNlcXVlbmNlO1xuICAgICAgICB9LFxuICAgICAgICBtYXAoX3R5LCBrZXksIHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuICQubWFwKHRoaXMudmlzaXQoa2V5KSwgdGhpcy52aXNpdCh2YWwpKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KF90eSwgdmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gJC5zZXQodGhpcy52aXNpdCh2YWwpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJhKCkge1xuICAgICAgICAgICAgcmV0dXJuICRlcmE7XG4gICAgICAgIH0sXG4gICAgICAgIGxlblByZWZpeGVkV3JhcHBlcihfdHksIGlubmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gJC5sZW5QcmVmaXhlZCh0aGlzLnZpc2l0KGlubmVyKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNpcmN1bGFyKHR5KSB7XG4gICAgICAgICAgICByZXR1cm4gJC5kZWZlcnJlZCgoKSA9PiB0aGlzLmNhY2hlW3R5LmlkXSk7XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuICh0eSkgPT4gdmlzaXRvci52aXNpdCh0eSk7XG59XG5leHBvcnQgY2xhc3MgQ2hhaW5FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2YWx1ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY29uc3QgY29tcGFjdENvZGVjVmlzaXRvciA9IG5ldyAkLkNvZGVjVmlzaXRvcigpXG4gICAgLmFkZCgkbnVsbCwgKCkgPT4gJG51bGwpXG4gICAgLmFkZCgkLnU4LCAoKSA9PiAkLmNvbXBhY3RVOClcbiAgICAuYWRkKCQudTE2LCAoKSA9PiAkLmNvbXBhY3RVMTYpXG4gICAgLmFkZCgkLnUzMiwgKCkgPT4gJC5jb21wYWN0VTMyKVxuICAgIC5hZGQoJC51NjQsICgpID0+ICQuY29tcGFjdFU2NClcbiAgICAuYWRkKCQudTEyOCwgKCkgPT4gJC5jb21wYWN0VTEyOClcbiAgICAuYWRkKCQudTI1NiwgKCkgPT4gJC5jb21wYWN0VTI1Nik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db2RlYy5qcy5tYXAiLCJpbXBvcnQgeyB1bnJlYWNoYWJsZSB9IGZyb20gXCIuLi9kZXBzL3N0ZC90ZXN0aW5nL2Fzc2VydHMuanNcIjtcbmV4cG9ydCB2YXIgQ29udHJhY3RNZXRhZGF0YTtcbihmdW5jdGlvbiAoQ29udHJhY3RNZXRhZGF0YSkge1xuICAgIC8vIFRPRE86IHN0cmljdGVyIHR5cGluZ3M/IE5vdCB0aGUgbW9zdCBuZWNlc3NhcnkgYXRtLlxuICAgIGZ1bmN0aW9uIGZyb21SYXdUeSh7IHR5cGU6IHsgZGVmLCBwYXJhbXMsIHBhdGggfSwgaWQgfSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMgPyBub3JtYWxpemVGaWVsZHMocGFyYW1zKSA6IFtdLFxuICAgICAgICAgICAgLy8gVE9ETzogZ3JhYiB0aGlzIGZyb20gYXBwcm9wcmlhdGUgbG9jXG4gICAgICAgICAgICBkb2NzOiBbXSxcbiAgICAgICAgICAgIC4uLigoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGRlZi5wcmltaXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiUHJpbWl0aXZlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBkZWYucHJpbWl0aXZlLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkZWYuY29tcG9zaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIlN0cnVjdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRzOiBub3JtYWxpemVGaWVsZHMoZGVmLmNvbXBvc2l0ZS5maWVsZHMpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkZWYudmFyaWFudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJVbmlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVtYmVyczogZGVmLnZhcmlhbnQudmFyaWFudHMubWFwKCh2YXJpYW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBmaWVsZHMsIC4uLnJlc3QgfSA9IHZhcmlhbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVtYmVyID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZHM6IGZpZWxkcyA/IG5vcm1hbGl6ZUZpZWxkcyhmaWVsZHMpIDogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnJlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRlZi50dXBsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJUdXBsZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRzOiBkZWYudHVwbGUsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRlZi5hcnJheSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJTaXplZEFycmF5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZW46IGRlZi5hcnJheS5sZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlUGFyYW06IGRlZi5hcnJheS50eXBlLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkZWYuc2VxdWVuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiU2VxdWVuY2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVQYXJhbTogZGVmLnNlcXVlbmNlLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRlZi5jb21wYWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIkNvbXBhY3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVQYXJhbTogZGVmLmNvbXBhY3QudHlwZVBhcmFtLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkZWYuYml0U2VxdWVuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiQml0U2VxdWVuY2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpdE9yZGVyVHlwZTogZGVmLmJpdFNlcXVlbmNlLmJpdE9yZGVyVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpdFN0b3JlVHlwZTogZGVmLmJpdFNlcXVlbmNlLmJpdFN0b3JlVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdW5yZWFjaGFibGUoKTtcbiAgICAgICAgICAgIH0pKCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIENvbnRyYWN0TWV0YWRhdGEuZnJvbVJhd1R5ID0gZnJvbVJhd1R5O1xuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUZpZWxkcyhmaWVsZHMpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkcy5tYXAoKHsgdHlwZTogdHksIC4uLnJlc3QgfSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHksIC4uLnJlc3QgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZSh7IFYzOiB7IHR5cGVzLCAuLi52M1Jlc3QgfSwgLi4udG9wTGV2ZWxSZXN0IH0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnRvcExldmVsUmVzdCxcbiAgICAgICAgICAgIFYzOiB7XG4gICAgICAgICAgICAgICAgLi4udjNSZXN0LFxuICAgICAgICAgICAgICAgIHR5cGVzOiB0eXBlcy5tYXAoZnJvbVJhd1R5KSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIENvbnRyYWN0TWV0YWRhdGEubm9ybWFsaXplID0gbm9ybWFsaXplO1xuICAgIGZ1bmN0aW9uIHR5cyhjb250cmFjdE1ldGFkYXRhKSB7XG4gICAgICAgIHJldHVybiBub3JtYWxpemUoY29udHJhY3RNZXRhZGF0YSkuVjMudHlwZXM7XG4gICAgfVxuICAgIENvbnRyYWN0TWV0YWRhdGEudHlzID0gdHlzO1xufSkoQ29udHJhY3RNZXRhZGF0YSB8fCAoQ29udHJhY3RNZXRhZGF0YSA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db250cmFjdC5qcy5tYXAiLCJpbXBvcnQgKiBhcyAkIGZyb20gXCIuLi9kZXBzL3NjYWxlLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gaW1tb3J0YWxFcmEoKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJJbW1vcnRhbFwiIH07XG59XG5leHBvcnQgZnVuY3Rpb24gbW9ydGFsRXJhKHBlcmlvZCwgY3VycmVudCkge1xuICAgIGNvbnN0IGFkanVzdGVkUGVyaW9kID0gbWluTihtYXhOKG5leHRQb3dlck9mVHdvKHBlcmlvZCksIDRuKSwgMW4gPDwgMTZuKTtcbiAgICBjb25zdCBwaGFzZSA9IGN1cnJlbnQgJSBhZGp1c3RlZFBlcmlvZDtcbiAgICBjb25zdCBxdWFudGl6ZUZhY3RvciA9IG1heE4oYWRqdXN0ZWRQZXJpb2QgPj4gMTJuLCAxbik7XG4gICAgY29uc3QgcXVhbnRpemVkUGhhc2UgPSBwaGFzZSAvIHF1YW50aXplRmFjdG9yICogcXVhbnRpemVGYWN0b3I7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJNb3J0YWxcIiwgcGVyaW9kOiBhZGp1c3RlZFBlcmlvZCwgcGhhc2U6IHF1YW50aXplZFBoYXNlIH07XG59XG5leHBvcnQgY29uc3QgJGVyYSA9ICQuY3JlYXRlQ29kZWMoe1xuICAgIG5hbWU6IFwiZXJhXCIsXG4gICAgX21ldGFkYXRhOiBudWxsLFxuICAgIF9zdGF0aWNTaXplOiAyLFxuICAgIF9lbmNvZGUoYnVmZmVyLCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gXCJJbW1vcnRhbFwiKSB7XG4gICAgICAgICAgICBidWZmZXIuYXJyYXlbYnVmZmVyLmluZGV4KytdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHF1YW50aXplRmFjdG9yID0gbWF4Tih2YWx1ZS5wZXJpb2QgPj4gMTJuLCAxbik7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGVkID0gbWluTihtYXhOKHRyYWlsaW5nWmVyb2VzKHZhbHVlLnBlcmlvZCkgLSAxbiwgMW4pLCAxNW4pXG4gICAgICAgICAgICAgICAgfCAoKHZhbHVlLnBoYXNlIC8gcXVhbnRpemVGYWN0b3IpIDw8IDRuKTtcbiAgICAgICAgICAgICQudTE2Ll9lbmNvZGUoYnVmZmVyLCBOdW1iZXIoZW5jb2RlZCkpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBfZGVjb2RlKGJ1ZmZlcikge1xuICAgICAgICBpZiAoYnVmZmVyLmFycmF5W2J1ZmZlci5pbmRleF0gPT09IDApIHtcbiAgICAgICAgICAgIGJ1ZmZlci5pbmRleCsrO1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJJbW1vcnRhbFwiIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGVkID0gQmlnSW50KCQudTE2Ll9kZWNvZGUoYnVmZmVyKSk7XG4gICAgICAgICAgICBjb25zdCBwZXJpb2QgPSAybiA8PCAoZW5jb2RlZCAlICgxbiA8PCA0bikpO1xuICAgICAgICAgICAgY29uc3QgcXVhbnRpemVGYWN0b3IgPSBtYXhOKHBlcmlvZCA+PiAxMm4sIDFuKTtcbiAgICAgICAgICAgIGNvbnN0IHBoYXNlID0gKGVuY29kZWQgPj4gNG4pICogcXVhbnRpemVGYWN0b3I7XG4gICAgICAgICAgICBpZiAocGVyaW9kID49IDRuICYmIHBoYXNlIDw9IHBlcmlvZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiTW9ydGFsXCIsIHBlcmlvZCwgcGhhc2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcGVyaW9kIGFuZCBwaGFzZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG59KTtcbmZ1bmN0aW9uIG1heE4oYSwgYikge1xuICAgIHJldHVybiBhID4gYiA/IGEgOiBiO1xufVxuZnVuY3Rpb24gbWluTihhLCBiKSB7XG4gICAgcmV0dXJuIGEgPiBiID8gYSA6IGI7XG59XG5mdW5jdGlvbiB0cmFpbGluZ1plcm9lcyhuKSB7XG4gICAgbGV0IGkgPSAwbjtcbiAgICB3aGlsZSAoIShuICYgMW4pKSB7XG4gICAgICAgIGkrKztcbiAgICAgICAgbiA+Pj0gMW47XG4gICAgfVxuICAgIHJldHVybiBpO1xufVxuZnVuY3Rpb24gbmV4dFBvd2VyT2ZUd28obikge1xuICAgIG4tLTtcbiAgICBsZXQgcCA9IDFuO1xuICAgIHdoaWxlIChuID4gMG4pIHtcbiAgICAgICAgcCA8PD0gMW47XG4gICAgICAgIG4gPj49IDFuO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVyYS5qcy5tYXAiLCJpbXBvcnQgKiBhcyAkIGZyb20gXCIuLi9kZXBzL3NjYWxlLmpzXCI7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tIFwiLi4vZGVwcy9zdGQvdGVzdGluZy9hc3NlcnRzLmpzXCI7XG5pbXBvcnQgKiBhcyBIIGZyb20gXCIuLi9oYXNoZXJzL21vZC5qc1wiO1xuaW1wb3J0ICogYXMgc3M1OCBmcm9tIFwiLi4vc3M1OC9tb2QuanNcIjtcbmltcG9ydCB7IGhleCB9IGZyb20gXCIuLi91dGlsL21vZC5qc1wiO1xuaW1wb3J0IHsgJG51bGwgfSBmcm9tIFwiLi9Db2RlYy5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uICRleHRyaW5zaWMocHJvcHMpIHtcbiAgICBjb25zdCB7IG1ldGFkYXRhLCBkZXJpdmVDb2RlYyB9ID0gcHJvcHM7XG4gICAgY29uc3QgeyBzaWduZWRFeHRlbnNpb25zIH0gPSBtZXRhZGF0YS5leHRyaW5zaWM7XG4gICAgY29uc3QgJHNpZyA9IGRlcml2ZUNvZGVjKGZpbmRFeHRyaW5zaWNUeXBlUGFyYW0oXCJTaWduYXR1cmVcIikpO1xuICAgIGNvbnN0ICRzaWdQcm9taXNlID0gJC5wcm9taXNlKCRzaWcpO1xuICAgIGNvbnN0ICRhZGRyZXNzID0gZGVyaXZlQ29kZWMoZmluZEV4dHJpbnNpY1R5cGVQYXJhbShcIkFkZHJlc3NcIikpO1xuICAgIGNvbnN0IGNhbGxUeSA9IGZpbmRFeHRyaW5zaWNUeXBlUGFyYW0oXCJDYWxsXCIpO1xuICAgIGFzc2VydChjYWxsVHk/LnR5cGUgPT09IFwiVW5pb25cIik7XG4gICAgY29uc3QgJGNhbGwgPSBkZXJpdmVDb2RlYyhjYWxsVHkpO1xuICAgIGNvbnN0IFskZXh0cmEsIGV4dHJhUGpzSW5mb10gPSBnZXRFeHRlbnNpb25JbmZvKHBqc0V4dHJhS2V5TWFwLCBcInR5XCIpO1xuICAgIGNvbnN0IFskYWRkaXRpb25hbCwgYWRkaXRpb25hbFBqc0luZm9dID0gZ2V0RXh0ZW5zaW9uSW5mbyhwanNBZGRpdGlvbmFsS2V5TWFwLCBcImFkZGl0aW9uYWxTaWduZWRcIik7XG4gICAgY29uc3QgcGpzSW5mbyA9IFsuLi5leHRyYVBqc0luZm8sIC4uLmFkZGl0aW9uYWxQanNJbmZvXTtcbiAgICBjb25zdCB0b1NpZ25TaXplID0gJGNhbGwuX3N0YXRpY1NpemUgKyAkZXh0cmEuX3N0YXRpY1NpemUgKyAkYWRkaXRpb25hbC5fc3RhdGljU2l6ZTtcbiAgICBjb25zdCB0b3RhbFNpemUgPSAxICsgJGFkZHJlc3MuX3N0YXRpY1NpemUgKyAkc2lnLl9zdGF0aWNTaXplICsgdG9TaWduU2l6ZTtcbiAgICBjb25zdCAkYmFzZUV4dHJpbnNpYyA9ICQuY3JlYXRlQ29kZWMoe1xuICAgICAgICBfbWV0YWRhdGE6IG51bGwsXG4gICAgICAgIF9zdGF0aWNTaXplOiB0b3RhbFNpemUsXG4gICAgICAgIF9lbmNvZGUoYnVmZmVyLCBleHRyaW5zaWMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0Qnl0ZSA9ICgrISFleHRyaW5zaWMuc2lnbmF0dXJlIDw8IDcpIHwgZXh0cmluc2ljLnByb3RvY29sVmVyc2lvbjtcbiAgICAgICAgICAgIGJ1ZmZlci5hcnJheVtidWZmZXIuaW5kZXgrK10gPSBmaXJzdEJ5dGU7XG4gICAgICAgICAgICBjb25zdCBjYWxsID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IGV4dHJpbnNpYy5wYWxsZXROYW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGV4dHJpbnNpYy5tZXRob2ROYW1lLFxuICAgICAgICAgICAgICAgICAgICAuLi5leHRyaW5zaWMuYXJncyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHsgc2lnbmF0dXJlIH0gPSBleHRyaW5zaWM7XG4gICAgICAgICAgICBpZiAoc2lnbmF0dXJlKSB7XG4gICAgICAgICAgICAgICAgJGFkZHJlc3MuX2VuY29kZShidWZmZXIsIHNpZ25hdHVyZS5hZGRyZXNzKTtcbiAgICAgICAgICAgICAgICBpZiAoXCJhZGRpdGlvbmFsXCIgaW4gc2lnbmF0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvU2lnbkJ1ZmZlciA9IG5ldyAkLkVuY29kZUJ1ZmZlcihidWZmZXIuc3RlYWxBbGxvYyh0b1NpZ25TaXplKSk7XG4gICAgICAgICAgICAgICAgICAgICRjYWxsLl9lbmNvZGUodG9TaWduQnVmZmVyLCBjYWxsKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbEVuZCA9IHRvU2lnbkJ1ZmZlci5maW5pc2hlZFNpemUgKyB0b1NpZ25CdWZmZXIuaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcInNpZ25QYXlsb2FkXCIgaW4gcHJvcHMuc2lnbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXh0cyA9IFsuLi5zaWduYXR1cmUuZXh0cmEsIC4uLnNpZ25hdHVyZS5hZGRpdGlvbmFsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4dEVuZHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGpzSW5mby5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBqc0luZm9baV0uY29kZWMuX2VuY29kZSh0b1NpZ25CdWZmZXIsIGV4dHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dEVuZHMucHVzaCh0b1NpZ25CdWZmZXIuZmluaXNoZWRTaXplICsgdG9TaWduQnVmZmVyLmluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4dHJhRW5kID0gZXh0RW5kc1tleHRyYVBqc0luZm8ubGVuZ3RoIC0gMV0gPz8gY2FsbEVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvU2lnbkVuY29kZWQgPSB0b1NpZ25CdWZmZXIuZmluaXNoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsRW5jb2RlZCA9IHRvU2lnbkVuY29kZWQuc3ViYXJyYXkoMCwgY2FsbEVuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHRyYUVuY29kZWQgPSB0b1NpZ25FbmNvZGVkLnN1YmFycmF5KGNhbGxFbmQsIGV4dHJhRW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaWduYXR1cmUuYWRkcmVzcy50eXBlICE9PSBcIklkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwb2xrYWRvdCBzaWduZXI6IGFkZHJlc3MgdHlwZXMgb3RoZXIgdGhhbiBJZCBhcmUgbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogc3M1OC5lbmNvZGUocHJvcHMucHJlZml4LCBzaWduYXR1cmUuYWRkcmVzcy52YWx1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBoZXguZW5jb2RlUHJlZml4ZWQoY2FsbEVuY29kZWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25lZEV4dGVuc2lvbnM6IHNpZ25lZEV4dGVuc2lvbnMubWFwKCh4KSA9PiB4LmlkZW50KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiBleHRyaW5zaWMucHJvdG9jb2xWZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsYXN0ID0gY2FsbEVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGpzSW5mby5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsga2V5IH0gPSBwanNJbmZvW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgha2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwb2xrYWRvdCBzaWduZXI6IHVua25vd24gZXh0ZW5zaW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWRba2V5XSA9IHR5cGVvZiBleHRzW2ldID09PSBcIm51bWJlclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZXh0c1tpXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGhleC5lbmNvZGVQcmVmaXhlZCh0b1NpZ25FbmNvZGVkLnN1YmFycmF5KGxhc3QsIGV4dEVuZHNbaV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0ID0gZXh0RW5kc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25lciA9IHByb3BzLnNpZ247XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVBc3luYygwLCBhc3luYyAoYnVmZmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzaWduYXR1cmUgfSA9IGF3YWl0IHNpZ25lci5zaWduUGF5bG9hZChwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuaW5zZXJ0QXJyYXkoaGV4LmRlY29kZShzaWduYXR1cmUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLmluc2VydEFycmF5KGV4dHJhRW5jb2RlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuaW5zZXJ0QXJyYXkoY2FsbEVuY29kZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGV4dHJhLl9lbmNvZGUodG9TaWduQnVmZmVyLCBzaWduYXR1cmUuZXh0cmEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXh0cmFFbmQgPSB0b1NpZ25CdWZmZXIuZmluaXNoZWRTaXplICsgdG9TaWduQnVmZmVyLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgJGFkZGl0aW9uYWwuX2VuY29kZSh0b1NpZ25CdWZmZXIsIHNpZ25hdHVyZS5hZGRpdGlvbmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvU2lnbkVuY29kZWQgPSB0b1NpZ25CdWZmZXIuZmluaXNoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsRW5jb2RlZCA9IHRvU2lnbkVuY29kZWQuc3ViYXJyYXkoMCwgY2FsbEVuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHRyYUVuY29kZWQgPSB0b1NpZ25FbmNvZGVkLnN1YmFycmF5KGNhbGxFbmQsIGV4dHJhRW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvU2lnbiA9IHRvU2lnbkVuY29kZWQubGVuZ3RoID4gMjU2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBILkJsYWtlMl8yNTYuaGFzaCh0b1NpZ25FbmNvZGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdG9TaWduRW5jb2RlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZyA9IHByb3BzLnNpZ24odG9TaWduKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaWcgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNpZ1Byb21pc2UuX2VuY29kZShidWZmZXIsIHNpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2lnLl9lbmNvZGUoYnVmZmVyLCBzaWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLmluc2VydEFycmF5KGV4dHJhRW5jb2RlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuaW5zZXJ0QXJyYXkoY2FsbEVuY29kZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkc2lnLl9lbmNvZGUoYnVmZmVyLCBzaWduYXR1cmUuc2lnKTtcbiAgICAgICAgICAgICAgICAgICAgJGV4dHJhLl9lbmNvZGUoYnVmZmVyLCBzaWduYXR1cmUuZXh0cmEpO1xuICAgICAgICAgICAgICAgICAgICAkY2FsbC5fZW5jb2RlKGJ1ZmZlciwgY2FsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgJGNhbGwuX2VuY29kZShidWZmZXIsIGNhbGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfZGVjb2RlKGJ1ZmZlcikge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RCeXRlID0gYnVmZmVyLmFycmF5W2J1ZmZlci5pbmRleCsrXTtcbiAgICAgICAgICAgIGNvbnN0IGhhc1NpZ25hdHVyZSA9IGZpcnN0Qnl0ZSAmICgxIDw8IDcpO1xuICAgICAgICAgICAgY29uc3QgcHJvdG9jb2xWZXJzaW9uID0gZmlyc3RCeXRlICYgfigxIDw8IDcpO1xuICAgICAgICAgICAgbGV0IHNpZ25hdHVyZTtcbiAgICAgICAgICAgIGlmIChoYXNTaWduYXR1cmUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gJGFkZHJlc3MuX2RlY29kZShidWZmZXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpZyA9ICRzaWcuX2RlY29kZShidWZmZXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4dHJhID0gJGV4dHJhLl9kZWNvZGUoYnVmZmVyKTtcbiAgICAgICAgICAgICAgICBzaWduYXR1cmUgPSB7IGFkZHJlc3MsIHNpZywgZXh0cmEgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhbGwgPSAkY2FsbC5fZGVjb2RlKGJ1ZmZlcik7XG4gICAgICAgICAgICBjb25zdCB7IHR5cGU6IHBhbGxldE5hbWUsIHZhbHVlOiB7IHR5cGU6IG1ldGhvZE5hbWUsIC4uLmFyZ3MgfSB9ID0gY2FsbDtcbiAgICAgICAgICAgIHJldHVybiB7IHByb3RvY29sVmVyc2lvbiwgc2lnbmF0dXJlLCBwYWxsZXROYW1lLCBtZXRob2ROYW1lLCBhcmdzIH07XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuICQubGVuUHJlZml4ZWQoJGJhc2VFeHRyaW5zaWMpO1xuICAgIGZ1bmN0aW9uIGZpbmRFeHRyaW5zaWNUeXBlUGFyYW0obmFtZSkge1xuICAgICAgICByZXR1cm4gbWV0YWRhdGEuZXh0cmluc2ljLnR5LnBhcmFtcy5maW5kKCh4KSA9PiB4Lm5hbWUgPT09IG5hbWUpPy50eTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uSW5mbyhrZXlNYXAsIGtleSkge1xuICAgICAgICBjb25zdCBwanNJbmZvID0gc2lnbmVkRXh0ZW5zaW9uc1xuICAgICAgICAgICAgLm1hcCgoZSkgPT4gKHsga2V5OiBrZXlNYXBbZS5pZGVudF0sIGNvZGVjOiBkZXJpdmVDb2RlYyhlW2tleV0pIH0pKVxuICAgICAgICAgICAgLmZpbHRlcigoeCkgPT4geC5jb2RlYyAhPT0gJG51bGwpO1xuICAgICAgICByZXR1cm4gWyQudHVwbGUoLi4ucGpzSW5mby5tYXAoKHgpID0+IHguY29kZWMpKSwgcGpzSW5mb107XG4gICAgfVxufVxuY29uc3QgcGpzRXh0cmFLZXlNYXAgPSB7XG4gICAgQ2hlY2tFcmE6IFwiZXJhXCIsXG4gICAgQ2hlY2tNb3J0YWxpdHk6IFwiZXJhXCIsXG4gICAgQ2hhcmdlVHJhbnNhY3Rpb25QYXltZW50OiBcInRpcFwiLFxuICAgIENoZWNrTm9uY2U6IFwibm9uY2VcIixcbn07XG5jb25zdCBwanNBZGRpdGlvbmFsS2V5TWFwID0ge1xuICAgIENoZWNrRXJhOiBcImJsb2NrSGFzaFwiLFxuICAgIENoZWNrTW9ydGFsaXR5OiBcImJsb2NrSGFzaFwiLFxuICAgIENoZWNrU3BlY1ZlcnNpb246IFwic3BlY1ZlcnNpb25cIixcbiAgICBDaGVja1R4VmVyc2lvbjogXCJ0cmFuc2FjdGlvblZlcnNpb25cIixcbiAgICBDaGVja1ZlcnNpb246IFwic3BlY1ZlcnNpb25cIixcbiAgICBDaGVja0dlbmVzaXM6IFwiZ2VuZXNpc0hhc2hcIixcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FeHRyaW5zaWMuanMubWFwIiwiaW1wb3J0ICogYXMgJCBmcm9tIFwiLi4vZGVwcy9zY2FsZS5qc1wiO1xuaW1wb3J0ICogYXMgSCBmcm9tIFwiLi4vaGFzaGVycy9tb2QuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiAkc3RvcmFnZUtleShwcm9wcykge1xuICAgIGxldCBrZXlDb2RlY3M7XG4gICAgaWYgKHByb3BzLnN0b3JhZ2VFbnRyeS50eXBlID09PSBcIk1hcFwiKSB7XG4gICAgICAgIGNvbnN0IGNvZGVjID0gcHJvcHMuZGVyaXZlQ29kZWMocHJvcHMuc3RvcmFnZUVudHJ5LmtleSk7XG4gICAgICAgIGlmIChwcm9wcy5zdG9yYWdlRW50cnkuaGFzaGVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGtleUNvZGVjcyA9IFtjb2RlY107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY29kZWMuX21ldGFkYXRhPy5bMF0gIT09ICQudHVwbGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBrZXkgY29kZWMgdG8gYmUgYSB0dXBsZSBzaW5jZSB0aGVyZSBhcmUgbXVsdGlwbGUgaGFzaGVyc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtleUNvZGVjcyA9IGNvZGVjLl9tZXRhZGF0YS5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAga2V5Q29kZWNzID0gW107XG4gICAgfVxuICAgIGNvbnN0IHBhbGxldEhhc2ggPSBILlR3b3gxMjguaGFzaChuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUocHJvcHMucGFsbGV0Lm5hbWUpKTtcbiAgICBjb25zdCBlbnRyeUhhc2ggPSBILlR3b3gxMjguaGFzaChuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUocHJvcHMuc3RvcmFnZUVudHJ5Lm5hbWUpKTtcbiAgICBjb25zdCAka2V5cyA9IFsuLi5BcnJheShrZXlDb2RlY3MubGVuZ3RoICsgMSkua2V5cygpXS5yZWR1Y2UoKGtleXMsIGkpID0+IHtcbiAgICAgICAga2V5c1tpXSA9ICQudHVwbGUoLi4ua2V5Q29kZWNzLnNsaWNlKDAsIGkpLm1hcCgoJGtleSwgaSkgPT4gSFtwcm9wcy5zdG9yYWdlRW50cnkuaGFzaGVyc1tpXV0uJGhhc2goJGtleSkpKTtcbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgfSwge30pO1xuICAgIHJldHVybiAkLmNyZWF0ZUNvZGVjKHtcbiAgICAgICAgX21ldGFkYXRhOiBbJHN0b3JhZ2VLZXksIHByb3BzXSxcbiAgICAgICAgX3N0YXRpY1NpemU6ICRrZXlzW09iamVjdC52YWx1ZXMoJGtleXMpLmxlbmd0aCAtIDFdLl9zdGF0aWNTaXplLFxuICAgICAgICBfZW5jb2RlKGJ1ZmZlciwga2V5KSB7XG4gICAgICAgICAgICBidWZmZXIuaW5zZXJ0QXJyYXkocGFsbGV0SGFzaCk7XG4gICAgICAgICAgICBidWZmZXIuaW5zZXJ0QXJyYXkoZW50cnlIYXNoKTtcbiAgICAgICAgICAgIGlmIChrZXkubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICRrZXlzW2tleS5sZW5ndGhdLl9lbmNvZGUoYnVmZmVyLCBrZXkpO1xuICAgICAgICB9LFxuICAgICAgICBfZGVjb2RlKGJ1ZmZlcikge1xuICAgICAgICAgICAgLy8gSWdub3JlIGluaXRpYWwgaGFzaGVzXG4gICAgICAgICAgICBidWZmZXIuaW5kZXggKz0gMzI7XG4gICAgICAgICAgICByZXR1cm4gJGtleXNbT2JqZWN0LnZhbHVlcygka2V5cykubGVuZ3RoIC0gMV0uX2RlY29kZShidWZmZXIpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuZXhwb3J0IGNsYXNzIFN0b3JhZ2VFbnRyeU1pc3NpbmdIYXNoZXIgZXh0ZW5kcyBFcnJvciB7XG59XG5leHBvcnQgY2xhc3MgSW52YWxpZEFyZ0VyciBleHRlbmRzIEVycm9yIHtcbn1cbmV4cG9ydCBjbGFzcyBEZWNvZGVOb25UcmFuc3BhcmVudEtleUVycm9yIGV4dGVuZHMgRXJyb3Ige1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9S2V5LmpzLm1hcCIsImltcG9ydCAqIGFzICQgZnJvbSBcIi4uL2RlcHMvc2NhbGUuanNcIjtcbmltcG9ydCAqIGFzIFUgZnJvbSBcIi4uL3V0aWwvbW9kLmpzXCI7XG5pbXBvcnQgeyAkdHlJZCwgJHR5cyB9IGZyb20gXCIuL3NjYWxlX2luZm8uanNcIjtcbmNvbnN0ICRoYXNoZXJLaW5kID0gJC5zdHJpbmdVbmlvbihbXG4gICAgXCJCbGFrZTJfMTI4XCIsXG4gICAgXCJCbGFrZTJfMjU2XCIsXG4gICAgXCJCbGFrZTJfMTI4Q29uY2F0XCIsXG4gICAgXCJUd294MTI4XCIsXG4gICAgXCJUd294MjU2XCIsXG4gICAgXCJUd294NjRDb25jYXRcIixcbiAgICBcIklkZW50aXR5XCIsXG5dKTtcbmV4cG9ydCBjb25zdCAkc3RvcmFnZUVudHJ5TW9kaWZpZXIgPSAkLnN0cmluZ1VuaW9uKFtcbiAgICBcIk9wdGlvbmFsXCIsXG4gICAgXCJEZWZhdWx0XCIsXG5dKTtcbmV4cG9ydCBjb25zdCAkc3RvcmFnZUVudHJ5VHlwZSA9ICQudGFnZ2VkVW5pb24oXCJ0eXBlXCIsIFtcbiAgICBbXCJQbGFpblwiLCBbXCJ2YWx1ZVwiLCAkdHlJZF1dLFxuICAgIFtcbiAgICAgICAgXCJNYXBcIixcbiAgICAgICAgW1wiaGFzaGVyc1wiLCAkLmFycmF5KCRoYXNoZXJLaW5kKV0sXG4gICAgICAgIFtcImtleVwiLCAkdHlJZF0sXG4gICAgICAgIFtcInZhbHVlXCIsICR0eUlkXSxcbiAgICBdLFxuXSk7XG5leHBvcnQgY29uc3QgJHN0b3JhZ2VFbnRyeSA9ICQuc3ByZWFkKCQuc3ByZWFkKCQub2JqZWN0KFtcIm5hbWVcIiwgJC5zdHJdLCBbXCJtb2RpZmllclwiLCAkc3RvcmFnZUVudHJ5TW9kaWZpZXJdKSwgJHN0b3JhZ2VFbnRyeVR5cGUpLCAkLm9iamVjdChbXCJkZWZhdWx0XCIsICQuYXJyYXkoJC51OCldLCBbXCJkb2NzXCIsICQuYXJyYXkoJC5zdHIpXSkpO1xuZXhwb3J0IGNvbnN0ICRzdG9yYWdlID0gJC5vYmplY3QoW1wicHJlZml4XCIsICQuc3RyXSwgW1wiZW50cmllc1wiLCAkLmFycmF5KCRzdG9yYWdlRW50cnkpXSk7XG5leHBvcnQgY29uc3QgJGNvbnN0YW50ID0gJC5vYmplY3QoW1wibmFtZVwiLCAkLnN0cl0sIFtcInR5XCIsICR0eUlkXSwgW1widmFsdWVcIiwgJC51aW50OEFycmF5XSwgW1wiZG9jc1wiLCAkLmFycmF5KCQuc3RyKV0pO1xuZXhwb3J0IGNvbnN0ICRwYWxsZXQgPSAkLm9iamVjdChbXCJuYW1lXCIsICQuc3RyXSwgW1wic3RvcmFnZVwiLCAkLm9wdGlvbigkc3RvcmFnZSldLCBbXCJjYWxsc1wiLCAkLm9wdGlvbigkdHlJZCldLCBbXCJldmVudFwiLCAkLm9wdGlvbigkdHlJZCldLCBbXCJjb25zdGFudHNcIiwgJC5hcnJheSgkY29uc3RhbnQpXSwgW1wiZXJyb3JcIiwgJC5vcHRpb24oJHR5SWQpXSwgW1wiaVwiLCAkLnU4XSk7XG5leHBvcnQgY29uc3QgJHNpZ25lZEV4dGVuc2lvbk1ldGFkYXRhID0gJC5vYmplY3QoW1wiaWRlbnRcIiwgJC5zdHJdLCBbXCJ0eVwiLCAkdHlJZF0sIFtcImFkZGl0aW9uYWxTaWduZWRcIiwgJHR5SWRdKTtcbmV4cG9ydCBjb25zdCAkZXh0cmluc2ljRGVmID0gJC5vYmplY3QoW1widHlcIiwgJHR5SWRdLCBbXCJ2ZXJzaW9uXCIsICQudThdLCBbXCJzaWduZWRFeHRlbnNpb25zXCIsICQuYXJyYXkoJHNpZ25lZEV4dGVuc2lvbk1ldGFkYXRhKV0pO1xuLy8gaHR0cHM6Ly9kb2NzLnN1YnN0cmF0ZS5pby92My9ydW50aW1lL21ldGFkYXRhLyNlbmNvZGVkLW1ldGFkYXRhLWZvcm1hdFxuZXhwb3J0IGNvbnN0IG1hZ2ljTnVtYmVyID0gMTYzNTAxODA5MztcbmV4cG9ydCBjb25zdCAkbWV0YWRhdGEgPSAkLm9iamVjdChbXCJtYWdpY051bWJlclwiLCAkLmNvbnN0YW50UGF0dGVybihtYWdpY051bWJlciwgJC51MzIpXSwgW1widmVyc2lvblwiLCAkLmNvbnN0YW50UGF0dGVybigxNCwgJC51OCldLCBbXCJ0eXNcIiwgJHR5c10sIFtcInBhbGxldHNcIiwgJC5hcnJheSgkcGFsbGV0KV0sIFtcImV4dHJpbnNpY1wiLCAkZXh0cmluc2ljRGVmXSk7XG5leHBvcnQgZnVuY3Rpb24gZnJvbVByZWZpeGVkSGV4KHNjYWxlRW5jb2RlZCkge1xuICAgIHJldHVybiAkbWV0YWRhdGEuZGVjb2RlKFUuaGV4LmRlY29kZShzY2FsZUVuY29kZWQpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYWxsZXQobWV0YWRhdGEsIG5hbWUpIHtcbiAgICByZXR1cm4gbWV0YWRhdGEucGFsbGV0cy5maW5kKChwYWxsZXQpID0+IHBhbGxldC5uYW1lID09PSBuYW1lKSB8fCBuZXcgUGFsbGV0Tm90Rm91bmRFcnJvcigpO1xufVxuZXhwb3J0IGNsYXNzIFBhbGxldE5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBVLkVycm9yQ3RvcihcIlBhbGxldE5vdEZvdW5kXCIpIHtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbnRyeShwYWxsZXQsIG5hbWUpIHtcbiAgICByZXR1cm4gcGFsbGV0LnN0b3JhZ2U/LmVudHJpZXMuZmluZCgoZW50cnkpID0+IGVudHJ5Lm5hbWUgPT09IG5hbWUpIHx8IG5ldyBFbnRyeU5vdEZvdW5kRXJyb3IoKTtcbn1cbmV4cG9ydCBjbGFzcyBFbnRyeU5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBVLkVycm9yQ3RvcihcIkVudHJ5Tm90Rm91bmRcIikge1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhbGxldEFuZEVudHJ5KG1ldGFkYXRhLCBwYWxsZXROYW1lLCBlbnRyeU5hbWUpIHtcbiAgICBjb25zdCBwYWxsZXQgPSBnZXRQYWxsZXQobWV0YWRhdGEsIHBhbGxldE5hbWUpO1xuICAgIGlmIChwYWxsZXQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gcGFsbGV0O1xuICAgIH1cbiAgICBjb25zdCBlbnRyeSA9IGdldEVudHJ5KHBhbGxldCwgZW50cnlOYW1lKTtcbiAgICBpZiAoZW50cnkgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgfVxuICAgIHJldHVybiBbcGFsbGV0LCBlbnRyeV07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NZXRhZGF0YS5qcy5tYXAiLCJleHBvcnQgY2xhc3MgVHlWaXNpdG9yIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXMsIG1ldGhvZHMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHlzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0eXNcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhY2hlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB7fVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBtZXRob2RzKTtcbiAgICB9XG4gICAgdmlzaXQodHkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0eSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdHkgPSB0aGlzLnR5c1t0eV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaSA9IHR5LmlkO1xuICAgICAgICBpZiAodGhpcy5jYWNoZVtpXSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVtpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jYWNoZVtpXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2lyY3VsYXIodHkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FjaGVbaV0gPSBudWxsOyAvLyBjaXJjdWxhcml0eSBkZXRlY3Rpb25cbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLl92aXNpdCh0eSk7XG4gICAgICAgIHRoaXMuY2FjaGVbaV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBfdmlzaXQodHkpIHtcbiAgICAgICAgaWYgKHR5LnR5cGUgPT09IFwiU3RydWN0XCIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hcCAmJiB0eS5wYXRoWzBdID09PSBcIkJUcmVlTWFwXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYXAodHksIHR5LnBhcmFtc1swXS50eSwgdHkucGFyYW1zWzFdLnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc2V0ICYmIHR5LnBhdGhbMF0gPT09IFwiQlRyZWVTZXRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldCh0eSwgdHkucGFyYW1zWzBdLnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5LnBhdGguYXQoLTEpID09PSBcIldyYXBwZXJPcGFxdWVcIiB8fCB0eS5wYXRoLmF0KC0xKSA9PT0gXCJXcmFwcGVyS2VlcE9wYXF1ZVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVuUHJlZml4ZWRXcmFwcGVyKHR5LCB0eS5wYXJhbXNbMF0udHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHkuZmllbGRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaXRTdHJ1Y3QodHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHkuZmllbGRzWzBdLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICh0eS5maWVsZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndyYXBwZXJTdHJ1Y3QodHksIHR5LmZpZWxkc1swXS50eSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50dXBsZVN0cnVjdCh0eSwgdHkuZmllbGRzLm1hcCgoeCkgPT4geC50eSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iamVjdFN0cnVjdCh0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHkudHlwZSA9PT0gXCJUdXBsZVwiKSB7XG4gICAgICAgICAgICBpZiAodHkuZmllbGRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaXRTdHJ1Y3QodHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHkuZmllbGRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndyYXBwZXJTdHJ1Y3QodHksIHR5LmZpZWxkc1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50dXBsZVN0cnVjdCh0eSwgdHkuZmllbGRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eS50eXBlID09PSBcIlVuaW9uXCIpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHJldmlzaXQgT3B0aW9uIGFuZCBSZXN1bHRcbiAgICAgICAgICAgIGlmICh0eS5wYXRoWzBdID09PSBcIk9wdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uKHR5LCB0eS5wYXJhbXNbMF0udHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHkucGF0aFswXSA9PT0gXCJSZXN1bHRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdCh0eSwgdHkucGFyYW1zWzBdLnR5LCB0eS5wYXJhbXNbMV0udHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5lcmEgJiYgdHkucGF0aC5hdCgtMSkgPT09IFwiRXJhXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcmEodHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHkubWVtYmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZXZlcih0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eS5tZW1iZXJzLmV2ZXJ5KCh4KSA9PiB4LmZpZWxkcy5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nVW5pb24odHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFnZ2VkVW5pb24odHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5LnR5cGUgPT09IFwiU2VxdWVuY2VcIikge1xuICAgICAgICAgICAgaWYgKHRoaXMudWludDhBcnJheSAmJiBfaXNVOCh0eS50eXBlUGFyYW0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudWludDhBcnJheSh0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hcnJheSh0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHkudHlwZSA9PT0gXCJTaXplZEFycmF5XCIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNpemVkVWludDhBcnJheSAmJiBfaXNVOCh0eS50eXBlUGFyYW0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZWRVaW50OEFycmF5KHR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNpemVkQXJyYXkodHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5LnR5cGUgPT09IFwiUHJpbWl0aXZlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByaW1pdGl2ZSh0eSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHkudHlwZSA9PT0gXCJDb21wYWN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBhY3QodHkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5LnR5cGUgPT09IFwiQml0U2VxdWVuY2VcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYml0U2VxdWVuY2UodHkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5yZWFjaGFibGVcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBfaXNVOCh0eSkge1xuICAgIHJldHVybiB0eS50eXBlID09PSBcIlByaW1pdGl2ZVwiICYmIHR5LmtpbmQgPT09IFwidThcIjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVR5VmlzaXRvci5qcy5tYXAiLCJleHBvcnQgKiBmcm9tIFwiLi9Db2RlYy5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vQ29udHJhY3QuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL0VyYS5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vRXh0cmluc2ljLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9LZXkuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL01ldGFkYXRhLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9zY2FsZV9pbmZvLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9UeVZpc2l0b3IuanNcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZC5qcy5tYXAiLCJpbXBvcnQgKiBhcyAkIGZyb20gXCIuLi9kZXBzL3NjYWxlLmpzXCI7XG5leHBvcnQgY2xhc3MgVHlEZWNvZGVDdHgge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0eXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0ICR0eXMgPSAkLmNyZWF0ZUNvZGVjKHtcbiAgICBuYW1lOiBcInR5c1wiLFxuICAgIF9tZXRhZGF0YTogbnVsbCxcbiAgICBfc3RhdGljU2l6ZTogJC5jb21wYWN0VTMyLl9zdGF0aWNTaXplLFxuICAgIF9lbmNvZGUoYnVmZmVyLCB2YWx1ZSkge1xuICAgICAgICAkLmFycmF5KCR0eSkuX2VuY29kZShidWZmZXIsIHZhbHVlKTtcbiAgICB9LFxuICAgIF9kZWNvZGUoYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9ICQuY29tcGFjdFUzMi5fZGVjb2RlKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IGN0eCA9IGJ1ZmZlci5jb250ZXh0LmdldChUeURlY29kZUN0eCk7XG4gICAgICAgIGNvbnN0IHR5cyA9IGN0eC50eXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoIH0sIChfLCBpZCkgPT4gKHsgaWQgfSkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5c1tpXSwgJHR5Ll9kZWNvZGUoYnVmZmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cztcbiAgICB9LFxufSk7XG5leHBvcnQgY29uc3QgJHR5SWQgPSAkLmNyZWF0ZUNvZGVjKHtcbiAgICBuYW1lOiBcInR5SWRcIixcbiAgICBfbWV0YWRhdGE6IG51bGwsXG4gICAgX3N0YXRpY1NpemU6ICQuY29tcGFjdFUzMi5fc3RhdGljU2l6ZSxcbiAgICBfZW5jb2RlKGJ1ZmZlciwgdmFsdWUpIHtcbiAgICAgICAgJC5jb21wYWN0VTMyLl9lbmNvZGUoYnVmZmVyLCB2YWx1ZS5pZCk7XG4gICAgfSxcbiAgICBfZGVjb2RlKGJ1ZmZlcikge1xuICAgICAgICBjb25zdCBjdHggPSBidWZmZXIuY29udGV4dC5nZXQoVHlEZWNvZGVDdHgpO1xuICAgICAgICBjb25zdCBpZCA9ICQuY29tcGFjdFUzMi5fZGVjb2RlKGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiBjdHgudHlzPy5baWRdID8/IHsgaWQgfTtcbiAgICB9LFxufSk7XG5leHBvcnQgY29uc3QgJGZpZWxkID0gJC5vYmplY3QoW1wibmFtZVwiLCAkLm9wdGlvbigkLnN0cildLCBbXCJ0eVwiLCAkdHlJZF0sIFtcInR5cGVOYW1lXCIsICQub3B0aW9uKCQuc3RyKV0sIFtcImRvY3NcIiwgJC5hcnJheSgkLnN0cildKTtcbmNvbnN0ICRwcmltaXRpdmVLaW5kID0gJC5zdHJpbmdVbmlvbihbXG4gICAgXCJib29sXCIsXG4gICAgXCJjaGFyXCIsXG4gICAgXCJzdHJcIixcbiAgICBcInU4XCIsXG4gICAgXCJ1MTZcIixcbiAgICBcInUzMlwiLFxuICAgIFwidTY0XCIsXG4gICAgXCJ1MTI4XCIsXG4gICAgXCJ1MjU2XCIsXG4gICAgXCJpOFwiLFxuICAgIFwiaTE2XCIsXG4gICAgXCJpMzJcIixcbiAgICBcImk2NFwiLFxuICAgIFwiaTEyOFwiLFxuICAgIFwiaTI1NlwiLFxuXSk7XG5leHBvcnQgY29uc3QgJHR5RGVmID0gJC50YWdnZWRVbmlvbihcInR5cGVcIiwgW1xuICAgIFtcbiAgICAgICAgXCJTdHJ1Y3RcIixcbiAgICAgICAgW1wiZmllbGRzXCIsICQuYXJyYXkoJGZpZWxkKV0sXG4gICAgXSxcbiAgICBbXG4gICAgICAgIFwiVW5pb25cIixcbiAgICAgICAgW1xuICAgICAgICAgICAgXCJtZW1iZXJzXCIsXG4gICAgICAgICAgICAkLmFycmF5KCQub2JqZWN0KFtcIm5hbWVcIiwgJC5zdHJdLCBbXCJmaWVsZHNcIiwgJC5hcnJheSgkZmllbGQpXSwgW1wiaW5kZXhcIiwgJC51OF0sIFtcImRvY3NcIiwgJC5hcnJheSgkLnN0cildKSksXG4gICAgICAgIF0sXG4gICAgXSxcbiAgICBbXG4gICAgICAgIFwiU2VxdWVuY2VcIixcbiAgICAgICAgW1widHlwZVBhcmFtXCIsICR0eUlkXSxcbiAgICBdLFxuICAgIFtcbiAgICAgICAgXCJTaXplZEFycmF5XCIsXG4gICAgICAgIFtcImxlblwiLCAkLnUzMl0sXG4gICAgICAgIFtcInR5cGVQYXJhbVwiLCAkdHlJZF0sXG4gICAgXSxcbiAgICBbXG4gICAgICAgIFwiVHVwbGVcIixcbiAgICAgICAgW1wiZmllbGRzXCIsICQuYXJyYXkoJHR5SWQpXSxcbiAgICBdLFxuICAgIFtcbiAgICAgICAgXCJQcmltaXRpdmVcIixcbiAgICAgICAgW1wia2luZFwiLCAkcHJpbWl0aXZlS2luZF0sXG4gICAgXSxcbiAgICBbXG4gICAgICAgIFwiQ29tcGFjdFwiLFxuICAgICAgICBbXCJ0eXBlUGFyYW1cIiwgJHR5SWRdLFxuICAgIF0sXG4gICAgW1xuICAgICAgICBcIkJpdFNlcXVlbmNlXCIsXG4gICAgICAgIFtcImJpdE9yZGVyVHlwZVwiLCAkdHlJZF0sXG4gICAgICAgIFtcImJpdFN0b3JlVHlwZVwiLCAkdHlJZF0sXG4gICAgXSxcbl0pO1xuZXhwb3J0IGNvbnN0ICRwYXJhbSA9ICQub2JqZWN0KFtcIm5hbWVcIiwgJC5zdHJdLCBbXCJ0eVwiLCAkLm9wdGlvbigkdHlJZCldKTtcbmV4cG9ydCBjb25zdCAkdHkgPSAkLnNwcmVhZCgkLnNwcmVhZCgkLm9iamVjdChbXCJpZFwiLCAkLmNvbXBhY3RVMzJdLCBbXCJwYXRoXCIsICQuYXJyYXkoJC5zdHIpXSwgW1wicGFyYW1zXCIsICQuYXJyYXkoJHBhcmFtKV0pLCAkdHlEZWYpLCAkLm9iamVjdChbXCJkb2NzXCIsICQuYXJyYXkoJC5zdHIpXSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NhbGVfaW5mby5qcy5tYXAiLCJpbXBvcnQgeyBibGFrZTJiIH0gZnJvbSBcIi4uL2RlcHMvYmxha2UyYi5qc1wiO1xuaW1wb3J0ICogYXMgJCBmcm9tIFwiLi4vZGVwcy9zY2FsZS5qc1wiO1xuaW1wb3J0IHsgRW5jb2RlQnVmZmVyIH0gZnJvbSBcIi4uL2RlcHMvc2NhbGUuanNcIjtcbmltcG9ydCB7IERlY29kZU5vblRyYW5zcGFyZW50S2V5RXJyb3IgfSBmcm9tIFwiLi4vZnJhbWVfbWV0YWRhdGEvS2V5LmpzXCI7XG5pbXBvcnQgeyBYeGhhc2ggfSBmcm9tIFwiLi94eGhhc2guanNcIjtcbmV4cG9ydCBjbGFzcyBIYXNoZXIge1xuICAgICRoYXNoKCRpbm5lcikge1xuICAgICAgICByZXR1cm4gJC5jcmVhdGVDb2RlYyh7XG4gICAgICAgICAgICBfbWV0YWRhdGE6IG51bGwsXG4gICAgICAgICAgICBfc3RhdGljU2l6ZTogdGhpcy5kaWdlc3RMZW5ndGggKyAkaW5uZXIuX3N0YXRpY1NpemUsXG4gICAgICAgICAgICBfZW5jb2RlOiAoYnVmZmVyLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc2hBcnJheSA9IGJ1ZmZlci5hcnJheS5zdWJhcnJheShidWZmZXIuaW5kZXgsIGJ1ZmZlci5pbmRleCArPSB0aGlzLmRpZ2VzdExlbmd0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gdGhpcy5jb25jYXRcbiAgICAgICAgICAgICAgICAgICAgPyBidWZmZXIuY3JlYXRlQ3Vyc29yKCRpbm5lci5fc3RhdGljU2l6ZSlcbiAgICAgICAgICAgICAgICAgICAgOiBuZXcgRW5jb2RlQnVmZmVyKGJ1ZmZlci5zdGVhbEFsbG9jKCRpbm5lci5fc3RhdGljU2l6ZSkpO1xuICAgICAgICAgICAgICAgICRpbm5lci5fZW5jb2RlKGN1cnNvciwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlci53YWl0Rm9yQnVmZmVyKGN1cnNvciwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25jYXQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLl9jb21taXRXcml0dGVuKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc2hpbmcgPSB0aGlzLmNyZWF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVIYXNoaW5nKGhhc2hpbmcsIGN1cnNvcik7XG4gICAgICAgICAgICAgICAgICAgIGhhc2hpbmcuZGlnZXN0SW50byhoYXNoQXJyYXkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9kZWNvZGU6IChidWZmZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29uY2F0KVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRGVjb2RlTm9uVHJhbnNwYXJlbnRLZXlFcnJvcigpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5pbmRleCArPSB0aGlzLmRpZ2VzdExlbmd0aDtcbiAgICAgICAgICAgICAgICByZXR1cm4gJGlubmVyLl9kZWNvZGUoYnVmZmVyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYXNoKGRhdGEpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5kaWdlc3RMZW5ndGggKyAodGhpcy5jb25jYXQgPyBkYXRhLmxlbmd0aCA6IDApKTtcbiAgICAgICAgY29uc3QgaGFzaGluZyA9IHRoaXMuY3JlYXRlKCk7XG4gICAgICAgIGhhc2hpbmcudXBkYXRlKGRhdGEpO1xuICAgICAgICBoYXNoaW5nLmRpZ2VzdEludG8ob3V0cHV0KTtcbiAgICAgICAgaWYgKHRoaXMuY29uY2F0KSB7XG4gICAgICAgICAgICBvdXRwdXQuc2V0KGRhdGEsIHRoaXMuZGlnZXN0TGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBCbGFrZTJIYXNoZXIgZXh0ZW5kcyBIYXNoZXIge1xuICAgIGNvbnN0cnVjdG9yKHNpemUsIGNvbmNhdCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb25jYXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGNvbmNhdFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGlnZXN0TGVuZ3RoXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGlnZXN0TGVuZ3RoID0gc2l6ZSAvIDg7XG4gICAgfVxuICAgIGNyZWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIGJsYWtlMmIuY3JlYXRlKHsgZGtMZW46IHRoaXMuZGlnZXN0TGVuZ3RoIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBJZGVudGl0eUhhc2hlciBleHRlbmRzIEhhc2hlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRpZ2VzdExlbmd0aFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29uY2F0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1cGRhdGUoKSB7IH0sXG4gICAgICAgICAgICBkaWdlc3RJbnRvKCkgeyB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAkaGFzaCgkaW5uZXIpIHtcbiAgICAgICAgcmV0dXJuICRpbm5lcjtcbiAgICB9XG4gICAgaGFzaChkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhLnNsaWNlKCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFR3b3hIYXNoZXIgZXh0ZW5kcyBIYXNoZXIge1xuICAgIGNvbnN0cnVjdG9yKHNpemUsIGNvbmNhdCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb25jYXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGNvbmNhdFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGlnZXN0TGVuZ3RoXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJvdW5kc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRpZ2VzdExlbmd0aCA9IHNpemUgLyA4O1xuICAgICAgICB0aGlzLnJvdW5kcyA9IHNpemUgLyA2NDtcbiAgICB9XG4gICAgY3JlYXRlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFh4aGFzaCh0aGlzLnJvdW5kcyk7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IEJsYWtlMl8xMjggPSBuZXcgQmxha2UySGFzaGVyKDEyOCwgZmFsc2UpO1xuZXhwb3J0IGNvbnN0IEJsYWtlMl8xMjhDb25jYXQgPSBuZXcgQmxha2UySGFzaGVyKDEyOCwgdHJ1ZSk7XG5leHBvcnQgY29uc3QgQmxha2UyXzI1NiA9IG5ldyBCbGFrZTJIYXNoZXIoMjU2LCBmYWxzZSk7XG5leHBvcnQgY29uc3QgSWRlbnRpdHkgPSBuZXcgSWRlbnRpdHlIYXNoZXIoKTtcbmV4cG9ydCBjb25zdCBUd294MTI4ID0gbmV3IFR3b3hIYXNoZXIoMTI4LCBmYWxzZSk7XG5leHBvcnQgY29uc3QgVHdveDI1NiA9IG5ldyBUd294SGFzaGVyKDI1NiwgZmFsc2UpO1xuZXhwb3J0IGNvbnN0IFR3b3g2NENvbmNhdCA9IG5ldyBUd294SGFzaGVyKDY0LCB0cnVlKTtcbmZ1bmN0aW9uIHVwZGF0ZUhhc2hpbmcoaGFzaGluZywgZGF0YSkge1xuICAgIGZvciAoY29uc3QgYXJyYXkgb2YgZGF0YS5maW5pc2hlZEFycmF5cykge1xuICAgICAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBFbmNvZGVCdWZmZXIpIHtcbiAgICAgICAgICAgIHVwZGF0ZUhhc2hpbmcoaGFzaGluZywgYXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGFzaGluZy51cGRhdGUoYXJyYXkpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kLmpzLm1hcCIsIi8qXG4gIENvcHlyaWdodCAyMDIyIFBhcml0eSBUZWNobm9sb2dpZXNcbiAgU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAgQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9wb2xrYWRvdC1qcy9jb21tb24vYmxvYi80MGQ2YTM4OC9wYWNrYWdlcy91dGlsLWNyeXB0by9zcmMveHhoYXNoL3h4aGFzaDY0LnRzXG5cclxuICBDb3B5cmlnaHQgMjAxNy0yMDIyIEBwb2xrYWRvdC91dGlsLWNyeXB0byBhdXRob3JzICYgY29udHJpYnV0b3JzXG4gIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vcGllcnJlYy9qcy14eGhhc2gvYmxvYi8wNTA0ZTc2ZjNkMzFhMjFhZTg1MjhhN2Y1OTBjNzI4OWM5ZTQzMWQyL2xpYi94eGhhc2g2NC5qc1xuXHJcbiAgeHhIYXNoNjQgaW1wbGVtZW50YXRpb24gaW4gcHVyZSBKYXZhc2NyaXB0XG4gIENvcHlyaWdodCAoQykgMjAxNiwgUGllcnJlIEN1cnRvXG5cclxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXHJcbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cclxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5jb25zdCBQNjRfMSA9IDExNDAwNzE0Nzg1MDc0Njk0NzkxbjtcbmNvbnN0IFA2NF8yID0gMTQwMjk0NjczNjY4OTcwMTk3MjduO1xuY29uc3QgUDY0XzMgPSAxNjA5NTg3OTI5MzkyODM5MTYxbjtcbmNvbnN0IFA2NF80ID0gOTY1MDAyOTI0MjI4NzgyODU3OW47XG5jb25zdCBQNjRfNSA9IDI4NzAxNzc0NTAwMTI2MDAyNjFuO1xuLy8gbWFzayBmb3IgYSB1NjQsIGFsbCBiaXRzIHNldFxuY29uc3QgVTY0ID0gMHhmZmZmZmZmZmZmZmZmZmZmbjtcbmZ1bmN0aW9uIHJvdGwoYSwgYikge1xuICAgIGNvbnN0IGMgPSBhICYgVTY0O1xuICAgIHJldHVybiAoKGMgPDwgYikgfCAoYyA+PiAoNjRuIC0gYikpKSAmIFU2NDtcbn1cbmV4cG9ydCBjbGFzcyBYeGhhc2gge1xuICAgIGNvbnN0cnVjdG9yKHJvdW5kcykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyb3VuZHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHJvdW5kc1xuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYnVmXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgVWludDhBcnJheSgzMilcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZpZXdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBEYXRhVmlldyh0aGlzLmJ1Zi5idWZmZXIpXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJidWZJXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ3cml0dGVuXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnZzID0gbmV3IEJpZ1VpbnQ2NEFycmF5KHJvdW5kcyAqIDQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgc2VlZCA9IDBuOyBpIDwgdGhpcy52cy5sZW5ndGg7IHNlZWQrKykge1xuICAgICAgICAgICAgdGhpcy52c1tpKytdID0gc2VlZCArIFA2NF8xICsgUDY0XzI7XG4gICAgICAgICAgICB0aGlzLnZzW2krK10gPSBzZWVkICsgUDY0XzI7XG4gICAgICAgICAgICB0aGlzLnZzW2krK10gPSBzZWVkO1xuICAgICAgICAgICAgdGhpcy52c1tpKytdID0gc2VlZCAtIFA2NF8xO1xuICAgICAgICB9XG4gICAgfVxuICAgIF91cGRhdGVWcyh2aWV3LCBwKSB7XG4gICAgICAgIGNvbnN0IGEgPSB2aWV3LmdldEJpZ1VpbnQ2NChwLCB0cnVlKTtcbiAgICAgICAgY29uc3QgYiA9IHZpZXcuZ2V0QmlnVWludDY0KHAgKyA4LCB0cnVlKTtcbiAgICAgICAgY29uc3QgYyA9IHZpZXcuZ2V0QmlnVWludDY0KHAgKyAxNiwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IGQgPSB2aWV3LmdldEJpZ1VpbnQ2NChwICsgMjQsIHRydWUpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudnMubGVuZ3RoOykge1xuICAgICAgICAgICAgdGhpcy52c1tpXSA9IFA2NF8xICogcm90bCh0aGlzLnZzW2krK10gKyBQNjRfMiAqIGEsIDMxbik7XG4gICAgICAgICAgICB0aGlzLnZzW2ldID0gUDY0XzEgKiByb3RsKHRoaXMudnNbaSsrXSArIFA2NF8yICogYiwgMzFuKTtcbiAgICAgICAgICAgIHRoaXMudnNbaV0gPSBQNjRfMSAqIHJvdGwodGhpcy52c1tpKytdICsgUDY0XzIgKiBjLCAzMW4pO1xuICAgICAgICAgICAgdGhpcy52c1tpXSA9IFA2NF8xICogcm90bCh0aGlzLnZzW2krK10gKyBQNjRfMiAqIGQsIDMxbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlKGlucHV0KSB7XG4gICAgICAgIHRoaXMud3JpdHRlbiArPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgaWYgKHRoaXMuYnVmSSkge1xuICAgICAgICAgICAgaSA9IE1hdGgubWluKGlucHV0Lmxlbmd0aCwgMzIgLSB0aGlzLmJ1ZkkpO1xuICAgICAgICAgICAgdGhpcy5idWYuc2V0KGlucHV0LnN1YmFycmF5KDAsIGkpLCB0aGlzLmJ1ZkkpO1xuICAgICAgICAgICAgdGhpcy5idWZJICs9IGk7XG4gICAgICAgICAgICBpZiAodGhpcy5idWZJIDwgMzIpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVnModGhpcy52aWV3LCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA8PSBpbnB1dC5sZW5ndGggLSAzMikge1xuICAgICAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhpbnB1dC5idWZmZXIsIGlucHV0LmJ5dGVPZmZzZXQsIGlucHV0LmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVZzKHZpZXcsIGkpO1xuICAgICAgICAgICAgICAgIGkgKz0gMzI7XG4gICAgICAgICAgICB9IHdoaWxlIChpICsgMzIgPD0gaW5wdXQubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1Zi5zZXQoaW5wdXQuc3ViYXJyYXkoaSkpO1xuICAgICAgICB0aGlzLmJ1ZkkgPSBpbnB1dC5sZW5ndGggLSBpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpZ2VzdEludG8obmV3IFVpbnQ4QXJyYXkodGhpcy5yb3VuZHMgKiA4KSk7XG4gICAgfVxuICAgIGRpZ2VzdEludG8oZGlnZXN0KSB7XG4gICAgICAgIGNvbnN0IGRpZ2VzdFZpZXcgPSBuZXcgRGF0YVZpZXcoZGlnZXN0LmJ1ZmZlciwgZGlnZXN0LmJ5dGVPZmZzZXQsIGRpZ2VzdC5ieXRlTGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvdW5kczsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB2MCA9IHRoaXMudnNbaSAqIDRdO1xuICAgICAgICAgICAgY29uc3QgdjEgPSB0aGlzLnZzW2kgKiA0ICsgMV07XG4gICAgICAgICAgICBjb25zdCB2MiA9IHRoaXMudnNbaSAqIDQgKyAyXTtcbiAgICAgICAgICAgIGNvbnN0IHYzID0gdGhpcy52c1tpICogNCArIDNdO1xuICAgICAgICAgICAgbGV0IGg2NCA9IDBuO1xuICAgICAgICAgICAgaWYgKHRoaXMud3JpdHRlbiA+PSAzMikge1xuICAgICAgICAgICAgICAgIGg2NCA9IFU2NCAmIChyb3RsKHYwLCAxbikgKyByb3RsKHYxLCA3bikgKyByb3RsKHYyLCAxMm4pICsgcm90bCh2MywgMThuKSk7XG4gICAgICAgICAgICAgICAgaDY0ID0gVTY0ICYgKChoNjQgXiAoUDY0XzEgKiByb3RsKHYwICogUDY0XzIsIDMxbikpKSAqIFA2NF8xICsgUDY0XzQpO1xuICAgICAgICAgICAgICAgIGg2NCA9IFU2NCAmICgoaDY0IF4gKFA2NF8xICogcm90bCh2MSAqIFA2NF8yLCAzMW4pKSkgKiBQNjRfMSArIFA2NF80KTtcbiAgICAgICAgICAgICAgICBoNjQgPSBVNjQgJiAoKGg2NCBeIChQNjRfMSAqIHJvdGwodjIgKiBQNjRfMiwgMzFuKSkpICogUDY0XzEgKyBQNjRfNCk7XG4gICAgICAgICAgICAgICAgaDY0ID0gVTY0ICYgKChoNjQgXiAoUDY0XzEgKiByb3RsKHYzICogUDY0XzIsIDMxbikpKSAqIFA2NF8xICsgUDY0XzQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaDY0ID0gQmlnSW50KGkpICsgUDY0XzU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoNjQgPSBVNjQgJiAoQmlnSW50KHRoaXMud3JpdHRlbikgKyBoNjQpO1xuICAgICAgICAgICAgbGV0IHAgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKHAgKyA4IDw9IHRoaXMuYnVmSSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG4gPSB0aGlzLnZpZXcuZ2V0QmlnVWludDY0KHAsIHRydWUpO1xuICAgICAgICAgICAgICAgIGg2NCA9IFU2NCAmIChQNjRfNCArIFA2NF8xICogcm90bChoNjQgXiAoUDY0XzEgKiByb3RsKFA2NF8yICogbiwgMzFuKSksIDI3bikpO1xuICAgICAgICAgICAgICAgIHAgKz0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwICsgNCA8PSB0aGlzLmJ1ZkkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuID0gQmlnSW50KHRoaXMudmlldy5nZXRVaW50MzIocCwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgIGg2NCA9IFU2NCAmIChQNjRfMyArIFA2NF8yICogcm90bChoNjQgXiAoUDY0XzEgKiBuKSwgMjNuKSk7XG4gICAgICAgICAgICAgICAgcCArPSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKHAgPCB0aGlzLmJ1ZkkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuID0gQmlnSW50KHRoaXMuYnVmW3ArK10pO1xuICAgICAgICAgICAgICAgIGg2NCA9IFU2NCAmIChQNjRfMSAqIHJvdGwoaDY0IF4gKFA2NF81ICogbiksIDExbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaDY0ID0gVTY0ICYgKFA2NF8yICogKGg2NCBeIChoNjQgPj4gMzNuKSkpO1xuICAgICAgICAgICAgaDY0ID0gVTY0ICYgKFA2NF8zICogKGg2NCBeIChoNjQgPj4gMjluKSkpO1xuICAgICAgICAgICAgaDY0ID0gVTY0ICYgKGg2NCBeIChoNjQgPj4gMzJuKSk7XG4gICAgICAgICAgICBkaWdlc3RWaWV3LnNldEJpZ1VpbnQ2NChpICogOCwgaDY0LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlnZXN0O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXh4aGFzaC5qcy5tYXAiLCIvLyBUT0RPOiB1bHRpbWF0ZWx5IGRlbGV0ZSB0aGlzIGZpbGUgdXBvbiBpbnRyb2R1Y3Rpb24gb2YgUlBDLW1ldGhvZC1zcGVjaWZpYyBjb2RlZ2VuXG5pbXBvcnQgeyBDb25maWcgfSBmcm9tIFwiLi4vY29uZmlnL21vZC5qc1wiO1xuLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGFyaXR5dGVjaC9jYXBpL2lzc3Vlcy8xMjdcbmNvbnN0IENvbmZpZ18gPSAoQ29uZmlnKTtcbmV4cG9ydCBjb25zdCBwb2xrYWRvdCA9IG5ldyBDb25maWdfKCgpID0+IFwid3NzOi8vcnBjLnBvbGthZG90LmlvXCIsIDApO1xuZXhwb3J0IGNvbnN0IGt1c2FtYSA9IG5ldyBDb25maWdfKCgpID0+IFwid3NzOi8va3VzYW1hLXJwYy5wb2xrYWRvdC5pb1wiLCAyKTtcbmV4cG9ydCBjb25zdCBhY2FsYSA9IG5ldyBDb25maWdfKCgpID0+IFwid3NzOi8vYWNhbGEtcG9sa2Fkb3QuYXBpLm9uZmluYWxpdHkuaW8vcHVibGljLXdzXCIsIDEwKTtcbmV4cG9ydCBjb25zdCByb2NvY28gPSBuZXcgQ29uZmlnXygoKSA9PiBcIndzczovL3JvY29jby1jb250cmFjdHMtcnBjLnBvbGthZG90LmlvXCIsIHVuZGVmaW5lZCk7XG5leHBvcnQgY29uc3QgbW9vbmJlYW0gPSBuZXcgQ29uZmlnXygoKSA9PiBcIndzczovL3dzcy5hcGkubW9vbmJlYW0ubmV0d29ya1wiLCAxMjg0KTtcbmV4cG9ydCBjb25zdCBzdGF0ZW1pbnQgPSBuZXcgQ29uZmlnXygoKSA9PiBcIndzczovL3N0YXRlbWludC1ycGMucG9sa2Fkb3QuaW9cIiwgdW5kZWZpbmVkKTtcbmV4cG9ydCBjb25zdCBzdWJzb2NpYWwgPSBuZXcgQ29uZmlnXygoKSA9PiBcIndzczovL3BhcmEuc3Vic29jaWFsLm5ldHdvcmtcIiwgMjgpO1xuZXhwb3J0IGNvbnN0IHdlc3RlbmQgPSBuZXcgQ29uZmlnXygoKSA9PiBcIndzczovL3dlc3RlbmQtcnBjLnBvbGthZG90LmlvXCIsIDQyKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmZpZ3MuanMubWFwIiwiZXhwb3J0ICogZnJvbSBcIi4vY29uZmlncy5qc1wiO1xuZXhwb3J0ICogYXMgcnBjIGZyb20gXCIuL3JwYy5qc1wiO1xuZXhwb3J0ICogYXMgdHlwZXMgZnJvbSBcIi4vdHlwZXMvbW9kLmpzXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2QuanMubWFwIiwiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cnBjLmpzLm1hcCIsImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dGhvci5qcy5tYXAiLCIvLyBUT0RPOiBjbGVhbiB0aGlzIHVwIVxuZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmVlZnkuanMubWFwIiwiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9sbG93LmpzLm1hcCIsImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbW1vbi5qcy5tYXAiLCJleHBvcnQgKiBmcm9tIFwiLi9hdXRob3IuanNcIjtcbmV4cG9ydCAqIGFzIGJlZWZ5IGZyb20gXCIuL2JlZWZ5LmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9jaGFpbl9oZWFkL3Vuc3RhYmxlL2ZvbGxvdy5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vY29tbW9uLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9zdGF0ZS5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vc3lzdGVtLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi90b2RvX29yZ2FuaXplX3RoZXNlLmpzXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2QuanMubWFwIiwiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdGUuanMubWFwIiwiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3lzdGVtLmpzLm1hcCIsImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvZG9fb3JnYW5pemVfdGhlc2UuanMubWFwIiwiZXhwb3J0ICogZnJvbSBcIi4vY29uZmlnL21vZC5qc1wiO1xuZXhwb3J0ICogYXMgJCBmcm9tIFwiLi9kZXBzL3NjYWxlLmpzXCI7XG5leHBvcnQgeyBCaXRTZXF1ZW5jZSB9IGZyb20gXCIuL2RlcHMvc2NhbGUuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2VmZmVjdC9tb2QuanNcIjtcbmV4cG9ydCAqIGFzIE0gZnJvbSBcIi4vZnJhbWVfbWV0YWRhdGEvbW9kLmpzXCI7XG5leHBvcnQgeyAkZXJhLCAkbnVsbCwgQ2hhaW5FcnJvciB9IGZyb20gXCIuL2ZyYW1lX21ldGFkYXRhL21vZC5qc1wiO1xuZXhwb3J0IHsga3VzYW1hLCBtb29uYmVhbSwgcG9sa2Fkb3QsIHJvY29jbywgd2VzdGVuZCB9IGZyb20gXCIuL2tub3duL21vZC5qc1wiOyAvLyBUT0RPOiBnZXQgcmlkIG9mIHRoaXMhXG5leHBvcnQgeyBoZXgsIG1hcENyZWF0ZVdhdGNoSGFuZGxlciwgd2F0Y2hJdGVyLCB9IGZyb20gXCIuL3V0aWwvbW9kLmpzXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2QuanMubWFwIiwidmFyIF9DbGllbnRfbmV4dElkLCBfQ2xpZW50X2xpc3RlbmVyQ2JzO1xuaW1wb3J0IHsgX19jbGFzc1ByaXZhdGVGaWVsZEdldCwgX19jbGFzc1ByaXZhdGVGaWVsZFNldCB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgZGVmZXJyZWQgfSBmcm9tIFwiLi4vZGVwcy9zdGQvYXN5bmMuanNcIjtcbmltcG9ydCB7IElzQ29ycmVzcG9uZGluZ1JlcyB9IGZyb20gXCIuL3V0aWwuanNcIjtcbmV4cG9ydCBjbGFzcyBDbGllbnQge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyBSUEMgY2xpZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0gaG9va3MgdGhlIGVycm9yIGhhbmRsaW5nIGFuZCBtZXNzYWdlIGhvb2tzIHdpdGggd2hpY2ggeW91J2QgbGlrZSB0aGUgaW5zdGFuY2UgdG8gb3BlcmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCBob29rcykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwcm92aWRlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogcHJvdmlkZXJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhvb2tzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBob29rc1xuICAgICAgICB9KTtcbiAgICAgICAgX0NsaWVudF9uZXh0SWQuc2V0KHRoaXMsIDApO1xuICAgICAgICBfQ2xpZW50X2xpc3RlbmVyQ2JzLnNldCh0aGlzLCBuZXcgTWFwKCkpO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2VuZCBhIG1lc3NhZ2UgdG8gdGhlIFJQQyBzZXJ2ZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGVncmVzc01lc3NhZ2UgdGhlIG1lc3NhZ2UgeW91IHdpc2ggdG8gc2VuZCB0byB0aGUgUlBDIHNlcnZlclxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2VuZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogKGVncmVzc01lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmhvb2tzPy5zZW5kPy4oZWdyZXNzTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5zZW5kKGVncmVzc01lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2xvc2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmhvb2tzPy5jbG9zZT8uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBAcmV0dXJucyBhIG5ldyBJRCwgdW5pcXVlIHRvIHRoZSBjbGllbnQgaW5zdGFuY2UgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidWlkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICByZXR1cm4gKF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NsaWVudF9uZXh0SWQsIChfYiA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NsaWVudF9uZXh0SWQsIFwiZlwiKSwgX2EgPSBfYisrLCBfYiksIFwiZlwiKSwgX2EpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQXR0YWNoIGEgbGlzdGVuZXIgdG8gaGFuZGxlIGluZ3Jlc3MgbWVzc2FnZXNcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNyZWF0ZUxpc3RlbmVyQ2IgdGhlIGZhY3RvcnkgZm9yIHRoZSBjYWxsYmFjayB0byBiZSB0cmlnZ2VyZWQgdXBvbiBhcnJpdmFsIG9mIGluZ3Jlc3MgbWVzc2FnZXNcbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxpc3RlblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogKGNyZWF0ZUxpc3RlbmVyQ2IpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdG9wTGlzdGVuaW5nID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DbGllbnRfbGlzdGVuZXJDYnMsIFwiZlwiKS5kZWxldGUobGlzdGVuZXJDYik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBsaXN0ZW5lckNiID0gY3JlYXRlTGlzdGVuZXJDYihzdG9wTGlzdGVuaW5nKTtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DbGllbnRfbGlzdGVuZXJDYnMsIFwiZlwiKS5zZXQobGlzdGVuZXJDYiwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUT0RPOiBkbyB3ZSB3YW50IHRvIHBhcmFtZXRlcml6ZSBgUnBjQ2xpZW50YCB3aXRoIGEgYFJhd01lc3NhZ2VgIHR5cGU/XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib25NZXNzYWdlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMucHJvdmlkZXIucGFyc2VJbmdyZXNzTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ob29rcz8uZXJyb3I/LihwYXJzZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ob29rcz8ucmVjZWl2ZT8uKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2xpZW50X2xpc3RlbmVyQ2JzLCBcImZcIikua2V5cygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcihwYXJzZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbkVycm9yXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmhvb2tzPy5lcnJvcj8uKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsIGFuIFJQQyBtZXRob2QgYW5kIHJldHVybiBhIHByb21pc2UgcmVzb2x2aW5nIHRvIGFuIGluZ3Jlc3MgbWVzc2FnZSB3aXRoIGFuIElEIHRoYXQgbWF0Y2hlcyB0aGUgZWdyZXNzIG1lc3NhZ2VcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG1ldGhvZE5hbWUgdGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB5b3Ugd2lzaCB0byBjYWxsXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgdGhlIHBhcmFtcyB3aXRoIHdoaWNoIHRvIGNhbGwgdGhlIG1ldGhvZFxuICAgICAgICAgKiBAcmV0dXJucyBhbiBpbmdyZXNzIG1lc3NhZ2UgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gbWV0aG9kIChvciBhIG1lc3NhZ2UtYWdub3N0aWMgZXJyb3IpXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYWxsXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAobWV0aG9kTmFtZSwgcGFyYW1zKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5pdCA9IHtcbiAgICAgICAgICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHRoaXMudWlkKCksXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgaXNDb3JyZXNwb25kaW5nUmVzID0gSXNDb3JyZXNwb25kaW5nUmVzKGluaXQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZ3Jlc3NNZXNzYWdlUGVuZGluZyA9IGRlZmVycmVkKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW4oKHN0b3BMaXN0ZW5pbmcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChyZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0NvcnJlc3BvbmRpbmdSZXMocmVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BMaXN0ZW5pbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmdyZXNzTWVzc2FnZVBlbmRpbmcucmVzb2x2ZShyZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZChpbml0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5ncmVzc01lc3NhZ2VQZW5kaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXRpYWxpemUgYW4gUlBDIHN1YnNjcmlwdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbWV0aG9kTmFtZSB0aGUgbWV0aG9kIG5hbWUgb2YgdGhlIHN1YnNjcmlwdGlvbiB5b3Ugd2lzaCB0byBpbml0XG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgdGhlIHBhcmFtcyB3aXRoIHdoaWNoIHRvIGluaXQgdGhlIHN1YnNjcmlwdGlvblxuICAgICAgICAgKiBAcGFyYW0gY3JlYXRlTGlzdGVuZXJDYiB0aGUgZmFjdG9yeSBvZiB0aGUgY2FsbGJhY2sgdG8gd2hpY2ggbm90aWZpY2F0aW9ucyBzaG91bGQgYmUgc3VwcGxpZWRcbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN1YnNjcmliZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogYXN5bmMgKG1ldGhvZE5hbWUsIHBhcmFtcywgY3JlYXRlTGlzdGVuZXJDYiwgY2xlYW51cCA9ICgpID0+IFByb21pc2UucmVzb2x2ZSgpKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5pdFJlcyA9IGF3YWl0IHRoaXMuY2FsbChtZXRob2ROYW1lLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGlmIChpbml0UmVzLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGZpeCB0eXBpbmdzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbml0UmVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjbGVhbnVwQXBwbGllZCA9ICgpID0+IGNsZWFudXAoaW5pdFJlcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVybWluYWxQZW5kaW5nID0gZGVmZXJyZWQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3Rlbigoc3RvcCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaXN0ZW5lckNiID0gY3JlYXRlTGlzdGVuZXJDYihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBjbGVhbnVwQXBwbGllZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVybWluYWxQZW5kaW5nLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAocmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzLnBhcmFtcz8uc3Vic2NyaXB0aW9uICYmIHJlcy5wYXJhbXMuc3Vic2NyaXB0aW9uID09PSBpbml0UmVzLnJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyQ2IocmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGFzc29jaWF0ZSBlcnJvcnMgd2l0aCBzdWJzY3JpcHRpb25zICYgZXhpdFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0ZXJtaW5hbFBlbmRpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbl9DbGllbnRfbmV4dElkID0gbmV3IFdlYWtNYXAoKSwgX0NsaWVudF9saXN0ZW5lckNicyA9IG5ldyBXZWFrTWFwKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXNlLmpzLm1hcCIsImltcG9ydCB7IEVycm9yQ3RvciB9IGZyb20gXCIuLi91dGlsL21vZC5qc1wiO1xuZXhwb3J0IGNsYXNzIFBhcnNlUmF3SW5ncmVzc01lc3NhZ2VFcnJvciBleHRlbmRzIEVycm9yQ3RvcihcIlBhcnNlUmF3SW5ncmVzc01lc3NhZ2VcIikge1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tbW9uLmpzLm1hcCIsImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lc3NhZ2VzLmpzLm1hcCIsImV4cG9ydCAqIGZyb20gXCIuL0Jhc2UuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vbWVzc2FnZXMuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3Byb3ZpZGVycy9wcm94eS5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vcHJvdmlkZXJzL3Ntb2xkb3QuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3Byb3ZpZGVycy9zdGQuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3V0aWwuanNcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZC5qcy5tYXAiLCJpbXBvcnQgeyBkZWFkbGluZSwgZGVmZXJyZWQgfSBmcm9tIFwiLi4vLi4vZGVwcy9zdGQvYXN5bmMuanNcIjtcbmltcG9ydCB7IEVycm9yQ3RvciB9IGZyb20gXCIuLi8uLi91dGlsL21vZC5qc1wiO1xuaW1wb3J0ICogYXMgQiBmcm9tIFwiLi4vQmFzZS5qc1wiO1xuaW1wb3J0IHsgUGFyc2VSYXdJbmdyZXNzTWVzc2FnZUVycm9yIH0gZnJvbSBcIi4uL2NvbW1vbi5qc1wiO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb3h5Q2xpZW50KGNvbmZpZywgaG9va3MpIHtcbiAgICBjb25zdCB3cyA9IG5ldyBXZWJTb2NrZXQoYXdhaXQgY29uZmlnLmRpc2NvdmVyeVZhbHVlKTtcbiAgICBjb25zdCBjbGllbnQgPSBuZXcgUHJveHlDbGllbnQod3MsIGhvb2tzKTtcbiAgICB3cy5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgY2xpZW50Lm9uRXJyb3IpO1xuICAgIHdzLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGNsaWVudC5vbk1lc3NhZ2UpO1xuICAgIGNvbnN0IHBlbmRpbmcgPSBkZWZlcnJlZCgpO1xuICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgICBjb25zdCBvbk9wZW5FcnJvciA9IChlKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh7IGxvZzogZSB9KTtcbiAgICAgICAgICAgIGNsZWFyTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICBwZW5kaW5nLnJlc29sdmUobmV3IEZhaWxlZFRvT3BlbkNvbm5lY3Rpb25FcnJvcigpKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb25PcGVuID0gKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHBlbmRpbmcucmVzb2x2ZShjbGllbnQpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjbGVhckxpc3RlbmVycyA9ICgpID0+IHtcbiAgICAgICAgICAgIHdzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvbk9wZW5FcnJvcik7XG4gICAgICAgICAgICB3cy5yZW1vdmVFdmVudExpc3RlbmVyKFwib3BlblwiLCBvbk9wZW4pO1xuICAgICAgICB9O1xuICAgICAgICB3cy5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25PcGVuRXJyb3IpO1xuICAgICAgICB3cy5hZGRFdmVudExpc3RlbmVyKFwib3BlblwiLCBvbk9wZW4pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcGVuZGluZy5yZXNvbHZlKGNsaWVudCk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBwZW5kaW5nO1xufVxuZXhwb3J0IGNsYXNzIFByb3h5Q2xpZW50IGV4dGVuZHMgQi5DbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKHdzLCBob29rcykge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBwYXJzZUluZ3Jlc3NNZXNzYWdlOiAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZSAhPT0gXCJvYmplY3RcIlxuICAgICAgICAgICAgICAgICAgICB8fCBlID09PSBudWxsXG4gICAgICAgICAgICAgICAgICAgIHx8ICEoXCJkYXRhXCIgaW4gZSlcbiAgICAgICAgICAgICAgICAgICAgfHwgdHlwZW9mIGUuZGF0YSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBhcnNlUmF3SW5ncmVzc01lc3NhZ2VFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShlLmRhdGEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlbmQ6IChlZ3Jlc3NNZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICAgICAgd3Muc2VuZChKU09OLnN0cmluZ2lmeShlZ3Jlc3NNZXNzYWdlKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2U6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwZW5kaW5nID0gZGVmZXJyZWQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvbkNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB3cy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgdGhpcy5vbkVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgd3MucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy5vbk1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB3cy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwgb25DbG9zZSk7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmcucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgd3MuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsIG9uQ2xvc2UpO1xuICAgICAgICAgICAgICAgIHdzLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgZGVhZGxpbmUocGVuZGluZywgMjUwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9lKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmcucmVzb2x2ZShuZXcgRmFpbGVkVG9EaXNjb25uZWN0RXJyb3IoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwZW5kaW5nO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSwgaG9va3MpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBGYWlsZWRUb09wZW5Db25uZWN0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvckN0b3IoXCJGYWlsZWRUb09wZW5Db25uZWN0aW9uXCIpIHtcbn1cbmV4cG9ydCBjbGFzcyBGYWlsZWRUb0Rpc2Nvbm5lY3RFcnJvciBleHRlbmRzIEVycm9yQ3RvcihcIkZhaWxlZFRvRGlzY29ubmVjdFwiKSB7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm94eS5qcy5tYXAiLCJ2YXIgX1Ntb2xkb3RDbGllbnRfY2hhaW47XG5pbXBvcnQgeyBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0IH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBFcnJvckN0b3IgfSBmcm9tIFwiLi4vLi4vdXRpbC9tb2QuanNcIjtcbmltcG9ydCB7IENsaWVudCB9IGZyb20gXCIuLi9CYXNlLmpzXCI7XG5pbXBvcnQgeyBQYXJzZVJhd0luZ3Jlc3NNZXNzYWdlRXJyb3IgfSBmcm9tIFwiLi4vY29tbW9uLmpzXCI7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc21vbGRvdENsaWVudChjb25maWcsIGhvb2tzKSB7XG4gICAgY29uc3Qgc21vbGRvdEluc3RhbmNlID0gYXdhaXQgZW5zdXJlSW5zdGFuY2UoKTtcbiAgICBpZiAoc21vbGRvdEluc3RhbmNlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHNtb2xkb3RJbnN0YW5jZTtcbiAgICB9XG4gICAgY29uc3Qgb25NZXNzYWdlQ29udGFpbmVyID0ge307XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gVE9ETzogd2lyZSB1cCBgb25FcnJvcmBcbiAgICAgICAgY29uc3QgY2hhaW4gPSBhd2FpdCBzbW9sZG90SW5zdGFuY2UuYWRkQ2hhaW4oe1xuICAgICAgICAgICAgY2hhaW5TcGVjOiBhd2FpdCBjb25maWcuZGlzY292ZXJ5VmFsdWUsXG4gICAgICAgICAgICBqc29uUnBjQ2FsbGJhY2s6IChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIG9uTWVzc2FnZUNvbnRhaW5lci5vbk1lc3NhZ2U/LihyZXNwb25zZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBTbW9sZG90Q2xpZW50KG9uTWVzc2FnZUNvbnRhaW5lciwgY2hhaW4ucmVtb3ZlLCBob29rcyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmFpbGVkVG9BZGRDaGFpbkVycm9yKGUpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBTbW9sZG90Q2xpZW50IGV4dGVuZHMgQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihvbk1lc3NhZ2VDb250YWluZXIsIHJlbW92ZSwgaG9va3MpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgcGFyc2VJbmdyZXNzTWVzc2FnZTogKHJhd0luZ3Jlc3NNZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmF3SW5ncmVzc01lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoX2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXJzZVJhd0luZ3Jlc3NNZXNzYWdlRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VuZDogKGVncmVzc01lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TbW9sZG90Q2xpZW50X2NoYWluLCBcImZcIik/LnNlbmRKc29uUnBjKEpTT04uc3RyaW5naWZ5KGVncmVzc01lc3NhZ2UpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRmFpbGVkVG9SZW1vdmVDaGFpbkVycm9yKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkoKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LCBob29rcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlbW92ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogcmVtb3ZlXG4gICAgICAgIH0pO1xuICAgICAgICBfU21vbGRvdENsaWVudF9jaGFpbi5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgb25NZXNzYWdlQ29udGFpbmVyLm9uTWVzc2FnZSA9IHRoaXMub25NZXNzYWdlO1xuICAgIH1cbn1cbl9TbW9sZG90Q2xpZW50X2NoYWluID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IF9zdGF0ZSA9IHt9O1xuYXN5bmMgZnVuY3Rpb24gZW5zdXJlSW5zdGFuY2UoKSB7XG4gICAgaWYgKCFfc3RhdGUuc21vbGRvdEluc3RhbmNlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzbW9sZG90ID0gYXdhaXQgaW1wb3J0KFwiLi4vLi4vZGVwcy9zbW9sZG90LmpzXCIpO1xuICAgICAgICAgICAgX3N0YXRlLnNtb2xkb3RJbnN0YW5jZSA9IHNtb2xkb3Quc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2UpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmFpbGVkVG9TdGFydFNtb2xkb3RFcnJvcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfc3RhdGUuc21vbGRvdEluc3RhbmNlO1xufVxuZXhwb3J0IGNsYXNzIEZhaWxlZFRvU3RhcnRTbW9sZG90RXJyb3IgZXh0ZW5kcyBFcnJvckN0b3IoXCJGYWlsZWRUb1N0YXJ0U21vbGRvdFwiKSB7XG59XG5leHBvcnQgY2xhc3MgRmFpbGVkVG9BZGRDaGFpbkVycm9yIGV4dGVuZHMgRXJyb3JDdG9yKFwiRmFpbGVkVG9BZGRDaGFpblwiKSB7XG4gICAgY29uc3RydWN0b3IoaW5uZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5uZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGlubmVyXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBTbW9sZG90SW50ZXJuYWxFcnJvciBleHRlbmRzIEVycm9yQ3RvcihcIlNtb2xkb3RJbnRlcm5hbFwiKSB7XG59XG4vLyBUT0RPOiBzcGVjaWZ5IG5hcnJvdyBgQWxyZWFkeURlc3Ryb3llZEVycm9yYCAmIGBDcmFzaEVycm9yYCBmcm9tIFNtb2xkb3RcbmV4cG9ydCBjbGFzcyBGYWlsZWRUb1JlbW92ZUNoYWluRXJyb3IgZXh0ZW5kcyBFcnJvckN0b3IoXCJGYWlsZWRUb1JlbW92ZUNoYWluXCIpIHtcbiAgICBjb25zdHJ1Y3Rvcihpbm5lcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbm5lclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogaW5uZXJcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c21vbGRvdC5qcy5tYXAiLCJpbXBvcnQgeyB1bmltcGxlbWVudGVkIH0gZnJvbSBcIi4uLy4uL2RlcHMvc3RkL3Rlc3RpbmcvYXNzZXJ0cy5qc1wiO1xuaW1wb3J0IHsgcHJveHlDbGllbnQgfSBmcm9tIFwiLi9wcm94eS5qc1wiO1xuaW1wb3J0IHsgc21vbGRvdENsaWVudCwgfSBmcm9tIFwiLi9zbW9sZG90LmpzXCI7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3RkQ2xpZW50KGNvbmZpZykge1xuICAgIGNvbnN0IGRpc2NvdmVyeVZhbHVlID0gYXdhaXQgY29uZmlnLmRpc2NvdmVyeVZhbHVlO1xuICAgIGlmICh0eXBlb2YgZGlzY292ZXJ5VmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgLy8gVE9ETzogaW1wcm92ZSBjaGVjayAvIG1vdmUgc2VsZWN0aW9uIGVsc2V3aGVyZVxuICAgICAgICBpZiAoZGlzY292ZXJ5VmFsdWUuc3RhcnRzV2l0aChcIndzXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJveHlDbGllbnQoY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzbW9sZG90Q2xpZW50KGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0ZC5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gSXNDb3JyZXNwb25kaW5nUmVzKGluaXQpIHtcbiAgICByZXR1cm4gKGluUXVlc3Rpb24pID0+IHtcbiAgICAgICAgcmV0dXJuIGluUXVlc3Rpb24/LmlkID09PSBpbml0LmlkO1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcCIsImltcG9ydCB7IGJsYWtlMmIgfSBmcm9tIFwiLi4vZGVwcy9ibGFrZTJiLmpzXCI7XG5pbXBvcnQgKiBhcyBiYXNlNTggZnJvbSBcIi4uL2RlcHMvc3RkL2VuY29kaW5nL2Jhc2U1OC5qc1wiO1xuaW1wb3J0ICogYXMgVSBmcm9tIFwiLi4vdXRpbC9tb2QuanNcIjtcbi8vIFNTNThQUkUgc3RyaW5nICgweDUzNTMzNTM4NTA1MjQ1IGhleCkgZW5jb2RlZCBhcyBVaW50OEFycmF5XG5jb25zdCBTUzU4UFJFID0gVWludDhBcnJheS5vZig4MywgODMsIDUzLCA1NiwgODAsIDgyLCA2OSk7XG5jb25zdCBDSEVDS1NVTV9MRU5HVEggPSAyO1xuY29uc3QgVkFMSURfQUREUkVTU19MRU5HVEhTID0ge1xuICAgIDM1OiB0cnVlLFxuICAgIDM2OiB0cnVlLFxuICAgIDM3OiB0cnVlLFxuICAgIDM4OiB0cnVlLFxufTtcbmNvbnN0IFZBTElEX1BVQkxJQ19LRVlfTEVOR1RIUyA9IHtcbiAgICAzMjogdHJ1ZSxcbiAgICAzMzogdHJ1ZSxcbn07XG5leHBvcnQgY2xhc3MgSW52YWxpZFB1YmxpY0tleUxlbmd0aEVycm9yIGV4dGVuZHMgVS5FcnJvckN0b3IoXCJJbnZhbGlkUHVibGljS2V5TGVuZ3RoRXJyb3JcIikge1xufVxuZXhwb3J0IGNsYXNzIEludmFsaWROZXR3b3JrUHJlZml4RXJyb3IgZXh0ZW5kcyBVLkVycm9yQ3RvcihcIkludmFsaWROZXR3b3JrUHJlZml4RXJyb3JcIikge1xufVxuZXhwb3J0IGNsYXNzIEludmFsaWRBZGRyZXNzTGVuZ3RoRXJyb3IgZXh0ZW5kcyBVLkVycm9yQ3RvcihcIkludmFsaWRBZGRyZXNzRXJyb3JcIikge1xufVxuZXhwb3J0IGNsYXNzIEludmFsaWRBZGRyZXNzQ2hlY2tzdW1FcnJvciBleHRlbmRzIFUuRXJyb3JDdG9yKFwiSW52YWxpZEFkZHJlc3NDaGVja3N1bUVycm9yXCIpIHtcbn1cbmV4cG9ydCBjb25zdCBlbmNvZGUgPSAocHJlZml4LCBwdWJLZXksIHZhbGlkTmV0d29ya1ByZWZpeGVzKSA9PiBiYXNlNTguZW5jb2RlKGVuY29kZVJhdyhwcmVmaXgsIHB1YktleSwgdmFsaWROZXR3b3JrUHJlZml4ZXMpKTtcbmV4cG9ydCBjb25zdCBlbmNvZGVSYXcgPSAocHJlZml4LCBwdWJLZXksIHZhbGlkTmV0d29ya1ByZWZpeGVzKSA9PiB7XG4gICAgY29uc3QgaXNWYWxpZFB1YmxpY0tleUxlbmd0aCA9ICEhVkFMSURfUFVCTElDX0tFWV9MRU5HVEhTW3B1YktleS5sZW5ndGhdO1xuICAgIGlmICghaXNWYWxpZFB1YmxpY0tleUxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFB1YmxpY0tleUxlbmd0aEVycm9yKCk7XG4gICAgfVxuICAgIGNvbnN0IGlzVmFsaWROZXR3b3JrUHJlZml4ID0gIXZhbGlkTmV0d29ya1ByZWZpeGVzIHx8IHZhbGlkTmV0d29ya1ByZWZpeGVzLmluY2x1ZGVzKHByZWZpeCk7XG4gICAgaWYgKCFpc1ZhbGlkTmV0d29ya1ByZWZpeCkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZE5ldHdvcmtQcmVmaXhFcnJvcigpO1xuICAgIH1cbiAgICBjb25zdCBwcmVmaXhCeXRlcyA9IHByZWZpeCA8IDY0XG4gICAgICAgID8gVWludDhBcnJheS5vZihwcmVmaXgpXG4gICAgICAgIDogVWludDhBcnJheS5vZigoKHByZWZpeCAmIDI1MikgPj4gMikgfCA2NCwgKHByZWZpeCA+PiA4KSB8ICgocHJlZml4ICYgMykgPDwgNikpO1xuICAgIGNvbnN0IGhhc2hlciA9IGJsYWtlMmIuY3JlYXRlKHtcbiAgICAgICAgZGtMZW46IDUxMiAvIDgsXG4gICAgfSk7XG4gICAgaGFzaGVyLnVwZGF0ZShTUzU4UFJFKTtcbiAgICBoYXNoZXIudXBkYXRlKHByZWZpeEJ5dGVzKTtcbiAgICBoYXNoZXIudXBkYXRlKHB1YktleSk7XG4gICAgY29uc3QgZGlnZXN0ID0gaGFzaGVyLmRpZ2VzdCgpO1xuICAgIGNvbnN0IGNoZWNrc3VtID0gZGlnZXN0LnN1YmFycmF5KDAsIENIRUNLU1VNX0xFTkdUSCk7XG4gICAgY29uc3QgYWRkcmVzcyA9IG5ldyBVaW50OEFycmF5KHByZWZpeEJ5dGVzLmxlbmd0aCArIHB1YktleS5sZW5ndGggKyBDSEVDS1NVTV9MRU5HVEgpO1xuICAgIGFkZHJlc3Muc2V0KHByZWZpeEJ5dGVzLCAwKTtcbiAgICBhZGRyZXNzLnNldChwdWJLZXksIHByZWZpeEJ5dGVzLmxlbmd0aCk7XG4gICAgYWRkcmVzcy5zZXQoY2hlY2tzdW0sIHByZWZpeEJ5dGVzLmxlbmd0aCArIHB1YktleS5sZW5ndGgpO1xuICAgIHJldHVybiBhZGRyZXNzO1xufTtcbmV4cG9ydCBjb25zdCBkZWNvZGUgPSAoYWRkcmVzcykgPT4gZGVjb2RlUmF3KGJhc2U1OC5kZWNvZGUoYWRkcmVzcykpO1xuZXhwb3J0IGNvbnN0IGRlY29kZVJhdyA9IChhZGRyZXNzKSA9PiB7XG4gICAgY29uc3QgaXNWYWxpZEFkZHJlc3NMZW5ndGggPSAhIVZBTElEX0FERFJFU1NfTEVOR1RIU1thZGRyZXNzLmxlbmd0aF07XG4gICAgaWYgKCFpc1ZhbGlkQWRkcmVzc0xlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NMZW5ndGhFcnJvcigpO1xuICAgIH1cbiAgICBjb25zdCBwcmVmaXhMZW5ndGggPSBhZGRyZXNzWzBdICYgNjQgPyAyIDogMTtcbiAgICBjb25zdCBwcmVmaXggPSBwcmVmaXhMZW5ndGggPT09IDFcbiAgICAgICAgPyBhZGRyZXNzWzBdXG4gICAgICAgIDogKChhZGRyZXNzWzBdICYgNjMpIDw8IDIpIHwgKGFkZHJlc3NbMV0gPj4gNilcbiAgICAgICAgICAgIHwgKChhZGRyZXNzWzFdICYgNjMpIDw8IDgpO1xuICAgIGNvbnN0IGhhc2hlciA9IGJsYWtlMmIuY3JlYXRlKHtcbiAgICAgICAgZGtMZW46IDUxMiAvIDgsXG4gICAgfSk7XG4gICAgaGFzaGVyLnVwZGF0ZShTUzU4UFJFKTtcbiAgICBoYXNoZXIudXBkYXRlKGFkZHJlc3Muc3ViYXJyYXkoMCwgYWRkcmVzcy5sZW5ndGggLSBDSEVDS1NVTV9MRU5HVEgpKTtcbiAgICBjb25zdCBkaWdlc3QgPSBoYXNoZXIuZGlnZXN0KCk7XG4gICAgY29uc3QgY2hlY2tzdW0gPSBhZGRyZXNzLnN1YmFycmF5KGFkZHJlc3MubGVuZ3RoIC0gQ0hFQ0tTVU1fTEVOR1RIKTtcbiAgICBpZiAoZGlnZXN0WzBdICE9PSBjaGVja3N1bVswXSB8fCBkaWdlc3RbMV0gIT09IGNoZWNrc3VtWzFdKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0NoZWNrc3VtRXJyb3IoKTtcbiAgICB9XG4gICAgY29uc3QgcHViS2V5ID0gYWRkcmVzcy5zdWJhcnJheShwcmVmaXhMZW5ndGgsIGFkZHJlc3MubGVuZ3RoIC0gQ0hFQ0tTVU1fTEVOR1RIKTtcbiAgICByZXR1cm4gW3ByZWZpeCwgcHViS2V5XTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2QuanMubWFwIiwiZXhwb3J0IGNvbnN0IEhleFN0cmluZ0JyYW5kID0gU3ltYm9sKCk7XG5leHBvcnQgY29uc3QgSGFzaEhleFN0cmluZ0JyYW5kID0gU3ltYm9sKCk7XG5leHBvcnQgY29uc3QgQWNjb3VudElkU3RyaW5nQnJhbmQgPSBTeW1ib2woKTtcbmV4cG9ydCBjb25zdCBTdWJzY3JpcHRpb25JZFN0cmluZ0JyYW5kID0gU3ltYm9sKCk7XG5leHBvcnQgY29uc3QgTXVsdGlBZGRyZXNzU3RyaW5nQnJhbmQgPSBTeW1ib2woKTtcbmV4cG9ydCBjb25zdCBIZXhVNjRTdHJpbmdCcmFuZCA9IFN5bWJvbCgpO1xuZXhwb3J0IGNvbnN0IEgyNTZTdHJpbmdCcmFuZCA9IFN5bWJvbCgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJhbmRlZC5qcy5tYXAiLCIvKiogUHJvZHVjZXMgYW4gZXJyb3Igd2hvc2UgbmFtZSBpcyByZXByZXNlbnRlZCB3aXRoaW4gdGhlIHR5cGUgc3lzdGVtICovXG5leHBvcnQgZnVuY3Rpb24gRXJyb3JDdG9yKG5hbWUpIHtcbiAgICByZXR1cm4gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBuYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gdGhyb3dJZkVycm9yKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9yLmpzLm1hcCIsImV4cG9ydCB7IGRlY29kZSBhcyBkZWNvZGVCdWYsIGVuY29kZSBhcyBlbmNvZGVCdWYgfSBmcm9tIFwiLi4vZGVwcy9zdGQvZW5jb2RpbmcvaGV4LmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlKGhleCkge1xuICAgIGlmIChoZXguc3RhcnRzV2l0aChcIjB4XCIpKVxuICAgICAgICBoZXggPSBoZXguc2xpY2UoMik7XG4gICAgaWYgKGhleC5sZW5ndGggJSAyID09PSAxKVxuICAgICAgICBoZXggPSBcIjBcIiArIGhleDtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGhleC5sZW5ndGggLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhleC5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheVtpXSA9IHBhcnNlSW50KGhleC5zbGljZShpICogMiwgaSAqIDIgKyAyKSwgMTYpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlKGJ5dGVzKSB7XG4gICAgbGV0IHN0ciA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdHIgKz0gYnl0ZXNbaV0udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVQcmVmaXhlZChieXRlcykge1xuICAgIHJldHVybiBcIjB4XCIgKyBlbmNvZGUoYnl0ZXMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGV4LmpzLm1hcCIsImV4cG9ydCAqIGZyb20gXCIuL2JyYW5kZWQuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2Vycm9yLmpzXCI7XG5leHBvcnQgKiBhcyBoZXggZnJvbSBcIi4vaGV4LmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi90eXBlcy5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vd2F0Y2guanNcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZC5qcy5tYXAiLCJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiLCJpbXBvcnQgeyBkZWZlcnJlZCB9IGZyb20gXCIuLi9kZXBzL3N0ZC9hc3luYy5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIG1hcENyZWF0ZVdhdGNoSGFuZGxlcihjcmVhdGVXYXRjaEhhbmRsZXIsIG1hcCkge1xuICAgIHJldHVybiAoY2xvc2UpID0+IHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJDYiA9IGNyZWF0ZVdhdGNoSGFuZGxlcihjbG9zZSk7XG4gICAgICAgIHJldHVybiAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgbGlzdGVuZXJDYihtYXAobWVzc2FnZSkpO1xuICAgICAgICB9O1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gd2F0Y2hJdGVyKCkge1xuICAgIGNvbnN0IHF1ZXVlID0gW107XG4gICAgY29uc3QgY2JzID0gW107XG4gICAgY29uc3Qgb25Eb25lQ29udGFpbmVyID0ge307XG4gICAgY29uc3QgY3JlYXRlV2F0Y2hIYW5kbGVyID0gKHN0b3ApID0+IHtcbiAgICAgICAgb25Eb25lQ29udGFpbmVyLm9uRG9uZSA9IHN0b3A7XG4gICAgICAgIHJldHVybiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNiID0gY2JzLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgICAgICBjYih7XG4gICAgICAgICAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgaXRlciA9IHtcbiAgICAgICAgYXN5bmMgbmV4dCgpIHtcbiAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHF1ZXVlLnNoaWZ0KCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBlbmRpbmcgPSBkZWZlcnJlZCgpO1xuICAgICAgICAgICAgY2JzLnB1c2gocGVuZGluZy5yZXNvbHZlKTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBwZW5kaW5nO1xuICAgICAgICB9LFxuICAgICAgICByZXR1cm4oKSB7XG4gICAgICAgICAgICBvbkRvbmVDb250YWluZXI/Lm9uRG9uZT8uKCk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oY3JlYXRlV2F0Y2hIYW5kbGVyLCBpdGVyKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdhdGNoLmpzLm1hcCIsImltcG9ydCB7IGNyZWF0ZUNvZGVjLCBFbmNvZGVFcnJvciB9IGZyb20gXCIuLi9jb21tb24uanNcIjtcbmltcG9ydCB7IGNvbXBhY3RVMzIgfSBmcm9tIFwiLi4vY29tcGFjdC9jb2RlYy5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHNpemVkQXJyYXkoJGVsLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gY3JlYXRlQ29kZWMoe1xuICAgICAgICBuYW1lOiBcInNpemVkQXJyYXlcIixcbiAgICAgICAgX21ldGFkYXRhOiBbc2l6ZWRBcnJheSwgJGVsLCBsZW5ndGhdLFxuICAgICAgICBfc3RhdGljU2l6ZTogJGVsLl9zdGF0aWNTaXplICogbGVuZ3RoLFxuICAgICAgICBfZW5jb2RlKGJ1ZmZlciwgdmFsdWUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAkZWwuX2VuY29kZShidWZmZXIsIHZhbHVlW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2RlY29kZShidWZmZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVtpXSA9ICRlbC5fZGVjb2RlKGJ1ZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYXJyYXkoJGVsKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNvZGVjKHtcbiAgICAgICAgbmFtZTogXCJhcnJheVwiLFxuICAgICAgICBfbWV0YWRhdGE6IFthcnJheSwgJGVsXSxcbiAgICAgICAgX3N0YXRpY1NpemU6IGNvbXBhY3RVMzIuX3N0YXRpY1NpemUsXG4gICAgICAgIF9lbmNvZGUoYnVmZmVyLCB2YWx1ZSkge1xuICAgICAgICAgICAgY29tcGFjdFUzMi5fZW5jb2RlKGJ1ZmZlciwgdmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBidWZmZXIucHVzaEFsbG9jKHZhbHVlLmxlbmd0aCAqICRlbC5fc3RhdGljU2l6ZSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAkZWwuX2VuY29kZShidWZmZXIsIHZhbHVlW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnVmZmVyLnBvcEFsbG9jKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9kZWNvZGUoYnVmZmVyKSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBjb21wYWN0VTMyLl9kZWNvZGUoYnVmZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVtpXSA9ICRlbC5fZGVjb2RlKGJ1ZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgdWludDhBcnJheSA9IGNyZWF0ZUNvZGVjKHtcbiAgICBuYW1lOiBcInVpbnQ4QXJyYXlcIixcbiAgICBfbWV0YWRhdGE6IG51bGwsXG4gICAgX3N0YXRpY1NpemU6IGNvbXBhY3RVMzIuX3N0YXRpY1NpemUsXG4gICAgX2VuY29kZShidWZmZXIsIHZhbHVlKSB7XG4gICAgICAgIGNvbXBhY3RVMzIuX2VuY29kZShidWZmZXIsIHZhbHVlLmxlbmd0aCk7XG4gICAgICAgIGJ1ZmZlci5pbnNlcnRBcnJheSh2YWx1ZSk7IC8vIHRoZSBjb250ZW50cyBvZiB0aGlzIHdpbGwgZXZlbnR1YWxseSBiZSBjbG9uZWQgYnkgYnVmZmVyXG4gICAgfSxcbiAgICBfZGVjb2RlKGJ1ZmZlcikge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBjb21wYWN0VTMyLl9kZWNvZGUoYnVmZmVyKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBidWZmZXIuYXJyYXkuc3ViYXJyYXkoYnVmZmVyLmluZGV4LCBidWZmZXIuaW5kZXggKyBsZW5ndGgpO1xuICAgICAgICBidWZmZXIuaW5kZXggKz0gbGVuZ3RoO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIHNpemVkVWludDhBcnJheShsZW5ndGgpIHtcbiAgICByZXR1cm4gY3JlYXRlQ29kZWMoe1xuICAgICAgICBuYW1lOiBcInNpemVkVWludDhBcnJheVwiLFxuICAgICAgICBfbWV0YWRhdGE6IFtzaXplZFVpbnQ4QXJyYXksIGxlbmd0aF0sXG4gICAgICAgIC8vIFdlIGNvdWxkIHNldCBgX3N0YXRpY1NpemVgIHRvIGBsZW5ndGhgLCBidXQgaW4gdGhpcyBjYXNlIGl0IHdpbGwgdXN1YWxseVxuICAgICAgICAvLyBtb3JlIGVmZmljaWVudCB0byBpbnNlcnQgdGhlIGFycmF5IGR5bmFtaWNhbGx5LCByYXRoZXIgdGhhbiBtYW51YWxseSBjb3B5XG4gICAgICAgIC8vIHRoZSBieXRlcy5cbiAgICAgICAgX3N0YXRpY1NpemU6IDAsXG4gICAgICAgIF9lbmNvZGUoYnVmZmVyLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAhPT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVuY29kZUVycm9yKHRoaXMsIHZhbHVlLCBgRXhwZWN0ZWQgYW4gYXJyYXkgb2Ygc2l6ZSAke2xlbmd0aH0sIGdvdCAke3ZhbHVlLmxlbmd0aH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5pbnNlcnRBcnJheSh2YWx1ZSk7IC8vIHRoZSBjb250ZW50cyBvZiB0aGlzIHdpbGwgZXZlbnR1YWxseSBiZSBjbG9uZWQgYnkgYnVmZmVyXG4gICAgICAgIH0sXG4gICAgICAgIF9kZWNvZGUoYnVmZmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyLmFycmF5LnN1YmFycmF5KGJ1ZmZlci5pbmRleCwgYnVmZmVyLmluZGV4ICs9IGxlbmd0aCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKiogQGRlcHJlY2F0ZWQgVXNlIGAkLnVpbnQ4QXJyYXlgIGluc3RlYWQgKi9cbmV4cG9ydCBjb25zdCB1aW50OGFycmF5ID0gdWludDhBcnJheTtcbi8qKiBAZGVwcmVjYXRlZCBVc2UgYCQuc2l6ZWRVaW50OEFycmF5YCBpbnN0ZWFkICovXG5leHBvcnQgY29uc3Qgc2l6ZWRVaW50OGFycmF5ID0gc2l6ZWRVaW50OEFycmF5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29kZWMuanMubWFwIiwiaW1wb3J0IHsgY3JlYXRlQ29kZWMgfSBmcm9tIFwiLi4vY29tbW9uLmpzXCI7XG5pbXBvcnQgeyBjb21wYWN0VTMyIH0gZnJvbSBcIi4uL2NvbXBhY3QvY29kZWMuanNcIjtcbmV4cG9ydCBjbGFzcyBCaXRTZXF1ZW5jZSB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoID0gMCwgZGF0YSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsZW5ndGhcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGxlbmd0aFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGF0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBieXRlTGVuZ3RoID0gTWF0aC5jZWlsKGxlbmd0aCAvIDgpO1xuICAgICAgICBkYXRhID8/PSBuZXcgVWludDhBcnJheShieXRlTGVuZ3RoKTtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoICE9PSBieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbmNvcnJlY3RseSBzaXplZCBVaW50OEFycmF5IHBhc3NlZCB0byBCaXRTZXF1ZW5jZSBjb25zdHJ1Y3RvclwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShhcnJheSkge1xuICAgICAgICBjb25zdCBzZXF1ZW5jZSA9IG5ldyBCaXRTZXF1ZW5jZShhcnJheS5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzZXF1ZW5jZS5fc2V0Qml0KGksIGFycmF5W2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VxdWVuY2U7XG4gICAgfVxuICAgIGdldCBieXRlTGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmxlbmd0aDtcbiAgICB9XG4gICAgX2hhc0JpdChpbmRleCkge1xuICAgICAgICByZXR1cm4gMCA8PSBpbmRleCAmJiBpbmRleCA8IHRoaXMubGVuZ3RoICYmIGluZGV4ID09PSBNYXRoLmZsb29yKGluZGV4KTtcbiAgICB9XG4gICAgX2dldEJpdChpbmRleCkge1xuICAgICAgICBpZiAoIXRoaXMuX2hhc0JpdChpbmRleCkpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBpID0gTWF0aC5mbG9vcihpbmRleCAvIDgpO1xuICAgICAgICBjb25zdCBqID0gNyAtIGluZGV4ICUgODtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMuZGF0YVtpXSAmICgxIDw8IGopKTtcbiAgICB9XG4gICAgX3NldEJpdChpbmRleCwgYml0KSB7XG4gICAgICAgIGlmICghdGhpcy5faGFzQml0KGluZGV4KSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgaSA9IE1hdGguZmxvb3IoaW5kZXggLyA4KTtcbiAgICAgICAgY29uc3QgaiA9IDcgLSBpbmRleCAlIDg7XG4gICAgICAgIHRoaXMuZGF0YVtpXSA9IHRoaXMuZGF0YVtpXSAmIH4oMSA8PCBqKSB8ICgrISFiaXQgPDwgaik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbk9iamVjdC5zZXRQcm90b3R5cGVPZihCaXRTZXF1ZW5jZS5wcm90b3R5cGUsIG5ldyBQcm94eShPYmplY3QucHJvdG90eXBlLCB7XG4gICAgZ2V0OiAodGFyZ2V0LCBrLCByZWNlaXZlcikgPT4ge1xuICAgICAgICBjb25zdCBpID0gdHlwZW9mIGsgPT09IFwic3RyaW5nXCIgPyArayA6IE5hTjtcbiAgICAgICAgaWYgKGlzTmFOKGkpKVxuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgaywgcmVjZWl2ZXIpO1xuICAgICAgICByZXR1cm4gcmVjZWl2ZXIuX2dldEJpdChpKTtcbiAgICB9LFxuICAgIHNldDogKHRhcmdldCwgaywgdiwgcmVjZWl2ZXIpID0+IHtcbiAgICAgICAgY29uc3QgaSA9IHR5cGVvZiBrID09PSBcInN0cmluZ1wiID8gK2sgOiBOYU47XG4gICAgICAgIGlmIChpc05hTihpKSlcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LnNldCh0YXJnZXQsIGssIHYsIHJlY2VpdmVyKTtcbiAgICAgICAgcmV0dXJuIHJlY2VpdmVyLl9zZXRCaXQoaSwgdik7XG4gICAgfSxcbn0pKTtcbmV4cG9ydCBjb25zdCBiaXRTZXF1ZW5jZSA9IGNyZWF0ZUNvZGVjKHtcbiAgICBuYW1lOiBcImJpdFNlcXVlbmNlXCIsXG4gICAgX21ldGFkYXRhOiBudWxsLFxuICAgIF9zdGF0aWNTaXplOiBjb21wYWN0VTMyLl9zdGF0aWNTaXplLFxuICAgIF9lbmNvZGUoYnVmZmVyLCB2YWx1ZSkge1xuICAgICAgICBjb21wYWN0VTMyLl9lbmNvZGUoYnVmZmVyLCB2YWx1ZS5sZW5ndGgpO1xuICAgICAgICBidWZmZXIuaW5zZXJ0QXJyYXkodmFsdWUuZGF0YSk7XG4gICAgfSxcbiAgICBfZGVjb2RlKGJ1ZmZlcikge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBjb21wYWN0VTMyLl9kZWNvZGUoYnVmZmVyKTtcbiAgICAgICAgY29uc3QgYnl0ZUxlbmd0aCA9IE1hdGguY2VpbChsZW5ndGggLyA4KTtcbiAgICAgICAgcmV0dXJuIG5ldyBCaXRTZXF1ZW5jZShsZW5ndGgsIGJ1ZmZlci5hcnJheS5zdWJhcnJheShidWZmZXIuaW5kZXgsIGJ1ZmZlci5pbmRleCArPSBieXRlTGVuZ3RoKSk7XG4gICAgfSxcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29kZWMuanMubWFwIiwiaW1wb3J0IHsgY3JlYXRlQ29kZWMgfSBmcm9tIFwiLi4vY29tbW9uLmpzXCI7XG5leHBvcnQgY29uc3QgYm9vbCA9IGNyZWF0ZUNvZGVjKHtcbiAgICBuYW1lOiBcImJvb2xlYW5cIixcbiAgICBfbWV0YWRhdGE6IG51bGwsXG4gICAgX3N0YXRpY1NpemU6IDEsXG4gICAgX2VuY29kZShidWZmZXIsIHZhbHVlKSB7XG4gICAgICAgIGJ1ZmZlci5hcnJheVtidWZmZXIuaW5kZXgrK10gPSArdmFsdWU7XG4gICAgfSxcbiAgICBfZGVjb2RlKGJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gISFidWZmZXIuYXJyYXlbYnVmZmVyLmluZGV4KytdO1xuICAgIH0sXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvZGVjLmpzLm1hcCIsInZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xufTtcbnZhciBfQ29kZWNWaXNpdG9yX2ZhbGxiYWNrLCBfQ29kZWNWaXNpdG9yX3Zpc2l0b3JzO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvZGVjKF9jb2RlYykge1xuICAgIGNvbnN0IHsgX3N0YXRpY1NpemUsIF9lbmNvZGUsIF9kZWNvZGUsIF9tZXRhZGF0YSwgbmFtZSB9ID0gX2NvZGVjO1xuICAgIGNvbnN0IGNvZGVjID0ge1xuICAgICAgICBuYW1lLFxuICAgICAgICBfc3RhdGljU2l6ZSxcbiAgICAgICAgX2VuY29kZSxcbiAgICAgICAgX2RlY29kZSxcbiAgICAgICAgLi4uX21ldGFkYXRhICYmIHsgX21ldGFkYXRhIH0sXG4gICAgICAgIGVuY29kZSh2YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgYnVmID0gbmV3IEVuY29kZUJ1ZmZlcihfc3RhdGljU2l6ZSk7XG4gICAgICAgICAgICBfZW5jb2RlLmNhbGwoY29kZWMsIGJ1ZiwgdmFsdWUpO1xuICAgICAgICAgICAgaWYgKGJ1Zi5hc3luY0NvdW50KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFbmNvZGVFcnJvcihjb2RlYywgdmFsdWUsIFwiQXR0ZW1wdGVkIHRvIHN5bmNocm9ub3VzbHkgZW5jb2RlIGFuIGFzeW5jIGNvZGVjXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1Zi5maW5pc2goKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgZW5jb2RlQXN5bmModmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZiA9IG5ldyBFbmNvZGVCdWZmZXIoX3N0YXRpY1NpemUpO1xuICAgICAgICAgICAgX2VuY29kZS5jYWxsKGNvZGVjLCBidWYsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBidWYuZmluaXNoQXN5bmMoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlKGFycmF5KSB7XG4gICAgICAgICAgICBjb25zdCBidWYgPSBuZXcgRGVjb2RlQnVmZmVyKGFycmF5KTtcbiAgICAgICAgICAgIHJldHVybiBfZGVjb2RlLmNhbGwoY29kZWMsIGJ1Zik7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4gY29kZWM7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQXN5bmNDb2RlYyhfY29kZWMpIHtcbiAgICBjb25zdCB7IF9zdGF0aWNTaXplLCBfZW5jb2RlQXN5bmMsIF9kZWNvZGUsIF9tZXRhZGF0YSwgbmFtZSB9ID0gX2NvZGVjO1xuICAgIGNvbnN0IGNvZGVjID0ge1xuICAgICAgICBuYW1lLFxuICAgICAgICBfc3RhdGljU2l6ZSxcbiAgICAgICAgX2VuY29kZShidWZmZXIsIHZhbHVlKSB7XG4gICAgICAgICAgICBidWZmZXIud3JpdGVBc3luYyhfc3RhdGljU2l6ZSwgKGJ1ZikgPT4gX2VuY29kZUFzeW5jKGJ1ZiwgdmFsdWUpKTtcbiAgICAgICAgfSxcbiAgICAgICAgX2RlY29kZSxcbiAgICAgICAgLi4uX21ldGFkYXRhICYmIHsgX21ldGFkYXRhIH0sXG4gICAgICAgIGVuY29kZSh2YWx1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVuY29kZUVycm9yKGNvZGVjLCB2YWx1ZSwgXCJBdHRlbXB0ZWQgdG8gc3luY2hyb25vdXNseSBlbmNvZGUgYW4gYXN5bmMgY29kZWNcIik7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGVuY29kZUFzeW5jKHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBidWYgPSBuZXcgRW5jb2RlQnVmZmVyKF9zdGF0aWNTaXplKTtcbiAgICAgICAgICAgIGF3YWl0IF9lbmNvZGVBc3luYy5jYWxsKGNvZGVjLCBidWYsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBidWYuZmluaXNoQXN5bmMoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlKGFycmF5KSB7XG4gICAgICAgICAgICBjb25zdCBidWYgPSBuZXcgRGVjb2RlQnVmZmVyKGFycmF5KTtcbiAgICAgICAgICAgIHJldHVybiBfZGVjb2RlLmNhbGwoY29kZWMsIGJ1Zik7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4gY29kZWM7XG59XG5leHBvcnQgZnVuY3Rpb24gd2l0aE1ldGFkYXRhKGNvZGVjLCBtZXRhZGF0YSkge1xuICAgIHJldHVybiB7IC4uLmNvZGVjLCBfbWV0YWRhdGE6IG1ldGFkYXRhIH07XG59XG5leHBvcnQgY2xhc3MgRW5jb2RlQnVmZmVyIHtcbiAgICAvKiogQ3JlYXRlcyBhIG5ldyBFbmNvZGVCdWZmZXIgd2l0aCBhIHNwZWNpZmllZCBpbml0aWFsIHNpemUvYnVmZmVyICovXG4gICAgY29uc3RydWN0b3IoaW5pdCwgY29udGV4dCA9IG5ldyBDb250ZXh0KCkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udGV4dFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogY29udGV4dFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZmluaXNoZWRBcnJheXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmaW5pc2hlZFNpemVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInF1ZXVlZEFycmF5c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFycmF5XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZpZXdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5kZXhcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFzeW5jQ291bnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFzeW5jUHJvbWlzZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFzeW5jUmVzb2x2ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogKCkgPT4geyB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zZXRBcnJheSh0eXBlb2YgaW5pdCA9PT0gXCJudW1iZXJcIiA/IG5ldyBVaW50OEFycmF5KGluaXQpIDogaW5pdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYSBVaW50OEFycmF5IGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBidWZmZXIuXG4gICAgICogVGhpcyBkb2VzIG5vdCBjb25zdW1lIGFueSBvZiB0aGUgcHJlLWFsbG9jYXRlZCBzcGFjZS5cbiAgICAgKi9cbiAgICBpbnNlcnRBcnJheShidWZmZXIpIHtcbiAgICAgICAgdGhpcy5fY29tbWl0V3JpdHRlbigpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkQXJyYXlzLnB1c2goYnVmZmVyKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZFNpemUgKz0gYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldEFycmF5KHRoaXMuYXJyYXkuc3ViYXJyYXkodGhpcy5pbmRleCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbG9jYXRlcyBtb3JlIHNwYWNlIGluIHRoZSBFbmNvZGVCdWZmZXIuXG4gICAgICogYC5wb3BBbGxvYygpYCBtdXN0IGJlIGNhbGxlZCBhZnRlciB0aGlzIHNwYWNlIGlzIHVzZWQuXG4gICAgICovXG4gICAgcHVzaEFsbG9jKHNpemUpIHtcbiAgICAgICAgdGhpcy5fY29tbWl0V3JpdHRlbigpO1xuICAgICAgICB0aGlzLnF1ZXVlZEFycmF5cy5wdXNoKHRoaXMuYXJyYXkuc3ViYXJyYXkodGhpcy5pbmRleCkpO1xuICAgICAgICB0aGlzLl9zZXRBcnJheShuZXcgVWludDhBcnJheShzaXplKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmlzaGVzIHRoZSBjdXJyZW50IGFycmF5IGFuZCByZXN1bWVzIHdyaXRpbmcgb24gdGhlIHByZXZpb3VzIGFycmF5LlxuICAgICAqIE11c3QgYmUgY2FsbGVkIGFmdGVyIGAucHVzaEFsbG9jKClgLlxuICAgICAqL1xuICAgIHBvcEFsbG9jKCkge1xuICAgICAgICB0aGlzLl9jb21taXRXcml0dGVuKCk7XG4gICAgICAgIHRoaXMuX3NldEFycmF5KHRoaXMucXVldWVkQXJyYXlzLnBvcCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHN1Yi1idWZmZXIgdGhhdCBjYW4gYmUgd3JpdHRlbiBpbnRvIGFzeW5jaHJvbm91c2x5LlxuICAgICAqIFRoZSBidWZmZXIgcGFzc2VkIHRvIHRoZSBjYWxsYmFjayBzaG91bGQgbm90IGJlIHVzZWQgYWZ0ZXIgdGhlIHJldHVybmVkIHByb21pc2UgcmVzb2x2ZXMuXG4gICAgICovXG4gICAgd3JpdGVBc3luYyhsZW5ndGgsIGZuKSB7XG4gICAgICAgIHRoaXMud2FpdEZvcihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjdXJzb3IgPSB0aGlzLmNyZWF0ZUN1cnNvcihsZW5ndGgpO1xuICAgICAgICAgICAgYXdhaXQgZm4oY3Vyc29yKTtcbiAgICAgICAgICAgIGN1cnNvci5jbG9zZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHN1Yi1idWZmZXIgdGhhdCBjYW4gYmUgd3JpdHRlbiBpbnRvIGxhdGVyIHRvIGluc2VydCBkYXRhIGludG8gdGhlIG1pZGRsZSBvZiB0aGUgYXJyYXkuXG4gICAgICogYC5jbG9zZSgpYCBtdXN0IGJlIGNhbGxlZCBhZnRlciB0aGUgY3Vyc29yIGlzIGRvbmUgYmVpbmcgd3JpdHRlbiBpbnRvLlxuICAgICAqIFRoZSBjdXJzb3Igc2hvdWxkIG5vdCBiZSB1c2VkIGFmdGVyIGAuY2xvc2UoKWAgaXMgY2FsbGVkLlxuICAgICAqIElmIHRoZSBjdXJzb3Igd2lsbCBiZSB3cml0dGVuIGludG8gYXN5bmNocm9ub3VzbHksIHRoZSBidWZmZXIgbXVzdCBiZSBoZWxkIG9wZW4gd2l0aCBgLndhaXRGb3IoKWAuXG4gICAgICovXG4gICAgY3JlYXRlQ3Vyc29yKGxlbmd0aCkge1xuICAgICAgICBjb25zdCBjdXJzb3IgPSBPYmplY3QuYXNzaWduKG5ldyBFbmNvZGVCdWZmZXIodGhpcy5zdGVhbEFsbG9jKGxlbmd0aCksIHRoaXMuY29udGV4dCksIHtcbiAgICAgICAgICAgIGNsb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy53YWl0Rm9yQnVmZmVyKGN1cnNvciwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjdXJzb3IuX2NvbW1pdFdyaXR0ZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5pc2hlZFNpemUgKz0gY3Vyc29yLmZpbmlzaGVkU2l6ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZpbmlzaGVkQXJyYXlzLnB1c2goY3Vyc29yKTtcbiAgICAgICAgcmV0dXJuIGN1cnNvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW1tZWRpYXRlbHkgaW52b2tlcyB0aGUgY2FsbGJhY2ssIGFuZCBob2xkcyB0aGUgYnVmZmVyIG9wZW4gdW50aWwgdGhlXG4gICAgICogcmV0dXJuZWQgcHJvbWlzZSByZXNvbHZlcy5cbiAgICAgKi9cbiAgICB3YWl0Rm9yKGZuKSB7XG4gICAgICAgIGlmICghdGhpcy5hc3luY0NvdW50KSB7XG4gICAgICAgICAgICB0aGlzLmFzeW5jUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB0aGlzLmFzeW5jUmVzb2x2ZSA9IHJlc29sdmUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXN5bmNDb3VudCsrO1xuICAgICAgICBmbigpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFzeW5jQ291bnQtLTtcbiAgICAgICAgICAgIGlmICghdGhpcy5hc3luY0NvdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hc3luY1Jlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hc3luY1Jlc29sdmUoUHJvbWlzZS5yZWplY3QoZSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3VtZXMgYGxlbmd0aGAgYWxsb2NhdGVkIGJ5dGVzIHdpdGhvdXQgd3JpdGluZyBhbnl0aGluZywgYW5kIHJldHVybnMgdGhlIHNraXBwZWQgc3ViYXJyYXkuXG4gICAgICogQW55dGhpbmcgd3JpdHRlbiBpbnRvIHRoZSByZXR1cm5lZCBhcnJheSB3aWxsIG5vdCBhZmZlY3QgdGhlIGJ1ZmZlcixcbiAgICAgKiBleGNlcHQgaWYgaXQgaXMgbGF0ZXIgcmVpbmNvcnBvcmF0ZWQgZS5nLiB2aWEgYC5pbnNlcnRBcnJheSgpYC5cbiAgICAgKiBSYXRoZXIgbmljaGUuXG4gICAgICovXG4gICAgc3RlYWxBbGxvYyhsZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fY29tbWl0V3JpdHRlbigpO1xuICAgICAgICBjb25zdCBhcnJheSA9IHRoaXMuYXJyYXkuc3ViYXJyYXkodGhpcy5pbmRleCwgdGhpcy5pbmRleCArIGxlbmd0aCk7XG4gICAgICAgIHRoaXMuX3NldEFycmF5KHRoaXMuYXJyYXkuc3ViYXJyYXkodGhpcy5pbmRleCArIGxlbmd0aCkpO1xuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIGNhbGxiYWNrIG9uY2UgYnVmZmVyJ3MgYXN5bmMgdGFza3MgZmluaXNoLCBhbmQgaG9sZHMgdGhpc1xuICAgICAqIGJ1ZmZlciBvcGVuIHVudGlsIHRoZSBjYWxsYmFjayByZXR1cm5zLlxuICAgICAqL1xuICAgIHdhaXRGb3JCdWZmZXIoYnVmZmVyLCBmbikge1xuICAgICAgICBpZiAoYnVmZmVyLmFzeW5jQ291bnQpIHtcbiAgICAgICAgICAgIHRoaXMud2FpdEZvcihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgYXdhaXQgYnVmZmVyLmFzeW5jUHJvbWlzZTtcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmlzaGVzIHRoZSBjdXJyZW50IGFycmF5LCBhbmQgcmV0dXJucyBhIFVpbnQ4QXJyYXkgY29udGFpbmluZyBldmVyeXRoaW5nIHdyaXR0ZW4uXG4gICAgICogVGhlIEVuY29kZUJ1ZmZlciBpcyBsZWZ0IGluIGFuIHVuZGVmaW5lZCBzdGF0ZSwgYW5kIHNob3VsZCBub3QgYmUgdXNlZCBhZnRlcndhcmRzLlxuICAgICAqIFRocm93cyBpZiBhc3luY2hyb25vdXMgd3JpdGVzIGFyZSBzdGlsbCBwZW5kaW5nLlxuICAgICAqL1xuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuYXN5bmNDb3VudClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRlZCB0byBmaW5pc2ggYmVmb3JlIGFzeW5jIGNvbXBsZXRpb25cIik7XG4gICAgICAgIGlmICghdGhpcy5maW5pc2hlZEFycmF5cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcnJheS5zdWJhcnJheSgwLCB0aGlzLmluZGV4KTtcbiAgICAgICAgdGhpcy5fY29tbWl0V3JpdHRlbigpO1xuICAgICAgICBjb25zdCBmdWxsQXJyYXkgPSBuZXcgVWludDhBcnJheSh0aGlzLmZpbmlzaGVkU2l6ZSk7XG4gICAgICAgIHRoaXMuX2ZpbmlzaEludG8oZnVsbEFycmF5LCAwKTtcbiAgICAgICAgcmV0dXJuIGZ1bGxBcnJheTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluaXNoZXMgdGhlIGN1cnJlbnQgYXJyYXksIGFuZCByZXR1cm5zIGEgVWludDhBcnJheSBjb250YWluaW5nIGV2ZXJ5dGhpbmcgd3JpdHRlbi5cbiAgICAgKiBUaGUgRW5jb2RlQnVmZmVyIGlzIGxlZnQgaW4gYW4gdW5kZWZpbmVkIHN0YXRlLCBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkIGFmdGVyd2FyZHMuXG4gICAgICovXG4gICAgYXN5bmMgZmluaXNoQXN5bmMoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuYXN5bmNQcm9taXNlO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2goKTtcbiAgICB9XG4gICAgLyoqIENvcGllcyBhbGwgZGF0YSBmcm9tIGZpbmlzaGVkQXJyYXlzIGludG8gZnVsbEFycmF5ICovXG4gICAgX2ZpbmlzaEludG8oZnVsbEFycmF5LCBpbmRleCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmluaXNoZWRBcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGFycmF5ID0gdGhpcy5maW5pc2hlZEFycmF5c1tpXTtcbiAgICAgICAgICAgIGlmIChhcnJheSBpbnN0YW5jZW9mIEVuY29kZUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gYXJyYXkuX2ZpbmlzaEludG8oZnVsbEFycmF5LCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmdWxsQXJyYXkuc2V0KGFycmF5LCBpbmRleCk7XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gYXJyYXkubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVzaGVzIHRoZSBkYXRhIHdyaXR0ZW4gaW4gYXJyYXkgdG8gZmluaXNoZWRBcnJheXMuXG4gICAgICogTGVhdmVzIHRoZSBidWZmZXIgaW4gYW4gaW52YWxpZCBzdGF0ZSAtLSBhcnJheSBhbmQgaW5kZXggbXVzdCBiZSB1cGRhdGVkLlxuICAgICAqL1xuICAgIF9jb21taXRXcml0dGVuKCkge1xuICAgICAgICBpZiAodGhpcy5pbmRleCkge1xuICAgICAgICAgICAgdGhpcy5maW5pc2hlZEFycmF5cy5wdXNoKHRoaXMuYXJyYXkuc3ViYXJyYXkoMCwgdGhpcy5pbmRleCkpO1xuICAgICAgICAgICAgdGhpcy5maW5pc2hlZFNpemUgKz0gdGhpcy5pbmRleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogU2V0cyBhcnJheSBhbmQgdXBkYXRlcyB2aWV3ICovXG4gICAgX3NldEFycmF5KGFycmF5KSB7XG4gICAgICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IERhdGFWaWV3KGFycmF5LmJ1ZmZlciwgYXJyYXkuYnl0ZU9mZnNldCwgYXJyYXkuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBEZWNvZGVCdWZmZXIge1xuICAgIGNvbnN0cnVjdG9yKGFycmF5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFycmF5XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBhcnJheVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmlld1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmRleFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udGV4dFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IENvbnRleHQoKVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IERhdGFWaWV3KGFycmF5LmJ1ZmZlciwgYXJyYXkuYnl0ZU9mZnNldCwgYXJyYXkuYnl0ZUxlbmd0aCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIENvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXBcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0KFQpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5tYXAuZ2V0KFQpO1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBUKCk7XG4gICAgICAgICAgICB0aGlzLm1hcC5zZXQoVCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQ29kZWNWaXNpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgX0NvZGVjVmlzaXRvcl9mYWxsYmFjay5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0NvZGVjVmlzaXRvcl92aXNpdG9ycy5zZXQodGhpcywgbmV3IE1hcCgpKTtcbiAgICB9XG4gICAgYWRkKGNvZGVjLCBmbikge1xuICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29kZWNWaXNpdG9yX3Zpc2l0b3JzLCBcImZcIikuaGFzKGNvZGVjKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIHZpc2l0b3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29kZWNWaXNpdG9yX3Zpc2l0b3JzLCBcImZcIikuc2V0KGNvZGVjLCBmbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmYWxsYmFjayhmbikge1xuICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29kZWNWaXNpdG9yX2ZhbGxiYWNrLCBcImZcIikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBmYWxsYmFja1wiKTtcbiAgICAgICAgfVxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Db2RlY1Zpc2l0b3JfZmFsbGJhY2ssIGZuLCBcImZcIik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgYGB0c1xuICAgICAqIHZpc2l0b3IuZ2VuZXJpYyg8VD4oKSA9PlxuICAgICAqICAgdmlzaXRvci5hZGQoJC5hcnJheTxUPiwgKGNvZGVjLCAkZWwpID0+IHtcbiAgICAgKiAgICAgLi4uXG4gICAgICogICB9KVxuICAgICAqIClcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZW5lcmljKGZuKSB7XG4gICAgICAgIGZuKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmlzaXQoY29kZWMpIHtcbiAgICAgICAgY29uc3QgdmlzaXRvciA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvZGVjVmlzaXRvcl92aXNpdG9ycywgXCJmXCIpLmdldChjb2RlYyk7XG4gICAgICAgIGlmICh2aXNpdG9yKVxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IoY29kZWMpO1xuICAgICAgICBpZiAoY29kZWMuX21ldGFkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCB2aXNpdG9yID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29kZWNWaXNpdG9yX3Zpc2l0b3JzLCBcImZcIikuZ2V0KGNvZGVjLl9tZXRhZGF0YVswXSk7XG4gICAgICAgICAgICBpZiAodmlzaXRvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXRvcihjb2RlYywgLi4uY29kZWMuX21ldGFkYXRhLnNsaWNlKDEpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29kZWNWaXNpdG9yX2ZhbGxiYWNrLCBcImZcIikpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db2RlY1Zpc2l0b3JfZmFsbGJhY2ssIFwiZlwiKS5jYWxsKHRoaXMsIGNvZGVjKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgY29kZWNcIik7XG4gICAgfVxufVxuX0NvZGVjVmlzaXRvcl9mYWxsYmFjayA9IG5ldyBXZWFrTWFwKCksIF9Db2RlY1Zpc2l0b3JfdmlzaXRvcnMgPSBuZXcgV2Vha01hcCgpO1xuZXhwb3J0IGNsYXNzIENvZGVjRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY29kZWMsIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvZGVjXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBjb2RlY1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRW5jb2RlRXJyb3IgZXh0ZW5kcyBDb2RlY0Vycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlYywgdmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIoY29kZWMsIG1lc3NhZ2UpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2YWx1ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwiRW5jb2RlRXJyb3JcIlxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRGVjb2RlRXJyb3IgZXh0ZW5kcyBDb2RlY0Vycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlYywgYnVmZmVyLCBtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKGNvZGVjLCBtZXNzYWdlKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYnVmZmVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBidWZmZXJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwiRGVjb2RlRXJyb3JcIlxuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tb24uanMubWFwIiwiaW1wb3J0IHsgY3JlYXRlQ29kZWMsIERlY29kZUVycm9yIH0gZnJvbSBcIi4uL2NvbW1vbi5qc1wiO1xuaW1wb3J0IHsgdTE2LCB1MzIgfSBmcm9tIFwiLi4vaW50L2NvZGVjLmpzXCI7XG5jb25zdCBNQVhfVTYgPSAwYjAwMTExMTExO1xuY29uc3QgTUFYX1UxNCA9IDE2MzgzO1xuY29uc3QgTUFYX1UzMCA9IDEwNzM3NDE4MjM7XG5jb25zdCBjb21wYWN0TnVtYmVyID0gY3JlYXRlQ29kZWMoe1xuICAgIG5hbWU6IFwiY29tcGFjdE51bWJlclwiLFxuICAgIF9tZXRhZGF0YTogbnVsbCxcbiAgICBfc3RhdGljU2l6ZTogNSxcbiAgICBfZW5jb2RlKGJ1ZmZlciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIDw9IE1BWF9VNikge1xuICAgICAgICAgICAgYnVmZmVyLmFycmF5W2J1ZmZlci5pbmRleCsrXSA9IHZhbHVlIDw8IDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPD0gTUFYX1UxNCkge1xuICAgICAgICAgICAgdTE2Ll9lbmNvZGUoYnVmZmVyLCAodmFsdWUgPDwgMikgfCAwYjAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA8PSBNQVhfVTMwKSB7XG4gICAgICAgICAgICAvLyBCZWNhdXNlIEpTIGJpdHdpc2Ugb3BzIHVzZSAqc2lnbmVkKiAzMi1iaXQgaW50cywgdGhpcyBvcGVyYXRpb25cbiAgICAgICAgICAgIC8vIHByb2R1Y2VzIG5lZ2F0aXZlIHZhbHVlcyB3aGVuIGB2YWx1ZSA+PSAyICoqIDI5YC4gSG93ZXZlciwgdGhpcyBpcyBvayxcbiAgICAgICAgICAgIC8vIGFzIGBzZXRVaW50MzJgIGNvcnJlY3RseSBjYXN0cyB0aGVzZSBuZWdhdGl2ZSB2YWx1ZXMgYmFjayB0byB1bnNpZ25lZFxuICAgICAgICAgICAgLy8gMzItYml0IGludHMuXG4gICAgICAgICAgICB1MzIuX2VuY29kZShidWZmZXIsICh2YWx1ZSA8PCAyKSB8IDBiMTApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnVmZmVyLmFycmF5W2J1ZmZlci5pbmRleCsrXSA9IDBiMTE7XG4gICAgICAgICAgICB1MzIuX2VuY29kZShidWZmZXIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgX2RlY29kZShidWZmZXIpIHtcbiAgICAgICAgc3dpdGNoIChidWZmZXIuYXJyYXlbYnVmZmVyLmluZGV4XSAmIDBiMTEpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyLmFycmF5W2J1ZmZlci5pbmRleCsrXSA+PiAyO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiB1MTYuX2RlY29kZShidWZmZXIpID4+IDI7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgLy8gV2UgdXNlIGFuIHVuc2lnbmVkIHJpZ2h0IHNoaWZ0LCBhcyB0aGUgZGVmYXVsdCBzaGlmdCBvcGVyYXRvclxuICAgICAgICAgICAgICAgIC8vIHVzZXMgc2lnbmVkIDMyLWJpdCBpbnRzLCB3aGljaCB3b3VsZCB5aWVsZCBpbnZhbGlkIHZhbHVlcy5cbiAgICAgICAgICAgICAgICByZXR1cm4gdTMyLl9kZWNvZGUoYnVmZmVyKSA+Pj4gMjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5hcnJheVtidWZmZXIuaW5kZXgrK10gIT09IDMpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBEZWNvZGVFcnJvcih0aGlzLCBidWZmZXIsIFwiT3V0IG9mIHJhbmdlIGZvciBVMzJcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHUzMi5fZGVjb2RlKGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICB9LFxufSk7XG5leHBvcnQgY29uc3QgY29tcGFjdFU4ID0gY29tcGFjdE51bWJlcjtcbmV4cG9ydCBjb25zdCBjb21wYWN0VTE2ID0gY29tcGFjdE51bWJlcjtcbmV4cG9ydCBjb25zdCBjb21wYWN0VTMyID0gY29tcGFjdE51bWJlcjtcbmNvbnN0IGNvbXBhY3RCaWdJbnQgPSBjcmVhdGVDb2RlYyh7XG4gICAgbmFtZTogXCJjb21wYWN0QmlnSW50XCIsXG4gICAgX21ldGFkYXRhOiBudWxsLFxuICAgIF9zdGF0aWNTaXplOiA1LFxuICAgIF9lbmNvZGUoYnVmZmVyLCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPD0gNDI5NDk2NzI5NSkge1xuICAgICAgICAgICAgY29tcGFjdE51bWJlci5fZW5jb2RlKGJ1ZmZlciwgTnVtYmVyKHZhbHVlKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGV4dHJhQnl0ZXMgPSAwO1xuICAgICAgICBsZXQgX3ZhbHVlID0gdmFsdWUgPj4gMzJuO1xuICAgICAgICB3aGlsZSAoX3ZhbHVlID4gMG4pIHtcbiAgICAgICAgICAgIF92YWx1ZSA+Pj0gOG47XG4gICAgICAgICAgICBleHRyYUJ5dGVzKys7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyLmFycmF5W2J1ZmZlci5pbmRleCsrXSA9IChleHRyYUJ5dGVzIDw8IDIpIHwgMGIxMTtcbiAgICAgICAgdTMyLl9lbmNvZGUoYnVmZmVyLCBOdW1iZXIodmFsdWUgJiAweGZmZmZmZmZmbikpO1xuICAgICAgICBfdmFsdWUgPSB2YWx1ZSA+PiAzMm47XG4gICAgICAgIGJ1ZmZlci5wdXNoQWxsb2MoZXh0cmFCeXRlcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXh0cmFCeXRlczsgaSsrKSB7XG4gICAgICAgICAgICBidWZmZXIuYXJyYXlbYnVmZmVyLmluZGV4KytdID0gTnVtYmVyKF92YWx1ZSAmIDB4ZmZuKTtcbiAgICAgICAgICAgIF92YWx1ZSA+Pj0gOG47XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyLnBvcEFsbG9jKCk7XG4gICAgfSxcbiAgICBfZGVjb2RlKGJ1ZmZlcikge1xuICAgICAgICBjb25zdCBiID0gYnVmZmVyLmFycmF5W2J1ZmZlci5pbmRleF07XG4gICAgICAgIGlmICgoYiAmIDBiMTEpIDwgMyB8fCBiID09PSAzKSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KGNvbXBhY3ROdW1iZXIuX2RlY29kZShidWZmZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleHRyYUJ5dGVzID0gYiA+PiAyO1xuICAgICAgICBidWZmZXIuaW5kZXgrKztcbiAgICAgICAgbGV0IHZhbHVlID0gQmlnSW50KHUzMi5fZGVjb2RlKGJ1ZmZlcikpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4dHJhQnl0ZXM7IGkrKykge1xuICAgICAgICAgICAgdmFsdWUgfD0gQmlnSW50KGJ1ZmZlci5hcnJheVtidWZmZXIuaW5kZXgrK10pIDw8IEJpZ0ludCgzMiArIGkgKiA4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbn0pO1xuZXhwb3J0IGNvbnN0IGNvbXBhY3RVNjQgPSBjb21wYWN0QmlnSW50O1xuZXhwb3J0IGNvbnN0IGNvbXBhY3RVMTI4ID0gY29tcGFjdEJpZ0ludDtcbmV4cG9ydCBjb25zdCBjb21wYWN0VTI1NiA9IGNvbXBhY3RCaWdJbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2RlYy5qcy5tYXAiLCJpbXBvcnQgeyBjcmVhdGVDb2RlYywgRGVjb2RlRXJyb3IsIEVuY29kZUVycm9yIH0gZnJvbSBcIi4uL2NvbW1vbi5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnN0YW50UGF0dGVybih2YWx1ZSwgYykge1xuICAgIGNvbnN0IHBhdHRlcm4gPSBjIGluc3RhbmNlb2YgVWludDhBcnJheSA/IGMgOiBjLmVuY29kZSh2YWx1ZSk7XG4gICAgcmV0dXJuIGNyZWF0ZUNvZGVjKHtcbiAgICAgICAgbmFtZTogXCJjb25zdGFudFBhdHRlcm5cIixcbiAgICAgICAgX21ldGFkYXRhOiBbY29uc3RhbnRQYXR0ZXJuLCB2YWx1ZSwgcGF0dGVybl0sXG4gICAgICAgIC8vIFdlIGNvdWxkIHNldCBgX3N0YXRpY1NpemVgIHRvIGBwYXR0ZXJuLmxlbmd0aGAsIGJ1dCBpbiB0aGlzIGNhc2UgaXQgd2lsbFxuICAgICAgICAvLyB1c3VhbGx5IG1vcmUgZWZmaWNpZW50IHRvIGluc2VydCBgcGF0dGVybmAgZHluYW1pY2FsbHksIHJhdGhlciB0aGFuXG4gICAgICAgIC8vIG1hbnVhbGx5IGNvcHkgdGhlIGJ5dGVzLlxuICAgICAgICBfc3RhdGljU2l6ZTogMCxcbiAgICAgICAgX2VuY29kZShidWZmZXIsIGdvdCkge1xuICAgICAgICAgICAgaWYgKGdvdCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRW5jb2RlRXJyb3IodGhpcywgZ290LCBgSW52YWxpZCB2YWx1ZTsgZXhwZWN0ZWQgJHt2YWx1ZX0sIGdvdCAke2dvdH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5pbnNlcnRBcnJheShwYXR0ZXJuKTtcbiAgICAgICAgfSxcbiAgICAgICAgX2RlY29kZShidWZmZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGdvdCA9IGJ1ZmZlci5hcnJheS5zdWJhcnJheShidWZmZXIuaW5kZXgsIGJ1ZmZlci5pbmRleCArPSBwYXR0ZXJuLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdHRlcm4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocGF0dGVybltpXSAhPT0gZ290W2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBEZWNvZGVFcnJvcih0aGlzLCBidWZmZXIsIGBJbnZhbGlkIHBhdHRlcm47IGV4cGVjdGVkICR7aGV4KHBhdHRlcm4pfSwgZ290ICR7aGV4KGdvdCl9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuZnVuY3Rpb24gaGV4KHBhdHRlcm4pIHtcbiAgICBsZXQgc3RyID0gXCIweFwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0dGVybi5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdHIgKz0gcGF0dGVybltpXS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29kZWMuanMubWFwIiwiZXhwb3J0IGZ1bmN0aW9uIGRlZmVycmVkKGdldENvZGVjKSB7XG4gICAgbGV0ICRjb2RlYztcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBcImRlZmVycmVkXCIsXG4gICAgICAgIF9tZXRhZGF0YTogW2RlZmVycmVkLCBnZXRDb2RlY10sXG4gICAgICAgIF9zdGF0aWNTaXplOiAwLFxuICAgICAgICBfZW5jb2RlKGJ1ZmZlciwgdmFsdWUpIHtcbiAgICAgICAgICAgICRjb2RlYyA/Pz0gZ2V0Q29kZWMoKTtcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoQWxsb2MoJGNvZGVjLl9zdGF0aWNTaXplKTtcbiAgICAgICAgICAgICRjb2RlYy5fZW5jb2RlKGJ1ZmZlciwgdmFsdWUpO1xuICAgICAgICAgICAgYnVmZmVyLnBvcEFsbG9jKCk7XG4gICAgICAgIH0sXG4gICAgICAgIF9kZWNvZGUoYnVmZmVyKSB7XG4gICAgICAgICAgICAkY29kZWMgPz89IGdldENvZGVjKCk7XG4gICAgICAgICAgICByZXR1cm4gJGNvZGVjLl9kZWNvZGUoYnVmZmVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW5jb2RlKHZhbHVlKSB7XG4gICAgICAgICAgICAkY29kZWMgPz89IGdldENvZGVjKCk7XG4gICAgICAgICAgICByZXR1cm4gJGNvZGVjLmVuY29kZSh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVuY29kZUFzeW5jKHZhbHVlKSB7XG4gICAgICAgICAgICAkY29kZWMgPz89IGdldENvZGVjKCk7XG4gICAgICAgICAgICByZXR1cm4gJGNvZGVjLmVuY29kZUFzeW5jKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlKGJ1ZmZlcikge1xuICAgICAgICAgICAgJGNvZGVjID8/PSBnZXRDb2RlYygpO1xuICAgICAgICAgICAgcmV0dXJuICRjb2RlYy5kZWNvZGUoYnVmZmVyKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29kZWMuanMubWFwIiwiaW1wb3J0IHsgY3JlYXRlQ29kZWMgfSBmcm9tIFwiLi4vY29tbW9uLmpzXCI7XG4vKipcbiAqIGBEdW1teWAncyBkZWNvZGVyIHJldHVybnMgYSBoYXJkLWNvZGVkIEpTIHZhbHVlIGFuZCBET0VTIE5PVCBlbmNvZGUgb3IgZGVjb2RlIGZyb20gYW55IGJ5dGVzLlxuICogQHBhcmFtIHZhbHVlIFRoZSBuYXRpdmUgdmFsdWUgY29ycmVzcG9uZGluZyB0byB0aGUgZ2VuZXJpY2FsbHktc3VwcGxpZWQgY29kZWNcbiAqIEByZXR1cm5zIEEgZHVtbXkgY29kZWMgd2l0aCB0aGUgcGF0Y2hlZCBzaWduYXR1cmUgb2YgYEVgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkdW1teSh2YWx1ZSkge1xuICAgIHJldHVybiBjcmVhdGVDb2RlYyh7XG4gICAgICAgIG5hbWU6IFwiZHVtbXlcIixcbiAgICAgICAgX21ldGFkYXRhOiBbZHVtbXksIHZhbHVlXSxcbiAgICAgICAgX3N0YXRpY1NpemU6IDAsXG4gICAgICAgIF9lbmNvZGUoKSB7IH0sXG4gICAgICAgIF9kZWNvZGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2RlYy5qcy5tYXAiLCJpbXBvcnQgeyBjcmVhdGVDb2RlYyB9IGZyb20gXCIuLi9jb21tb24uanNcIjtcbmltcG9ydCB7IG9iamVjdCB9IGZyb20gXCIuLi9vYmplY3QvY29kZWMuanNcIjtcbi8qKlxuICogQHBhcmFtIGN0b3IgVGhlIGNvbnN0cnVjdG9yIHdpdGggd2hpY2ggdG8gaW5zdGFudGlhdGUgdGhlIGluc3RhbmNlIC8gZnJvbSB3aG9zZSBpbnN0YW5jZSB0byBlbmNvZGVcbiAqIEBwYXJhbSBmaWVsZHMgdGhlIG9yZGVyZWQgZmllbGRzIHVzZWQgdG8gZGVjb2RlIHBhcmFtcyBmb3IgdGhlIGNvbnN0cnVjdG9yIC8gZW5jb2RlIGZyb20gdGhlIGluc3RhbmNlXG4gKiBAcmV0dXJucyB0aGUgaW5zdGFuY2UgY29kZWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbmNlKGN0b3IsIC4uLmZpZWxkcykge1xuICAgIGNvbnN0ICRvYmplY3QgPSBvYmplY3QoLi4uZmllbGRzKTtcbiAgICByZXR1cm4gY3JlYXRlQ29kZWMoe1xuICAgICAgICAuLi4kb2JqZWN0LFxuICAgICAgICBfbWV0YWRhdGE6IFtpbnN0YW5jZSwgY3RvciwgLi4uZmllbGRzXSxcbiAgICAgICAgX2RlY29kZShidWZmZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGFyciA9IEFycmF5KGZpZWxkcy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcnJbaV0gPSBmaWVsZHNbaV1bMV0uX2RlY29kZShidWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBjdG9yKC4uLmFycik7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2RlYy5qcy5tYXAiLCJpbXBvcnQgeyBjcmVhdGVDb2RlYyB9IGZyb20gXCIuLi9jb21tb24uanNcIjtcbmV4cG9ydCBjb25zdCB1OCA9IGNyZWF0ZUNvZGVjKHtcbiAgICBuYW1lOiBcInU4XCIsXG4gICAgX21ldGFkYXRhOiBbaW50LCBmYWxzZSwgOF0sXG4gICAgX3N0YXRpY1NpemU6IDEsXG4gICAgX2VuY29kZShidWZmZXIsIHZhbHVlKSB7XG4gICAgICAgIGJ1ZmZlci5hcnJheVtidWZmZXIuaW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9LFxuICAgIF9kZWNvZGUoYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBidWZmZXIuYXJyYXlbYnVmZmVyLmluZGV4KytdO1xuICAgIH0sXG59KTtcbmZ1bmN0aW9uIF9pbnQoc2l6ZSwga2V5KSB7XG4gICAgY29uc3QgZ2V0TWV0aG9kID0gRGF0YVZpZXcucHJvdG90eXBlW1wiZ2V0XCIgKyBrZXldO1xuICAgIGNvbnN0IHNldE1ldGhvZCA9IERhdGFWaWV3LnByb3RvdHlwZVtcInNldFwiICsga2V5XTtcbiAgICByZXR1cm4gY3JlYXRlQ29kZWMoe1xuICAgICAgICBuYW1lOiBgJHtrZXlbMF0udG9Mb3dlckNhc2V9JHtzaXplICogOH1gLFxuICAgICAgICBfbWV0YWRhdGE6IFtpbnQsIGtleS5pbmNsdWRlcyhcIkludFwiKSwgc2l6ZSAqIDhdLFxuICAgICAgICBfc3RhdGljU2l6ZTogc2l6ZSxcbiAgICAgICAgX2VuY29kZShidWZmZXIsIHZhbHVlKSB7XG4gICAgICAgICAgICBzZXRNZXRob2QuY2FsbChidWZmZXIudmlldywgYnVmZmVyLmluZGV4LCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICBidWZmZXIuaW5kZXggKz0gc2l6ZTtcbiAgICAgICAgfSxcbiAgICAgICAgX2RlY29kZShidWZmZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0TWV0aG9kLmNhbGwoYnVmZmVyLnZpZXcsIGJ1ZmZlci5pbmRleCwgdHJ1ZSk7XG4gICAgICAgICAgICBidWZmZXIuaW5kZXggKz0gc2l6ZTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBpOCA9IF9pbnQoMSwgXCJJbnQ4XCIpO1xuZXhwb3J0IGNvbnN0IHUxNiA9IF9pbnQoMiwgXCJVaW50MTZcIik7XG5leHBvcnQgY29uc3QgaTE2ID0gX2ludCgyLCBcIkludDE2XCIpO1xuZXhwb3J0IGNvbnN0IHUzMiA9IF9pbnQoNCwgXCJVaW50MzJcIik7XG5leHBvcnQgY29uc3QgaTMyID0gX2ludCg0LCBcIkludDMyXCIpO1xuZXhwb3J0IGNvbnN0IHU2NCA9IF9pbnQoOCwgXCJCaWdVaW50NjRcIik7XG5leHBvcnQgY29uc3QgaTY0ID0gX2ludCg4LCBcIkJpZ0ludDY0XCIpO1xuY29uc3QgXzEyOCA9IChzaWduZWQpID0+IHtcbiAgICBjb25zdCBnZXRNZXRob2QgPSBEYXRhVmlldy5wcm90b3R5cGVbc2lnbmVkID8gXCJnZXRCaWdJbnQ2NFwiIDogXCJnZXRCaWdVaW50NjRcIl07XG4gICAgcmV0dXJuIGNyZWF0ZUNvZGVjKHtcbiAgICAgICAgbmFtZTogYCR7c2lnbmVkID8gXCJpXCIgOiBcInVcIn0xMjhgLFxuICAgICAgICBfbWV0YWRhdGE6IFtpbnQsIHNpZ25lZCwgMTI4XSxcbiAgICAgICAgX3N0YXRpY1NpemU6IDE2LFxuICAgICAgICBfZW5jb2RlKGJ1ZmZlciwgdmFsdWUpIHtcbiAgICAgICAgICAgIGJ1ZmZlci52aWV3LnNldEJpZ0ludDY0KGJ1ZmZlci5pbmRleCwgdmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgYnVmZmVyLnZpZXcuc2V0QmlnSW50NjQoYnVmZmVyLmluZGV4ICsgOCwgdmFsdWUgPj4gNjRuLCB0cnVlKTtcbiAgICAgICAgICAgIGJ1ZmZlci5pbmRleCArPSAxNjtcbiAgICAgICAgfSxcbiAgICAgICAgX2RlY29kZShidWZmZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGIgPSBidWZmZXIudmlldy5nZXRCaWdVaW50NjQoYnVmZmVyLmluZGV4LCB0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBnZXRNZXRob2QuY2FsbChidWZmZXIudmlldywgYnVmZmVyLmluZGV4ICsgOCwgdHJ1ZSk7XG4gICAgICAgICAgICBidWZmZXIuaW5kZXggKz0gMTY7XG4gICAgICAgICAgICByZXR1cm4gKGEgPDwgNjRuKSB8IGI7XG4gICAgICAgIH0sXG4gICAgfSk7XG59O1xuZXhwb3J0IGNvbnN0IHUxMjggPSBfMTI4KGZhbHNlKTtcbmV4cG9ydCBjb25zdCBpMTI4ID0gXzEyOCh0cnVlKTtcbmNvbnN0IF8yNTYgPSAoc2lnbmVkKSA9PiB7XG4gICAgY29uc3QgZ2V0TWV0aG9kID0gRGF0YVZpZXcucHJvdG90eXBlW3NpZ25lZCA/IFwiZ2V0QmlnSW50NjRcIiA6IFwiZ2V0QmlnVWludDY0XCJdO1xuICAgIHJldHVybiBjcmVhdGVDb2RlYyh7XG4gICAgICAgIG5hbWU6IGAke3NpZ25lZCA/IFwiaVwiIDogXCJ1XCJ9MjU2YCxcbiAgICAgICAgX21ldGFkYXRhOiBbaW50LCBzaWduZWQsIDI1Nl0sXG4gICAgICAgIF9zdGF0aWNTaXplOiAzMixcbiAgICAgICAgX2VuY29kZShidWZmZXIsIHZhbHVlKSB7XG4gICAgICAgICAgICBidWZmZXIudmlldy5zZXRCaWdJbnQ2NChidWZmZXIuaW5kZXgsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgICAgIGJ1ZmZlci52aWV3LnNldEJpZ0ludDY0KGJ1ZmZlci5pbmRleCArIDgsIHZhbHVlID4+IDY0biwgdHJ1ZSk7XG4gICAgICAgICAgICBidWZmZXIudmlldy5zZXRCaWdJbnQ2NChidWZmZXIuaW5kZXggKyAxNiwgdmFsdWUgPj4gMTI4biwgdHJ1ZSk7XG4gICAgICAgICAgICBidWZmZXIudmlldy5zZXRCaWdJbnQ2NChidWZmZXIuaW5kZXggKyAyNCwgdmFsdWUgPj4gMTkybiwgdHJ1ZSk7XG4gICAgICAgICAgICBidWZmZXIuaW5kZXggKz0gMzI7XG4gICAgICAgIH0sXG4gICAgICAgIF9kZWNvZGUoYnVmZmVyKSB7XG4gICAgICAgICAgICBjb25zdCBkID0gYnVmZmVyLnZpZXcuZ2V0QmlnVWludDY0KGJ1ZmZlci5pbmRleCwgdHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBjID0gYnVmZmVyLnZpZXcuZ2V0QmlnVWludDY0KGJ1ZmZlci5pbmRleCArIDgsIHRydWUpO1xuICAgICAgICAgICAgY29uc3QgYiA9IGJ1ZmZlci52aWV3LmdldEJpZ1VpbnQ2NChidWZmZXIuaW5kZXggKyAxNiwgdHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBhID0gZ2V0TWV0aG9kLmNhbGwoYnVmZmVyLnZpZXcsIGJ1ZmZlci5pbmRleCArIDI0LCB0cnVlKTtcbiAgICAgICAgICAgIGJ1ZmZlci5pbmRleCArPSAzMjtcbiAgICAgICAgICAgIHJldHVybiAoYSA8PCAxOTJuKSB8IChiIDw8IDEyOG4pIHwgKGMgPDwgNjRuKSB8IGQ7XG4gICAgICAgIH0sXG4gICAgfSk7XG59O1xuZXhwb3J0IGNvbnN0IHUyNTYgPSBfMjU2KGZhbHNlKTtcbmV4cG9ydCBjb25zdCBpMjU2ID0gXzI1Nih0cnVlKTtcbmV4cG9ydCBmdW5jdGlvbiBpbnQoc2lnbmVkLCBzaXplKSB7XG4gICAgY29uc3Qga2V5ID0gYCR7c2lnbmVkID8gXCJpXCIgOiBcInVcIn0ke3NpemV9YDtcbiAgICByZXR1cm4geyB1OCwgaTgsIHUxNiwgaTE2LCB1MzIsIGkzMiwgdTY0LCBpNjQsIHUxMjgsIGkxMjgsIHUyNTYsIGkyNTYgfVtrZXldO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29kZWMuanMubWFwIiwiaW1wb3J0IHsgY3JlYXRlQ29kZWMsIERlY29kZUVycm9yLCBFbmNvZGVFcnJvciwgd2l0aE1ldGFkYXRhIH0gZnJvbSBcIi4uL2NvbW1vbi5qc1wiO1xuaW1wb3J0IHsgY29tcGFjdFUzMiB9IGZyb20gXCIuLi9jb21wYWN0L2NvZGVjLmpzXCI7XG5pbXBvcnQgeyB0dXBsZSB9IGZyb20gXCIuLi9tb2QuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBpdGVyYWJsZSh7ICRlbCwgY2FsY0xlbmd0aCwgcmVoeWRyYXRlIH0pIHtcbiAgICByZXR1cm4gY3JlYXRlQ29kZWMoe1xuICAgICAgICBuYW1lOiBcIml0ZXJhYmxlXCIsXG4gICAgICAgIF9tZXRhZGF0YTogW2l0ZXJhYmxlLCB7ICRlbCwgY2FsY0xlbmd0aCwgcmVoeWRyYXRlIH1dLFxuICAgICAgICBfc3RhdGljU2l6ZTogY29tcGFjdFUzMi5fc3RhdGljU2l6ZSxcbiAgICAgICAgX2VuY29kZShidWZmZXIsIHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBjYWxjTGVuZ3RoKHZhbHVlKTtcbiAgICAgICAgICAgIGNvbXBhY3RVMzIuX2VuY29kZShidWZmZXIsIGxlbmd0aCk7XG4gICAgICAgICAgICBidWZmZXIucHVzaEFsbG9jKGxlbmd0aCAqICRlbC5fc3RhdGljU2l6ZSk7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgJGVsLl9lbmNvZGUoYnVmZmVyLCBlbCk7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgIT09IGxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRW5jb2RlRXJyb3IodGhpcywgdmFsdWUsIFwiSW5jb3JyZWN0IGxlbmd0aCByZXR1cm5lZCBieSBjYWxjTGVuZ3RoXCIpO1xuICAgICAgICAgICAgYnVmZmVyLnBvcEFsbG9jKCk7XG4gICAgICAgIH0sXG4gICAgICAgIF9kZWNvZGUoYnVmZmVyKSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBjb21wYWN0VTMyLl9kZWNvZGUoYnVmZmVyKTtcbiAgICAgICAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJlaHlkcmF0ZShmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgJGVsLl9kZWNvZGUoYnVmZmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB9KCkpO1xuICAgICAgICAgICAgaWYgKCFkb25lKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBEZWNvZGVFcnJvcih0aGlzLCBidWZmZXIsIFwiSXRlcmFibGUgcGFzc2VkIHRvIHJlaHlkcmF0ZSBtdXN0IGJlIGltbWVkaWF0ZWx5IGV4aGF1c3RlZFwiKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXQoJGVsKSB7XG4gICAgcmV0dXJuIHdpdGhNZXRhZGF0YShpdGVyYWJsZSh7XG4gICAgICAgICRlbCxcbiAgICAgICAgY2FsY0xlbmd0aDogKHNldCkgPT4gc2V0LnNpemUsXG4gICAgICAgIHJlaHlkcmF0ZTogKHZhbHVlcykgPT4gbmV3IFNldCh2YWx1ZXMpLFxuICAgIH0pLCBbc2V0LCAkZWxdKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtYXAoJGtleSwgJHZhbHVlKSB7XG4gICAgcmV0dXJuIHdpdGhNZXRhZGF0YShpdGVyYWJsZSh7XG4gICAgICAgICRlbDogdHVwbGUoJGtleSwgJHZhbHVlKSxcbiAgICAgICAgY2FsY0xlbmd0aDogKG1hcCkgPT4gbWFwLnNpemUsXG4gICAgICAgIHJlaHlkcmF0ZTogKHZhbHVlcykgPT4gbmV3IE1hcCh2YWx1ZXMpLFxuICAgIH0pLCBbbWFwLCAka2V5LCAkdmFsdWVdKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvZGVjLmpzLm1hcCIsImltcG9ydCB7IGNyZWF0ZUNvZGVjIH0gZnJvbSBcIi4uL2NvbW1vbi5qc1wiO1xuaW1wb3J0IHsgY29tcGFjdFUzMiB9IGZyb20gXCIuLi9jb21wYWN0L2NvZGVjLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gbGVuUHJlZml4ZWQoJGlubmVyKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNvZGVjKHtcbiAgICAgICAgX21ldGFkYXRhOiBbbGVuUHJlZml4ZWQsICRpbm5lcl0sXG4gICAgICAgIF9zdGF0aWNTaXplOiBjb21wYWN0VTMyLl9zdGF0aWNTaXplICsgJGlubmVyLl9zdGF0aWNTaXplLFxuICAgICAgICBfZW5jb2RlKGJ1ZmZlciwgZXh0cmluc2ljKSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGhDdXJzb3IgPSBidWZmZXIuY3JlYXRlQ3Vyc29yKGNvbXBhY3RVMzIuX3N0YXRpY1NpemUpO1xuICAgICAgICAgICAgY29uc3QgY29udGVudEN1cnNvciA9IGJ1ZmZlci5jcmVhdGVDdXJzb3IoJGlubmVyLl9zdGF0aWNTaXplKTtcbiAgICAgICAgICAgICRpbm5lci5fZW5jb2RlKGNvbnRlbnRDdXJzb3IsIGV4dHJpbnNpYyk7XG4gICAgICAgICAgICBidWZmZXIud2FpdEZvckJ1ZmZlcihjb250ZW50Q3Vyc29yLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gY29udGVudEN1cnNvci5maW5pc2hlZFNpemUgKyBjb250ZW50Q3Vyc29yLmluZGV4O1xuICAgICAgICAgICAgICAgIGNvbXBhY3RVMzIuX2VuY29kZShsZW5ndGhDdXJzb3IsIGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbGVuZ3RoQ3Vyc29yLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgY29udGVudEN1cnNvci5jbG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIF9kZWNvZGUoYnVmZmVyKSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBjb21wYWN0VTMyLl9kZWNvZGUoYnVmZmVyKTtcbiAgICAgICAgICAgIHJldHVybiAkaW5uZXIuZGVjb2RlKGJ1ZmZlci5hcnJheS5zdWJhcnJheShidWZmZXIuaW5kZXgsIGJ1ZmZlci5pbmRleCArPSBsZW5ndGgpKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvZGVjLmpzLm1hcCIsImV4cG9ydCAqIGZyb20gXCIuL2FycmF5L2NvZGVjLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9iaXRTZXF1ZW5jZS9jb2RlYy5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vYm9vbC9jb2RlYy5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vY29tbW9uLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9jb21wYWN0L2NvZGVjLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9jb25zdGFudFBhdHRlcm4vY29kZWMuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2RlZmVycmVkL2NvZGVjLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9kdW1teS9jb2RlYy5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vaW5zdGFuY2UvY29kZWMuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2ludC9jb2RlYy5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vaXRlcmFibGUvY29kZWMuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2xlblByZWZpeGVkL2NvZGVjLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9uZXZlci9jb2RlYy5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vb2JqZWN0L2NvZGVjLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9vcHRpb24vY29kZWMuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL29wdGlvbi9vcHRpb25Cb29sL2NvZGVjLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9wcm9taXNlL2NvZGVjLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9yZXN1bHQvY29kZWMuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3NwcmVhZC9jb2RlYy5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vc3RyL2NvZGVjLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi90cmFuc2Zvcm0vY29kZWMuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3R1cGxlL2NvZGVjLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi91bmlvbi9jb2RlYy5qc1wiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kLmpzLm1hcCIsImltcG9ydCB7IGNyZWF0ZUNvZGVjLCBEZWNvZGVFcnJvciwgRW5jb2RlRXJyb3IgfSBmcm9tIFwiLi4vY29tbW9uLmpzXCI7XG5leHBvcnQgY29uc3QgbmV2ZXIgPSBjcmVhdGVDb2RlYyh7XG4gICAgbmFtZTogXCJuZXZlclwiLFxuICAgIF9tZXRhZGF0YTogbnVsbCxcbiAgICBfc3RhdGljU2l6ZTogMCxcbiAgICBfZW5jb2RlKHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFbmNvZGVFcnJvcih0aGlzLCB2YWx1ZSwgXCJDYW5ub3QgZW5jb2RlICQubmV2ZXJcIik7XG4gICAgfSxcbiAgICBfZGVjb2RlKGJ1ZmZlcikge1xuICAgICAgICB0aHJvdyBuZXcgRGVjb2RlRXJyb3IodGhpcywgYnVmZmVyLCBcIkNhbm5vdCBkZWNvZGUgJC5uZXZlclwiKTtcbiAgICB9LFxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2RlYy5qcy5tYXAiLCJpbXBvcnQgeyBjcmVhdGVDb2RlYyB9IGZyb20gXCIuLi9jb21tb24uanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBvYmplY3QoLi4uZmllbGRzKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNvZGVjKHtcbiAgICAgICAgbmFtZTogXCJvYmplY3RcIixcbiAgICAgICAgX21ldGFkYXRhOiBbb2JqZWN0LCAuLi5maWVsZHNdLFxuICAgICAgICBfc3RhdGljU2l6ZTogZmllbGRzLm1hcCgoeCkgPT4geFsxXS5fc3RhdGljU2l6ZSkucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCksXG4gICAgICAgIF9lbmNvZGUoYnVmZmVyLCB2YWx1ZSkge1xuICAgICAgICAgICAgZmllbGRzLmZvckVhY2goKFtrZXksIGZpZWxkRW5jb2Rlcl0pID0+IHtcbiAgICAgICAgICAgICAgICBmaWVsZEVuY29kZXIuX2VuY29kZShidWZmZXIsIHZhbHVlW2tleV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIF9kZWNvZGUoYnVmZmVyKSB7XG4gICAgICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2tleSwgZmllbGRdID0gZmllbGRzW2ldO1xuICAgICAgICAgICAgICAgIG9ialtrZXldID0gZmllbGQuX2RlY29kZShidWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvZGVjLmpzLm1hcCIsImltcG9ydCB7IGNyZWF0ZUNvZGVjLCBEZWNvZGVFcnJvciB9IGZyb20gXCIuLi9jb21tb24uanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBvcHRpb24oJHNvbWUpIHtcbiAgICByZXR1cm4gY3JlYXRlQ29kZWMoe1xuICAgICAgICBuYW1lOiBcIm9wdGlvblwiLFxuICAgICAgICBfbWV0YWRhdGE6IFtvcHRpb24sICRzb21lXSxcbiAgICAgICAgX3N0YXRpY1NpemU6IDEgKyAkc29tZS5fc3RhdGljU2l6ZSxcbiAgICAgICAgX2VuY29kZShidWZmZXIsIHZhbHVlKSB7XG4gICAgICAgICAgICBidWZmZXIuYXJyYXlbYnVmZmVyLmluZGV4KytdID0gKyh2YWx1ZSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgJHNvbWUuX2VuY29kZShidWZmZXIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2RlY29kZShidWZmZXIpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoYnVmZmVyLmFycmF5W2J1ZmZlci5pbmRleCsrXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDoge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRzb21lLl9kZWNvZGUoYnVmZmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRGVjb2RlRXJyb3IoJHNvbWUsIGJ1ZmZlciwgXCJDb3VsZCBub3QgZGVjb2RlIE9wdGlvbiBhcyBgU29tZShfKWAgbm9yIGBOb25lYFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2RlYy5qcy5tYXAiLCJpbXBvcnQgeyBjcmVhdGVDb2RlYyB9IGZyb20gXCIuLi8uLi9jb21tb24uanNcIjtcbmV4cG9ydCBjb25zdCBvcHRpb25Cb29sID0gY3JlYXRlQ29kZWMoe1xuICAgIG5hbWU6IFwib3B0aW9uQm9vbFwiLFxuICAgIF9tZXRhZGF0YTogbnVsbCxcbiAgICBfc3RhdGljU2l6ZTogMSxcbiAgICBfZW5jb2RlKGJ1ZmZlciwgdmFsdWUpIHtcbiAgICAgICAgYnVmZmVyLmFycmF5W2J1ZmZlci5pbmRleCsrXSA9IHZhbHVlID09PSB1bmRlZmluZWQgPyAwIDogMSArICshdmFsdWU7XG4gICAgfSxcbiAgICBfZGVjb2RlKGJ1ZmZlcikge1xuICAgICAgICBjb25zdCBieXRlID0gYnVmZmVyLmFycmF5W2J1ZmZlci5pbmRleCsrXTtcbiAgICAgICAgcmV0dXJuIGJ5dGUgPT09IDAgPyB1bmRlZmluZWQgOiAhKGJ5dGUgLSAxKTtcbiAgICB9LFxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2RlYy5qcy5tYXAiLCJpbXBvcnQgeyBjcmVhdGVBc3luY0NvZGVjIH0gZnJvbSBcIi4uL2NvbW1vbi5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHByb21pc2UoJHZhbHVlKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jQ29kZWMoe1xuICAgICAgICBuYW1lOiBcInByb21pc2VcIixcbiAgICAgICAgX21ldGFkYXRhOiBbcHJvbWlzZSwgJHZhbHVlXSxcbiAgICAgICAgX3N0YXRpY1NpemU6ICR2YWx1ZS5fc3RhdGljU2l6ZSxcbiAgICAgICAgYXN5bmMgX2VuY29kZUFzeW5jKGJ1ZmZlciwgdmFsdWUpIHtcbiAgICAgICAgICAgICR2YWx1ZS5fZW5jb2RlKGJ1ZmZlciwgYXdhaXQgdmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBfZGVjb2RlKGJ1ZmZlcikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgkdmFsdWUuX2RlY29kZShidWZmZXIpKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvZGVjLmpzLm1hcCIsImltcG9ydCB7IHVuaW9uIH0gZnJvbSBcIi4uL3VuaW9uL2NvZGVjLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gcmVzdWx0KCRvaywgJGVycikge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHVuaW9uKCh2YWx1ZSkgPT4gdmFsdWUgaW5zdGFuY2VvZiBFcnJvciA/IDEgOiAwLCBbJG9rLCAkZXJyXSksIHtcbiAgICAgICAgX21ldGFkYXRhOiBbcmVzdWx0LCAkb2ssICRlcnJdLFxuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29kZWMuanMubWFwIiwiaW1wb3J0IHsgY3JlYXRlQ29kZWMgfSBmcm9tIFwiLi4vY29tbW9uLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gc3ByZWFkKCRhLCAkYikge1xuICAgIHJldHVybiBjcmVhdGVDb2RlYyh7XG4gICAgICAgIG5hbWU6IFwic3ByZWFkXCIsXG4gICAgICAgIF9tZXRhZGF0YTogW3NwcmVhZCwgJGEsICRiXSxcbiAgICAgICAgX3N0YXRpY1NpemU6ICRhLl9zdGF0aWNTaXplICsgJGIuX3N0YXRpY1NpemUsXG4gICAgICAgIF9lbmNvZGUoYnVmZmVyLCB2YWx1ZSkge1xuICAgICAgICAgICAgJGEuX2VuY29kZShidWZmZXIsIHZhbHVlKTtcbiAgICAgICAgICAgICRiLl9lbmNvZGUoYnVmZmVyLCB2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIF9kZWNvZGUoYnVmZmVyKSB7XG4gICAgICAgICAgICByZXR1cm4geyAuLi4kYS5fZGVjb2RlKGJ1ZmZlciksIC4uLiRiLl9kZWNvZGUoYnVmZmVyKSB9O1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29kZWMuanMubWFwIiwiaW1wb3J0IHsgY3JlYXRlQ29kZWMsIERlY29kZUVycm9yIH0gZnJvbSBcIi4uL2NvbW1vbi5qc1wiO1xuaW1wb3J0IHsgY29tcGFjdFUzMiB9IGZyb20gXCIuLi9jb21wYWN0L2NvZGVjLmpzXCI7XG5leHBvcnQgY29uc3Qgc3RyID0gY3JlYXRlQ29kZWMoe1xuICAgIG5hbWU6IFwic3RyXCIsXG4gICAgX21ldGFkYXRhOiBudWxsLFxuICAgIF9zdGF0aWNTaXplOiBjb21wYWN0VTMyLl9zdGF0aWNTaXplLFxuICAgIF9lbmNvZGUoYnVmZmVyLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBhcnJheSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZSk7XG4gICAgICAgIGNvbXBhY3RVMzIuX2VuY29kZShidWZmZXIsIGFycmF5Lmxlbmd0aCk7XG4gICAgICAgIGJ1ZmZlci5pbnNlcnRBcnJheShhcnJheSk7XG4gICAgfSxcbiAgICBfZGVjb2RlKGJ1ZmZlcikge1xuICAgICAgICBjb25zdCBsZW4gPSBjb21wYWN0VTMyLl9kZWNvZGUoYnVmZmVyKTtcbiAgICAgICAgaWYgKGJ1ZmZlci5hcnJheS5sZW5ndGggPCBidWZmZXIuaW5kZXggKyBsZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBEZWNvZGVFcnJvcih0aGlzLCBidWZmZXIsIFwiQXR0ZW1wdGluZyB0byBgc3RyYC1kZWNvZGUgYmV5b25kIGJvdW5kcyBvZiBpbnB1dCBieXRlc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzbGljZSA9IGJ1ZmZlci5hcnJheS5zbGljZShidWZmZXIuaW5kZXgsIGJ1ZmZlci5pbmRleCArIGxlbik7XG4gICAgICAgIGJ1ZmZlci5pbmRleCArPSBsZW47XG4gICAgICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoc2xpY2UpO1xuICAgIH0sXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvZGVjLmpzLm1hcCIsImltcG9ydCB7IGNyZWF0ZUNvZGVjIH0gZnJvbSBcIi4uL2NvbW1vbi5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybSgkYmFzZSwgZW5jb2RlLCBkZWNvZGUpIHtcbiAgICByZXR1cm4gY3JlYXRlQ29kZWMoe1xuICAgICAgICBuYW1lOiBcInRyYW5zZm9ybVwiLFxuICAgICAgICBfbWV0YWRhdGE6IFt0cmFuc2Zvcm0sICRiYXNlLCBlbmNvZGUsIGRlY29kZV0sXG4gICAgICAgIF9zdGF0aWNTaXplOiAkYmFzZS5fc3RhdGljU2l6ZSxcbiAgICAgICAgX2VuY29kZShidWZmZXIsIHZhbHVlKSB7XG4gICAgICAgICAgICAkYmFzZS5fZW5jb2RlKGJ1ZmZlciwgZW5jb2RlKHZhbHVlKSk7XG4gICAgICAgIH0sXG4gICAgICAgIF9kZWNvZGUoYnVmZmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlKCRiYXNlLl9kZWNvZGUoYnVmZmVyKSk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2RlYy5qcy5tYXAiLCJpbXBvcnQgeyBjcmVhdGVDb2RlYyB9IGZyb20gXCIuLi9jb21tb24uanNcIjtcbmV4cG9ydCBmdW5jdGlvbiB0dXBsZSguLi5jb2RlY3MpIHtcbiAgICByZXR1cm4gY3JlYXRlQ29kZWMoe1xuICAgICAgICBuYW1lOiBcInR1cGxlXCIsXG4gICAgICAgIF9tZXRhZGF0YTogW3R1cGxlLCAuLi5jb2RlY3NdLFxuICAgICAgICBfc3RhdGljU2l6ZTogY29kZWNzLm1hcCgoeCkgPT4geC5fc3RhdGljU2l6ZSkucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCksXG4gICAgICAgIF9lbmNvZGUoYnVmZmVyLCB2YWx1ZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2RlY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb2RlY3NbaV0uX2VuY29kZShidWZmZXIsIHZhbHVlW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2RlY29kZShidWZmZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gQXJyYXkoY29kZWNzLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvZGVjcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhbHVlW2ldID0gY29kZWNzW2ldLl9kZWNvZGUoYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvZGVjLmpzLm1hcCIsImltcG9ydCB7IGNyZWF0ZUNvZGVjLCBEZWNvZGVFcnJvciwgd2l0aE1ldGFkYXRhIH0gZnJvbSBcIi4uL2NvbW1vbi5qc1wiO1xuaW1wb3J0IHsgZHVtbXkgfSBmcm9tIFwiLi4vZHVtbXkvY29kZWMuanNcIjtcbmltcG9ydCB7IG9iamVjdCB9IGZyb20gXCIuLi9vYmplY3QvY29kZWMuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiB1bmlvbihnZXRJbmRleCwgJG1lbWJlcnMpIHtcbiAgICByZXR1cm4gY3JlYXRlQ29kZWMoe1xuICAgICAgICBuYW1lOiBcInVuaW9uXCIsXG4gICAgICAgIF9tZXRhZGF0YTogW3VuaW9uLCBnZXRJbmRleCwgJG1lbWJlcnNdLFxuICAgICAgICBfc3RhdGljU2l6ZTogMSArIE1hdGgubWF4KC4uLk9iamVjdC52YWx1ZXMoJG1lbWJlcnMpLm1hcCgoeCkgPT4geC5fc3RhdGljU2l6ZSkpLFxuICAgICAgICBfZW5jb2RlKGJ1ZmZlciwgdmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpc2NyaW1pbmFudCA9IGdldEluZGV4KHZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0ICRtZW1iZXIgPSAkbWVtYmVyc1tkaXNjcmltaW5hbnRdO1xuICAgICAgICAgICAgYnVmZmVyLmFycmF5W2J1ZmZlci5pbmRleCsrXSA9IGRpc2NyaW1pbmFudDtcbiAgICAgICAgICAgICRtZW1iZXIuX2VuY29kZShidWZmZXIsIHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgX2RlY29kZShidWZmZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpc2NyaW1pbmFudCA9IGJ1ZmZlci5hcnJheVtidWZmZXIuaW5kZXgrK107XG4gICAgICAgICAgICBjb25zdCAkbWVtYmVyID0gJG1lbWJlcnNbZGlzY3JpbWluYW50XTtcbiAgICAgICAgICAgIGlmICghJG1lbWJlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBEZWNvZGVFcnJvcih0aGlzLCBidWZmZXIsIGBObyBzdWNoIG1lbWJlciBjb2RlYyBtYXRjaGluZyB0aGUgZGlzY3JpbWluYW50IFxcYCR7ZGlzY3JpbWluYW50fVxcYGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRtZW1iZXIuX2RlY29kZShidWZmZXIpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRhZ2dlZFVuaW9uKHRhZ0tleSwgbWVtYmVycykge1xuICAgIGNvbnN0IHRhZ1RvRGlzY3JpbWluYW50ID0ge307XG4gICAgY29uc3QgZGlzY3JpbWluYW50VG9NZW1iZXIgPSB7fTtcbiAgICBmb3IgKGNvbnN0IF9kaXNjcmltaW5hbnQgaW4gbWVtYmVycykge1xuICAgICAgICBjb25zdCBkaXNjcmltaW5hbnQgPSArX2Rpc2NyaW1pbmFudDtcbiAgICAgICAgaWYgKGlzTmFOKGRpc2NyaW1pbmFudCkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgW3RhZywgLi4uZmllbGRzXSA9IG1lbWJlcnNbZGlzY3JpbWluYW50XTtcbiAgICAgICAgdGFnVG9EaXNjcmltaW5hbnRbdGFnXSA9IGRpc2NyaW1pbmFudDtcbiAgICAgICAgZGlzY3JpbWluYW50VG9NZW1iZXJbZGlzY3JpbWluYW50XSA9IG9iamVjdChbdGFnS2V5LCBkdW1teSh0YWcpXSwgLi4uZmllbGRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHdpdGhNZXRhZGF0YSh1bmlvbigodmFsdWUpID0+IHRhZ1RvRGlzY3JpbWluYW50W3ZhbHVlW3RhZ0tleV1dLCBkaXNjcmltaW5hbnRUb01lbWJlciksIFt0YWdnZWRVbmlvbiwgdGFnS2V5LCBtZW1iZXJzXSk7XG59XG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nVW5pb24obWVtYmVycykge1xuICAgIGNvbnN0IGtleVRvRGlzY3JpbWluYW50ID0ge307XG4gICAgZm9yIChjb25zdCBfZGlzY3JpbWluYW50IGluIG1lbWJlcnMpIHtcbiAgICAgICAgY29uc3QgZGlzY3JpbWluYW50ID0gK19kaXNjcmltaW5hbnQ7XG4gICAgICAgIGlmIChpc05hTihkaXNjcmltaW5hbnQpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IGtleSA9IG1lbWJlcnNbZGlzY3JpbWluYW50XTtcbiAgICAgICAga2V5VG9EaXNjcmltaW5hbnRba2V5XSA9IGRpc2NyaW1pbmFudDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNvZGVjKHtcbiAgICAgICAgbmFtZTogXCJzdHJpbmdVbmlvblwiLFxuICAgICAgICBfbWV0YWRhdGE6IFtzdHJpbmdVbmlvbiwgbWVtYmVyc10sXG4gICAgICAgIF9zdGF0aWNTaXplOiAxLFxuICAgICAgICBfZW5jb2RlKGJ1ZmZlciwgdmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpc2NyaW1pbmFudCA9IGtleVRvRGlzY3JpbWluYW50W3ZhbHVlXTtcbiAgICAgICAgICAgIGJ1ZmZlci5hcnJheVtidWZmZXIuaW5kZXgrK10gPSBkaXNjcmltaW5hbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIF9kZWNvZGUoYnVmZmVyKSB7XG4gICAgICAgICAgICBjb25zdCBkaXNjcmltaW5hbnQgPSBidWZmZXIuYXJyYXlbYnVmZmVyLmluZGV4KytdO1xuICAgICAgICAgICAgcmV0dXJuIG1lbWJlcnNbZGlzY3JpbWluYW50XTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvZGVjLmpzLm1hcCIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRpZiAoY2FjaGVkTW9kdWxlLmVycm9yICE9PSB1bmRlZmluZWQpIHRocm93IGNhY2hlZE1vZHVsZS5lcnJvcjtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0dHJ5IHtcblx0XHR2YXIgZXhlY09wdGlvbnMgPSB7IGlkOiBtb2R1bGVJZCwgbW9kdWxlOiBtb2R1bGUsIGZhY3Rvcnk6IF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLCByZXF1aXJlOiBfX3dlYnBhY2tfcmVxdWlyZV9fIH07XG5cdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pLmZvckVhY2goZnVuY3Rpb24oaGFuZGxlcikgeyBoYW5kbGVyKGV4ZWNPcHRpb25zKTsgfSk7XG5cdFx0bW9kdWxlID0gZXhlY09wdGlvbnMubW9kdWxlO1xuXHRcdGV4ZWNPcHRpb25zLmZhY3RvcnkuY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgZXhlY09wdGlvbnMucmVxdWlyZSk7XG5cdH0gY2F0Y2goZSkge1xuXHRcdG1vZHVsZS5lcnJvciA9IGU7XG5cdFx0dGhyb3cgZTtcblx0fVxuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuLy8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbl9fd2VicGFja19yZXF1aXJlX18ubSA9IF9fd2VicGFja19tb2R1bGVzX187XG5cbi8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX187XG5cbi8vIGV4cG9zZSB0aGUgbW9kdWxlIGV4ZWN1dGlvbiBpbnRlcmNlcHRvclxuX193ZWJwYWNrX3JlcXVpcmVfXy5pID0gW107XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0ZnVuY3Rpb24oKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG5cdFx0ZnVuY3Rpb24oKSB7IHJldHVybiBtb2R1bGU7IH07XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBkZWZpbml0aW9uKSB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uZiA9IHt9O1xuLy8gVGhpcyBmaWxlIGNvbnRhaW5zIG9ubHkgdGhlIGVudHJ5IGNodW5rLlxuLy8gVGhlIGNodW5rIGxvYWRpbmcgZnVuY3Rpb24gZm9yIGFkZGl0aW9uYWwgY2h1bmtzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmUgPSBmdW5jdGlvbihjaHVua0lkKSB7XG5cdHJldHVybiBQcm9taXNlLmFsbChPYmplY3Qua2V5cyhfX3dlYnBhY2tfcmVxdWlyZV9fLmYpLnJlZHVjZShmdW5jdGlvbihwcm9taXNlcywga2V5KSB7XG5cdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5mW2tleV0oY2h1bmtJZCwgcHJvbWlzZXMpO1xuXHRcdHJldHVybiBwcm9taXNlcztcblx0fSwgW10pKTtcbn07IiwiLy8gVGhpcyBmdW5jdGlvbiBhbGxvdyB0byByZWZlcmVuY2UgYXN5bmMgY2h1bmtzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnUgPSBmdW5jdGlvbihjaHVua0lkKSB7XG5cdC8vIHJldHVybiB1cmwgZm9yIGZpbGVuYW1lcyBiYXNlZCBvbiB0ZW1wbGF0ZVxuXHRyZXR1cm4gXCJcIiArIGNodW5rSWQgKyBcIi5qc1wiO1xufTsiLCIvLyBUaGlzIGZ1bmN0aW9uIGFsbG93IHRvIHJlZmVyZW5jZSBhbGwgY2h1bmtzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmh1ID0gZnVuY3Rpb24oY2h1bmtJZCkge1xuXHQvLyByZXR1cm4gdXJsIGZvciBmaWxlbmFtZXMgYmFzZWQgb24gdGVtcGxhdGVcblx0cmV0dXJuIFwiXCIgKyBjaHVua0lkICsgXCIuXCIgKyBfX3dlYnBhY2tfcmVxdWlyZV9fLmgoKSArIFwiLmhvdC11cGRhdGUuanNcIjtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5obXJGID0gZnVuY3Rpb24oKSB7IHJldHVybiBcIm1haW4uXCIgKyBfX3dlYnBhY2tfcmVxdWlyZV9fLmgoKSArIFwiLmhvdC11cGRhdGUuanNvblwiOyB9OyIsIl9fd2VicGFja19yZXF1aXJlX18uaCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCI5YzA3ZGY0NDMyYjY0YjRhMzRjZVwiOyB9IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcblx0fVxufSkoKTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmosIHByb3ApIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApOyB9IiwidmFyIGluUHJvZ3Jlc3MgPSB7fTtcbnZhciBkYXRhV2VicGFja1ByZWZpeCA9IFwiY2FwaS1zaW1wbGUtZGVtbzpcIjtcbi8vIGxvYWRTY3JpcHQgZnVuY3Rpb24gdG8gbG9hZCBhIHNjcmlwdCB2aWEgc2NyaXB0IHRhZ1xuX193ZWJwYWNrX3JlcXVpcmVfXy5sID0gZnVuY3Rpb24odXJsLCBkb25lLCBrZXksIGNodW5rSWQpIHtcblx0aWYoaW5Qcm9ncmVzc1t1cmxdKSB7IGluUHJvZ3Jlc3NbdXJsXS5wdXNoKGRvbmUpOyByZXR1cm47IH1cblx0dmFyIHNjcmlwdCwgbmVlZEF0dGFjaDtcblx0aWYoa2V5ICE9PSB1bmRlZmluZWQpIHtcblx0XHR2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzY3JpcHRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgcyA9IHNjcmlwdHNbaV07XG5cdFx0XHRpZihzLmdldEF0dHJpYnV0ZShcInNyY1wiKSA9PSB1cmwgfHwgcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLXdlYnBhY2tcIikgPT0gZGF0YVdlYnBhY2tQcmVmaXggKyBrZXkpIHsgc2NyaXB0ID0gczsgYnJlYWs7IH1cblx0XHR9XG5cdH1cblx0aWYoIXNjcmlwdCkge1xuXHRcdG5lZWRBdHRhY2ggPSB0cnVlO1xuXHRcdHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXG5cdFx0c2NyaXB0LmNoYXJzZXQgPSAndXRmLTgnO1xuXHRcdHNjcmlwdC50aW1lb3V0ID0gMTIwO1xuXHRcdGlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLm5jKSB7XG5cdFx0XHRzY3JpcHQuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgX193ZWJwYWNrX3JlcXVpcmVfXy5uYyk7XG5cdFx0fVxuXHRcdHNjcmlwdC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXdlYnBhY2tcIiwgZGF0YVdlYnBhY2tQcmVmaXggKyBrZXkpO1xuXHRcdHNjcmlwdC5zcmMgPSB1cmw7XG5cdH1cblx0aW5Qcm9ncmVzc1t1cmxdID0gW2RvbmVdO1xuXHR2YXIgb25TY3JpcHRDb21wbGV0ZSA9IGZ1bmN0aW9uKHByZXYsIGV2ZW50KSB7XG5cdFx0Ly8gYXZvaWQgbWVtIGxlYWtzIGluIElFLlxuXHRcdHNjcmlwdC5vbmVycm9yID0gc2NyaXB0Lm9ubG9hZCA9IG51bGw7XG5cdFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHRcdHZhciBkb25lRm5zID0gaW5Qcm9ncmVzc1t1cmxdO1xuXHRcdGRlbGV0ZSBpblByb2dyZXNzW3VybF07XG5cdFx0c2NyaXB0LnBhcmVudE5vZGUgJiYgc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcblx0XHRkb25lRm5zICYmIGRvbmVGbnMuZm9yRWFjaChmdW5jdGlvbihmbikgeyByZXR1cm4gZm4oZXZlbnQpOyB9KTtcblx0XHRpZihwcmV2KSByZXR1cm4gcHJldihldmVudCk7XG5cdH1cblx0O1xuXHR2YXIgdGltZW91dCA9IHNldFRpbWVvdXQob25TY3JpcHRDb21wbGV0ZS5iaW5kKG51bGwsIHVuZGVmaW5lZCwgeyB0eXBlOiAndGltZW91dCcsIHRhcmdldDogc2NyaXB0IH0pLCAxMjAwMDApO1xuXHRzY3JpcHQub25lcnJvciA9IG9uU2NyaXB0Q29tcGxldGUuYmluZChudWxsLCBzY3JpcHQub25lcnJvcik7XG5cdHNjcmlwdC5vbmxvYWQgPSBvblNjcmlwdENvbXBsZXRlLmJpbmQobnVsbCwgc2NyaXB0Lm9ubG9hZCk7XG5cdG5lZWRBdHRhY2ggJiYgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xufTsiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsInZhciBjdXJyZW50TW9kdWxlRGF0YSA9IHt9O1xudmFyIGluc3RhbGxlZE1vZHVsZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmM7XG5cbi8vIG1vZHVsZSBhbmQgcmVxdWlyZSBjcmVhdGlvblxudmFyIGN1cnJlbnRDaGlsZE1vZHVsZTtcbnZhciBjdXJyZW50UGFyZW50cyA9IFtdO1xuXG4vLyBzdGF0dXNcbnZhciByZWdpc3RlcmVkU3RhdHVzSGFuZGxlcnMgPSBbXTtcbnZhciBjdXJyZW50U3RhdHVzID0gXCJpZGxlXCI7XG5cbi8vIHdoaWxlIGRvd25sb2FkaW5nXG52YXIgYmxvY2tpbmdQcm9taXNlcyA9IDA7XG52YXIgYmxvY2tpbmdQcm9taXNlc1dhaXRpbmcgPSBbXTtcblxuLy8gVGhlIHVwZGF0ZSBpbmZvXG52YXIgY3VycmVudFVwZGF0ZUFwcGx5SGFuZGxlcnM7XG52YXIgcXVldWVkSW52YWxpZGF0ZWRNb2R1bGVzO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbl9fd2VicGFja19yZXF1aXJlX18uaG1yRCA9IGN1cnJlbnRNb2R1bGVEYXRhO1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmkucHVzaChmdW5jdGlvbiAob3B0aW9ucykge1xuXHR2YXIgbW9kdWxlID0gb3B0aW9ucy5tb2R1bGU7XG5cdHZhciByZXF1aXJlID0gY3JlYXRlUmVxdWlyZShvcHRpb25zLnJlcXVpcmUsIG9wdGlvbnMuaWQpO1xuXHRtb2R1bGUuaG90ID0gY3JlYXRlTW9kdWxlSG90T2JqZWN0KG9wdGlvbnMuaWQsIG1vZHVsZSk7XG5cdG1vZHVsZS5wYXJlbnRzID0gY3VycmVudFBhcmVudHM7XG5cdG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRjdXJyZW50UGFyZW50cyA9IFtdO1xuXHRvcHRpb25zLnJlcXVpcmUgPSByZXF1aXJlO1xufSk7XG5cbl9fd2VicGFja19yZXF1aXJlX18uaG1yQyA9IHt9O1xuX193ZWJwYWNrX3JlcXVpcmVfXy5obXJJID0ge307XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlcXVpcmUocmVxdWlyZSwgbW9kdWxlSWQpIHtcblx0dmFyIG1lID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XG5cdGlmICghbWUpIHJldHVybiByZXF1aXJlO1xuXHR2YXIgZm4gPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuXHRcdGlmIChtZS5ob3QuYWN0aXZlKSB7XG5cdFx0XHRpZiAoaW5zdGFsbGVkTW9kdWxlc1tyZXF1ZXN0XSkge1xuXHRcdFx0XHR2YXIgcGFyZW50cyA9IGluc3RhbGxlZE1vZHVsZXNbcmVxdWVzdF0ucGFyZW50cztcblx0XHRcdFx0aWYgKHBhcmVudHMuaW5kZXhPZihtb2R1bGVJZCkgPT09IC0xKSB7XG5cdFx0XHRcdFx0cGFyZW50cy5wdXNoKG1vZHVsZUlkKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3VycmVudFBhcmVudHMgPSBbbW9kdWxlSWRdO1xuXHRcdFx0XHRjdXJyZW50Q2hpbGRNb2R1bGUgPSByZXF1ZXN0O1xuXHRcdFx0fVxuXHRcdFx0aWYgKG1lLmNoaWxkcmVuLmluZGV4T2YocmVxdWVzdCkgPT09IC0xKSB7XG5cdFx0XHRcdG1lLmNoaWxkcmVuLnB1c2gocmVxdWVzdCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnNvbGUud2Fybihcblx0XHRcdFx0XCJbSE1SXSB1bmV4cGVjdGVkIHJlcXVpcmUoXCIgK1xuXHRcdFx0XHRcdHJlcXVlc3QgK1xuXHRcdFx0XHRcdFwiKSBmcm9tIGRpc3Bvc2VkIG1vZHVsZSBcIiArXG5cdFx0XHRcdFx0bW9kdWxlSWRcblx0XHRcdCk7XG5cdFx0XHRjdXJyZW50UGFyZW50cyA9IFtdO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVxdWlyZShyZXF1ZXN0KTtcblx0fTtcblx0dmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIHJlcXVpcmVbbmFtZV07XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0cmVxdWlyZVtuYW1lXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH07XG5cdH07XG5cdGZvciAodmFyIG5hbWUgaW4gcmVxdWlyZSkge1xuXHRcdGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVxdWlyZSwgbmFtZSkgJiYgbmFtZSAhPT0gXCJlXCIpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgbmFtZSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKG5hbWUpKTtcblx0XHR9XG5cdH1cblx0Zm4uZSA9IGZ1bmN0aW9uIChjaHVua0lkKSB7XG5cdFx0cmV0dXJuIHRyYWNrQmxvY2tpbmdQcm9taXNlKHJlcXVpcmUuZShjaHVua0lkKSk7XG5cdH07XG5cdHJldHVybiBmbjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTW9kdWxlSG90T2JqZWN0KG1vZHVsZUlkLCBtZSkge1xuXHR2YXIgX21haW4gPSBjdXJyZW50Q2hpbGRNb2R1bGUgIT09IG1vZHVsZUlkO1xuXHR2YXIgaG90ID0ge1xuXHRcdC8vIHByaXZhdGUgc3R1ZmZcblx0XHRfYWNjZXB0ZWREZXBlbmRlbmNpZXM6IHt9LFxuXHRcdF9hY2NlcHRlZEVycm9ySGFuZGxlcnM6IHt9LFxuXHRcdF9kZWNsaW5lZERlcGVuZGVuY2llczoge30sXG5cdFx0X3NlbGZBY2NlcHRlZDogZmFsc2UsXG5cdFx0X3NlbGZEZWNsaW5lZDogZmFsc2UsXG5cdFx0X3NlbGZJbnZhbGlkYXRlZDogZmFsc2UsXG5cdFx0X2Rpc3Bvc2VIYW5kbGVyczogW10sXG5cdFx0X21haW46IF9tYWluLFxuXHRcdF9yZXF1aXJlU2VsZjogZnVuY3Rpb24gKCkge1xuXHRcdFx0Y3VycmVudFBhcmVudHMgPSBtZS5wYXJlbnRzLnNsaWNlKCk7XG5cdFx0XHRjdXJyZW50Q2hpbGRNb2R1bGUgPSBfbWFpbiA/IHVuZGVmaW5lZCA6IG1vZHVsZUlkO1xuXHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCk7XG5cdFx0fSxcblxuXHRcdC8vIE1vZHVsZSBBUElcblx0XHRhY3RpdmU6IHRydWUsXG5cdFx0YWNjZXB0OiBmdW5jdGlvbiAoZGVwLCBjYWxsYmFjaywgZXJyb3JIYW5kbGVyKSB7XG5cdFx0XHRpZiAoZGVwID09PSB1bmRlZmluZWQpIGhvdC5fc2VsZkFjY2VwdGVkID0gdHJ1ZTtcblx0XHRcdGVsc2UgaWYgKHR5cGVvZiBkZXAgPT09IFwiZnVuY3Rpb25cIikgaG90Ll9zZWxmQWNjZXB0ZWQgPSBkZXA7XG5cdFx0XHRlbHNlIGlmICh0eXBlb2YgZGVwID09PSBcIm9iamVjdFwiICYmIGRlcCAhPT0gbnVsbCkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRlcC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbZGVwW2ldXSA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHRcdFx0XHRcdGhvdC5fYWNjZXB0ZWRFcnJvckhhbmRsZXJzW2RlcFtpXV0gPSBlcnJvckhhbmRsZXI7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbZGVwXSA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHRcdFx0XHRob3QuX2FjY2VwdGVkRXJyb3JIYW5kbGVyc1tkZXBdID0gZXJyb3JIYW5kbGVyO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZGVjbGluZTogZnVuY3Rpb24gKGRlcCkge1xuXHRcdFx0aWYgKGRlcCA9PT0gdW5kZWZpbmVkKSBob3QuX3NlbGZEZWNsaW5lZCA9IHRydWU7XG5cdFx0XHRlbHNlIGlmICh0eXBlb2YgZGVwID09PSBcIm9iamVjdFwiICYmIGRlcCAhPT0gbnVsbClcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkZXAubGVuZ3RoOyBpKyspXG5cdFx0XHRcdFx0aG90Ll9kZWNsaW5lZERlcGVuZGVuY2llc1tkZXBbaV1dID0gdHJ1ZTtcblx0XHRcdGVsc2UgaG90Ll9kZWNsaW5lZERlcGVuZGVuY2llc1tkZXBdID0gdHJ1ZTtcblx0XHR9LFxuXHRcdGRpc3Bvc2U6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHRcdFx0aG90Ll9kaXNwb3NlSGFuZGxlcnMucHVzaChjYWxsYmFjayk7XG5cdFx0fSxcblx0XHRhZGREaXNwb3NlSGFuZGxlcjogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdFx0XHRob3QuX2Rpc3Bvc2VIYW5kbGVycy5wdXNoKGNhbGxiYWNrKTtcblx0XHR9LFxuXHRcdHJlbW92ZURpc3Bvc2VIYW5kbGVyOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0XHRcdHZhciBpZHggPSBob3QuX2Rpc3Bvc2VIYW5kbGVycy5pbmRleE9mKGNhbGxiYWNrKTtcblx0XHRcdGlmIChpZHggPj0gMCkgaG90Ll9kaXNwb3NlSGFuZGxlcnMuc3BsaWNlKGlkeCwgMSk7XG5cdFx0fSxcblx0XHRpbnZhbGlkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLl9zZWxmSW52YWxpZGF0ZWQgPSB0cnVlO1xuXHRcdFx0c3dpdGNoIChjdXJyZW50U3RhdHVzKSB7XG5cdFx0XHRcdGNhc2UgXCJpZGxlXCI6XG5cdFx0XHRcdFx0Y3VycmVudFVwZGF0ZUFwcGx5SGFuZGxlcnMgPSBbXTtcblx0XHRcdFx0XHRPYmplY3Qua2V5cyhfX3dlYnBhY2tfcmVxdWlyZV9fLmhtckkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5obXJJW2tleV0oXG5cdFx0XHRcdFx0XHRcdG1vZHVsZUlkLFxuXHRcdFx0XHRcdFx0XHRjdXJyZW50VXBkYXRlQXBwbHlIYW5kbGVyc1xuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRzZXRTdGF0dXMoXCJyZWFkeVwiKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcInJlYWR5XCI6XG5cdFx0XHRcdFx0T2JqZWN0LmtleXMoX193ZWJwYWNrX3JlcXVpcmVfXy5obXJJKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18uaG1ySVtrZXldKFxuXHRcdFx0XHRcdFx0XHRtb2R1bGVJZCxcblx0XHRcdFx0XHRcdFx0Y3VycmVudFVwZGF0ZUFwcGx5SGFuZGxlcnNcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJwcmVwYXJlXCI6XG5cdFx0XHRcdGNhc2UgXCJjaGVja1wiOlxuXHRcdFx0XHRjYXNlIFwiZGlzcG9zZVwiOlxuXHRcdFx0XHRjYXNlIFwiYXBwbHlcIjpcblx0XHRcdFx0XHQocXVldWVkSW52YWxpZGF0ZWRNb2R1bGVzID0gcXVldWVkSW52YWxpZGF0ZWRNb2R1bGVzIHx8IFtdKS5wdXNoKFxuXHRcdFx0XHRcdFx0bW9kdWxlSWRcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdC8vIGlnbm9yZSByZXF1ZXN0cyBpbiBlcnJvciBzdGF0ZXNcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gTWFuYWdlbWVudCBBUElcblx0XHRjaGVjazogaG90Q2hlY2ssXG5cdFx0YXBwbHk6IGhvdEFwcGx5LFxuXHRcdHN0YXR1czogZnVuY3Rpb24gKGwpIHtcblx0XHRcdGlmICghbCkgcmV0dXJuIGN1cnJlbnRTdGF0dXM7XG5cdFx0XHRyZWdpc3RlcmVkU3RhdHVzSGFuZGxlcnMucHVzaChsKTtcblx0XHR9LFxuXHRcdGFkZFN0YXR1c0hhbmRsZXI6IGZ1bmN0aW9uIChsKSB7XG5cdFx0XHRyZWdpc3RlcmVkU3RhdHVzSGFuZGxlcnMucHVzaChsKTtcblx0XHR9LFxuXHRcdHJlbW92ZVN0YXR1c0hhbmRsZXI6IGZ1bmN0aW9uIChsKSB7XG5cdFx0XHR2YXIgaWR4ID0gcmVnaXN0ZXJlZFN0YXR1c0hhbmRsZXJzLmluZGV4T2YobCk7XG5cdFx0XHRpZiAoaWR4ID49IDApIHJlZ2lzdGVyZWRTdGF0dXNIYW5kbGVycy5zcGxpY2UoaWR4LCAxKTtcblx0XHR9LFxuXG5cdFx0Ly9pbmhlcml0IGZyb20gcHJldmlvdXMgZGlzcG9zZSBjYWxsXG5cdFx0ZGF0YTogY3VycmVudE1vZHVsZURhdGFbbW9kdWxlSWRdXG5cdH07XG5cdGN1cnJlbnRDaGlsZE1vZHVsZSA9IHVuZGVmaW5lZDtcblx0cmV0dXJuIGhvdDtcbn1cblxuZnVuY3Rpb24gc2V0U3RhdHVzKG5ld1N0YXR1cykge1xuXHRjdXJyZW50U3RhdHVzID0gbmV3U3RhdHVzO1xuXHR2YXIgcmVzdWx0cyA9IFtdO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcmVnaXN0ZXJlZFN0YXR1c0hhbmRsZXJzLmxlbmd0aDsgaSsrKVxuXHRcdHJlc3VsdHNbaV0gPSByZWdpc3RlcmVkU3RhdHVzSGFuZGxlcnNbaV0uY2FsbChudWxsLCBuZXdTdGF0dXMpO1xuXG5cdHJldHVybiBQcm9taXNlLmFsbChyZXN1bHRzKTtcbn1cblxuZnVuY3Rpb24gdW5ibG9jaygpIHtcblx0aWYgKC0tYmxvY2tpbmdQcm9taXNlcyA9PT0gMCkge1xuXHRcdHNldFN0YXR1cyhcInJlYWR5XCIpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKGJsb2NraW5nUHJvbWlzZXMgPT09IDApIHtcblx0XHRcdFx0dmFyIGxpc3QgPSBibG9ja2luZ1Byb21pc2VzV2FpdGluZztcblx0XHRcdFx0YmxvY2tpbmdQcm9taXNlc1dhaXRpbmcgPSBbXTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0bGlzdFtpXSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdHJhY2tCbG9ja2luZ1Byb21pc2UocHJvbWlzZSkge1xuXHRzd2l0Y2ggKGN1cnJlbnRTdGF0dXMpIHtcblx0XHRjYXNlIFwicmVhZHlcIjpcblx0XHRcdHNldFN0YXR1cyhcInByZXBhcmVcIik7XG5cdFx0LyogZmFsbHRocm91Z2ggKi9cblx0XHRjYXNlIFwicHJlcGFyZVwiOlxuXHRcdFx0YmxvY2tpbmdQcm9taXNlcysrO1xuXHRcdFx0cHJvbWlzZS50aGVuKHVuYmxvY2ssIHVuYmxvY2spO1xuXHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHdhaXRGb3JCbG9ja2luZ1Byb21pc2VzKGZuKSB7XG5cdGlmIChibG9ja2luZ1Byb21pc2VzID09PSAwKSByZXR1cm4gZm4oKTtcblx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cdFx0YmxvY2tpbmdQcm9taXNlc1dhaXRpbmcucHVzaChmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXNvbHZlKGZuKCkpO1xuXHRcdH0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gaG90Q2hlY2soYXBwbHlPblVwZGF0ZSkge1xuXHRpZiAoY3VycmVudFN0YXR1cyAhPT0gXCJpZGxlXCIpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJjaGVjaygpIGlzIG9ubHkgYWxsb3dlZCBpbiBpZGxlIHN0YXR1c1wiKTtcblx0fVxuXHRyZXR1cm4gc2V0U3RhdHVzKFwiY2hlY2tcIilcblx0XHQudGhlbihfX3dlYnBhY2tfcmVxdWlyZV9fLmhtck0pXG5cdFx0LnRoZW4oZnVuY3Rpb24gKHVwZGF0ZSkge1xuXHRcdFx0aWYgKCF1cGRhdGUpIHtcblx0XHRcdFx0cmV0dXJuIHNldFN0YXR1cyhhcHBseUludmFsaWRhdGVkTW9kdWxlcygpID8gXCJyZWFkeVwiIDogXCJpZGxlXCIpLnRoZW4oXG5cdFx0XHRcdFx0ZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2V0U3RhdHVzKFwicHJlcGFyZVwiKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIHVwZGF0ZWRNb2R1bGVzID0gW107XG5cdFx0XHRcdGN1cnJlbnRVcGRhdGVBcHBseUhhbmRsZXJzID0gW107XG5cblx0XHRcdFx0cmV0dXJuIFByb21pc2UuYWxsKFxuXHRcdFx0XHRcdE9iamVjdC5rZXlzKF9fd2VicGFja19yZXF1aXJlX18uaG1yQykucmVkdWNlKGZ1bmN0aW9uIChcblx0XHRcdFx0XHRcdHByb21pc2VzLFxuXHRcdFx0XHRcdFx0a2V5XG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmhtckNba2V5XShcblx0XHRcdFx0XHRcdFx0dXBkYXRlLmMsXG5cdFx0XHRcdFx0XHRcdHVwZGF0ZS5yLFxuXHRcdFx0XHRcdFx0XHR1cGRhdGUubSxcblx0XHRcdFx0XHRcdFx0cHJvbWlzZXMsXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnRVcGRhdGVBcHBseUhhbmRsZXJzLFxuXHRcdFx0XHRcdFx0XHR1cGRhdGVkTW9kdWxlc1xuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHJldHVybiBwcm9taXNlcztcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFtdKVxuXHRcdFx0XHQpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHJldHVybiB3YWl0Rm9yQmxvY2tpbmdQcm9taXNlcyhmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRpZiAoYXBwbHlPblVwZGF0ZSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gaW50ZXJuYWxBcHBseShhcHBseU9uVXBkYXRlKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBzZXRTdGF0dXMoXCJyZWFkeVwiKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdXBkYXRlZE1vZHVsZXM7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdH0pO1xufVxuXG5mdW5jdGlvbiBob3RBcHBseShvcHRpb25zKSB7XG5cdGlmIChjdXJyZW50U3RhdHVzICE9PSBcInJlYWR5XCIpIHtcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFwiYXBwbHkoKSBpcyBvbmx5IGFsbG93ZWQgaW4gcmVhZHkgc3RhdHVzIChzdGF0ZTogXCIgK1xuXHRcdFx0XHRcdGN1cnJlbnRTdGF0dXMgK1xuXHRcdFx0XHRcdFwiKVwiXG5cdFx0XHQpO1xuXHRcdH0pO1xuXHR9XG5cdHJldHVybiBpbnRlcm5hbEFwcGx5KG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBpbnRlcm5hbEFwcGx5KG9wdGlvbnMpIHtcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0YXBwbHlJbnZhbGlkYXRlZE1vZHVsZXMoKTtcblxuXHR2YXIgcmVzdWx0cyA9IGN1cnJlbnRVcGRhdGVBcHBseUhhbmRsZXJzLm1hcChmdW5jdGlvbiAoaGFuZGxlcikge1xuXHRcdHJldHVybiBoYW5kbGVyKG9wdGlvbnMpO1xuXHR9KTtcblx0Y3VycmVudFVwZGF0ZUFwcGx5SGFuZGxlcnMgPSB1bmRlZmluZWQ7XG5cblx0dmFyIGVycm9ycyA9IHJlc3VsdHNcblx0XHQubWFwKGZ1bmN0aW9uIChyKSB7XG5cdFx0XHRyZXR1cm4gci5lcnJvcjtcblx0XHR9KVxuXHRcdC5maWx0ZXIoQm9vbGVhbik7XG5cblx0aWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG5cdFx0cmV0dXJuIHNldFN0YXR1cyhcImFib3J0XCIpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhyb3cgZXJyb3JzWzBdO1xuXHRcdH0pO1xuXHR9XG5cblx0Ly8gTm93IGluIFwiZGlzcG9zZVwiIHBoYXNlXG5cdHZhciBkaXNwb3NlUHJvbWlzZSA9IHNldFN0YXR1cyhcImRpc3Bvc2VcIik7XG5cblx0cmVzdWx0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0XHRpZiAocmVzdWx0LmRpc3Bvc2UpIHJlc3VsdC5kaXNwb3NlKCk7XG5cdH0pO1xuXG5cdC8vIE5vdyBpbiBcImFwcGx5XCIgcGhhc2Vcblx0dmFyIGFwcGx5UHJvbWlzZSA9IHNldFN0YXR1cyhcImFwcGx5XCIpO1xuXG5cdHZhciBlcnJvcjtcblx0dmFyIHJlcG9ydEVycm9yID0gZnVuY3Rpb24gKGVycikge1xuXHRcdGlmICghZXJyb3IpIGVycm9yID0gZXJyO1xuXHR9O1xuXG5cdHZhciBvdXRkYXRlZE1vZHVsZXMgPSBbXTtcblx0cmVzdWx0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0XHRpZiAocmVzdWx0LmFwcGx5KSB7XG5cdFx0XHR2YXIgbW9kdWxlcyA9IHJlc3VsdC5hcHBseShyZXBvcnRFcnJvcik7XG5cdFx0XHRpZiAobW9kdWxlcykge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRvdXRkYXRlZE1vZHVsZXMucHVzaChtb2R1bGVzW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIFByb21pc2UuYWxsKFtkaXNwb3NlUHJvbWlzZSwgYXBwbHlQcm9taXNlXSkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gaGFuZGxlIGVycm9ycyBpbiBhY2NlcHQgaGFuZGxlcnMgYW5kIHNlbGYgYWNjZXB0ZWQgbW9kdWxlIGxvYWRcblx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdHJldHVybiBzZXRTdGF0dXMoXCJmYWlsXCIpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmIChxdWV1ZWRJbnZhbGlkYXRlZE1vZHVsZXMpIHtcblx0XHRcdHJldHVybiBpbnRlcm5hbEFwcGx5KG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKGxpc3QpIHtcblx0XHRcdFx0b3V0ZGF0ZWRNb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKG1vZHVsZUlkKSB7XG5cdFx0XHRcdFx0aWYgKGxpc3QuaW5kZXhPZihtb2R1bGVJZCkgPCAwKSBsaXN0LnB1c2gobW9kdWxlSWQpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuIGxpc3Q7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc2V0U3RhdHVzKFwiaWRsZVwiKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBvdXRkYXRlZE1vZHVsZXM7XG5cdFx0fSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBhcHBseUludmFsaWRhdGVkTW9kdWxlcygpIHtcblx0aWYgKHF1ZXVlZEludmFsaWRhdGVkTW9kdWxlcykge1xuXHRcdGlmICghY3VycmVudFVwZGF0ZUFwcGx5SGFuZGxlcnMpIGN1cnJlbnRVcGRhdGVBcHBseUhhbmRsZXJzID0gW107XG5cdFx0T2JqZWN0LmtleXMoX193ZWJwYWNrX3JlcXVpcmVfXy5obXJJKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdHF1ZXVlZEludmFsaWRhdGVkTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2R1bGVJZCkge1xuXHRcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmhtcklba2V5XShcblx0XHRcdFx0XHRtb2R1bGVJZCxcblx0XHRcdFx0XHRjdXJyZW50VXBkYXRlQXBwbHlIYW5kbGVyc1xuXHRcdFx0XHQpO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdFx0cXVldWVkSW52YWxpZGF0ZWRNb2R1bGVzID0gdW5kZWZpbmVkO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59IiwidmFyIHNjcmlwdFVybDtcbmlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLmcuaW1wb3J0U2NyaXB0cykgc2NyaXB0VXJsID0gX193ZWJwYWNrX3JlcXVpcmVfXy5nLmxvY2F0aW9uICsgXCJcIjtcbnZhciBkb2N1bWVudCA9IF9fd2VicGFja19yZXF1aXJlX18uZy5kb2N1bWVudDtcbmlmICghc2NyaXB0VXJsICYmIGRvY3VtZW50KSB7XG5cdGlmIChkb2N1bWVudC5jdXJyZW50U2NyaXB0KVxuXHRcdHNjcmlwdFVybCA9IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjXG5cdGlmICghc2NyaXB0VXJsKSB7XG5cdFx0dmFyIHNjcmlwdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTtcblx0XHRpZihzY3JpcHRzLmxlbmd0aCkgc2NyaXB0VXJsID0gc2NyaXB0c1tzY3JpcHRzLmxlbmd0aCAtIDFdLnNyY1xuXHR9XG59XG4vLyBXaGVuIHN1cHBvcnRpbmcgYnJvd3NlcnMgd2hlcmUgYW4gYXV0b21hdGljIHB1YmxpY1BhdGggaXMgbm90IHN1cHBvcnRlZCB5b3UgbXVzdCBzcGVjaWZ5IGFuIG91dHB1dC5wdWJsaWNQYXRoIG1hbnVhbGx5IHZpYSBjb25maWd1cmF0aW9uXG4vLyBvciBwYXNzIGFuIGVtcHR5IHN0cmluZyAoXCJcIikgYW5kIHNldCB0aGUgX193ZWJwYWNrX3B1YmxpY19wYXRoX18gdmFyaWFibGUgZnJvbSB5b3VyIGNvZGUgdG8gdXNlIHlvdXIgb3duIGxvZ2ljLlxuaWYgKCFzY3JpcHRVcmwpIHRocm93IG5ldyBFcnJvcihcIkF1dG9tYXRpYyBwdWJsaWNQYXRoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyXCIpO1xuc2NyaXB0VXJsID0gc2NyaXB0VXJsLnJlcGxhY2UoLyMuKiQvLCBcIlwiKS5yZXBsYWNlKC9cXD8uKiQvLCBcIlwiKS5yZXBsYWNlKC9cXC9bXlxcL10rJC8sIFwiL1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18ucCA9IHNjcmlwdFVybDsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmIgPSBkb2N1bWVudC5iYXNlVVJJIHx8IHNlbGYubG9jYXRpb24uaHJlZjtcblxuLy8gb2JqZWN0IHRvIHN0b3JlIGxvYWRlZCBhbmQgbG9hZGluZyBjaHVua3Ncbi8vIHVuZGVmaW5lZCA9IGNodW5rIG5vdCBsb2FkZWQsIG51bGwgPSBjaHVuayBwcmVsb2FkZWQvcHJlZmV0Y2hlZFxuLy8gW3Jlc29sdmUsIHJlamVjdCwgUHJvbWlzZV0gPSBjaHVuayBsb2FkaW5nLCAwID0gY2h1bmsgbG9hZGVkXG52YXIgaW5zdGFsbGVkQ2h1bmtzID0gX193ZWJwYWNrX3JlcXVpcmVfXy5obXJTX2pzb25wID0gX193ZWJwYWNrX3JlcXVpcmVfXy5obXJTX2pzb25wIHx8IHtcblx0XCJtYWluXCI6IDBcbn07XG5cbl9fd2VicGFja19yZXF1aXJlX18uZi5qID0gZnVuY3Rpb24oY2h1bmtJZCwgcHJvbWlzZXMpIHtcblx0XHQvLyBKU09OUCBjaHVuayBsb2FkaW5nIGZvciBqYXZhc2NyaXB0XG5cdFx0dmFyIGluc3RhbGxlZENodW5rRGF0YSA9IF9fd2VicGFja19yZXF1aXJlX18ubyhpbnN0YWxsZWRDaHVua3MsIGNodW5rSWQpID8gaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdIDogdW5kZWZpbmVkO1xuXHRcdGlmKGluc3RhbGxlZENodW5rRGF0YSAhPT0gMCkgeyAvLyAwIG1lYW5zIFwiYWxyZWFkeSBpbnN0YWxsZWRcIi5cblxuXHRcdFx0Ly8gYSBQcm9taXNlIG1lYW5zIFwiY3VycmVudGx5IGxvYWRpbmdcIi5cblx0XHRcdGlmKGluc3RhbGxlZENodW5rRGF0YSkge1xuXHRcdFx0XHRwcm9taXNlcy5wdXNoKGluc3RhbGxlZENodW5rRGF0YVsyXSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZih0cnVlKSB7IC8vIGFsbCBjaHVua3MgaGF2ZSBKU1xuXHRcdFx0XHRcdC8vIHNldHVwIFByb21pc2UgaW4gY2h1bmsgY2FjaGVcblx0XHRcdFx0XHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkgeyBpbnN0YWxsZWRDaHVua0RhdGEgPSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gPSBbcmVzb2x2ZSwgcmVqZWN0XTsgfSk7XG5cdFx0XHRcdFx0cHJvbWlzZXMucHVzaChpbnN0YWxsZWRDaHVua0RhdGFbMl0gPSBwcm9taXNlKTtcblxuXHRcdFx0XHRcdC8vIHN0YXJ0IGNodW5rIGxvYWRpbmdcblx0XHRcdFx0XHR2YXIgdXJsID0gX193ZWJwYWNrX3JlcXVpcmVfXy5wICsgX193ZWJwYWNrX3JlcXVpcmVfXy51KGNodW5rSWQpO1xuXHRcdFx0XHRcdC8vIGNyZWF0ZSBlcnJvciBiZWZvcmUgc3RhY2sgdW53b3VuZCB0byBnZXQgdXNlZnVsIHN0YWNrdHJhY2UgbGF0ZXJcblx0XHRcdFx0XHR2YXIgZXJyb3IgPSBuZXcgRXJyb3IoKTtcblx0XHRcdFx0XHR2YXIgbG9hZGluZ0VuZGVkID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0XHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhpbnN0YWxsZWRDaHVua3MsIGNodW5rSWQpKSB7XG5cdFx0XHRcdFx0XHRcdGluc3RhbGxlZENodW5rRGF0YSA9IGluc3RhbGxlZENodW5rc1tjaHVua0lkXTtcblx0XHRcdFx0XHRcdFx0aWYoaW5zdGFsbGVkQ2h1bmtEYXRhICE9PSAwKSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdGlmKGluc3RhbGxlZENodW5rRGF0YSkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBlcnJvclR5cGUgPSBldmVudCAmJiAoZXZlbnQudHlwZSA9PT0gJ2xvYWQnID8gJ21pc3NpbmcnIDogZXZlbnQudHlwZSk7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJlYWxTcmMgPSBldmVudCAmJiBldmVudC50YXJnZXQgJiYgZXZlbnQudGFyZ2V0LnNyYztcblx0XHRcdFx0XHRcdFx0XHRlcnJvci5tZXNzYWdlID0gJ0xvYWRpbmcgY2h1bmsgJyArIGNodW5rSWQgKyAnIGZhaWxlZC5cXG4oJyArIGVycm9yVHlwZSArICc6ICcgKyByZWFsU3JjICsgJyknO1xuXHRcdFx0XHRcdFx0XHRcdGVycm9yLm5hbWUgPSAnQ2h1bmtMb2FkRXJyb3InO1xuXHRcdFx0XHRcdFx0XHRcdGVycm9yLnR5cGUgPSBlcnJvclR5cGU7XG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3IucmVxdWVzdCA9IHJlYWxTcmM7XG5cdFx0XHRcdFx0XHRcdFx0aW5zdGFsbGVkQ2h1bmtEYXRhWzFdKGVycm9yKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5sKHVybCwgbG9hZGluZ0VuZGVkLCBcImNodW5rLVwiICsgY2h1bmtJZCwgY2h1bmtJZCk7XG5cdFx0XHRcdH0gZWxzZSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gPSAwO1xuXHRcdFx0fVxuXHRcdH1cbn07XG5cbi8vIG5vIHByZWZldGNoaW5nXG5cbi8vIG5vIHByZWxvYWRlZFxuXG52YXIgY3VycmVudFVwZGF0ZWRNb2R1bGVzTGlzdDtcbnZhciB3YWl0aW5nVXBkYXRlUmVzb2x2ZXMgPSB7fTtcbmZ1bmN0aW9uIGxvYWRVcGRhdGVDaHVuayhjaHVua0lkLCB1cGRhdGVkTW9kdWxlc0xpc3QpIHtcblx0Y3VycmVudFVwZGF0ZWRNb2R1bGVzTGlzdCA9IHVwZGF0ZWRNb2R1bGVzTGlzdDtcblx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdHdhaXRpbmdVcGRhdGVSZXNvbHZlc1tjaHVua0lkXSA9IHJlc29sdmU7XG5cdFx0Ly8gc3RhcnQgdXBkYXRlIGNodW5rIGxvYWRpbmdcblx0XHR2YXIgdXJsID0gX193ZWJwYWNrX3JlcXVpcmVfXy5wICsgX193ZWJwYWNrX3JlcXVpcmVfXy5odShjaHVua0lkKTtcblx0XHQvLyBjcmVhdGUgZXJyb3IgYmVmb3JlIHN0YWNrIHVud291bmQgdG8gZ2V0IHVzZWZ1bCBzdGFja3RyYWNlIGxhdGVyXG5cdFx0dmFyIGVycm9yID0gbmV3IEVycm9yKCk7XG5cdFx0dmFyIGxvYWRpbmdFbmRlZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRpZih3YWl0aW5nVXBkYXRlUmVzb2x2ZXNbY2h1bmtJZF0pIHtcblx0XHRcdFx0d2FpdGluZ1VwZGF0ZVJlc29sdmVzW2NodW5rSWRdID0gdW5kZWZpbmVkXG5cdFx0XHRcdHZhciBlcnJvclR5cGUgPSBldmVudCAmJiAoZXZlbnQudHlwZSA9PT0gJ2xvYWQnID8gJ21pc3NpbmcnIDogZXZlbnQudHlwZSk7XG5cdFx0XHRcdHZhciByZWFsU3JjID0gZXZlbnQgJiYgZXZlbnQudGFyZ2V0ICYmIGV2ZW50LnRhcmdldC5zcmM7XG5cdFx0XHRcdGVycm9yLm1lc3NhZ2UgPSAnTG9hZGluZyBob3QgdXBkYXRlIGNodW5rICcgKyBjaHVua0lkICsgJyBmYWlsZWQuXFxuKCcgKyBlcnJvclR5cGUgKyAnOiAnICsgcmVhbFNyYyArICcpJztcblx0XHRcdFx0ZXJyb3IubmFtZSA9ICdDaHVua0xvYWRFcnJvcic7XG5cdFx0XHRcdGVycm9yLnR5cGUgPSBlcnJvclR5cGU7XG5cdFx0XHRcdGVycm9yLnJlcXVlc3QgPSByZWFsU3JjO1xuXHRcdFx0XHRyZWplY3QoZXJyb3IpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5sKHVybCwgbG9hZGluZ0VuZGVkKTtcblx0fSk7XG59XG5cbnNlbGZbXCJ3ZWJwYWNrSG90VXBkYXRlY2FwaV9zaW1wbGVfZGVtb1wiXSA9IGZ1bmN0aW9uKGNodW5rSWQsIG1vcmVNb2R1bGVzLCBydW50aW1lKSB7XG5cdGZvcih2YXIgbW9kdWxlSWQgaW4gbW9yZU1vZHVsZXMpIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8obW9yZU1vZHVsZXMsIG1vZHVsZUlkKSkge1xuXHRcdFx0Y3VycmVudFVwZGF0ZVttb2R1bGVJZF0gPSBtb3JlTW9kdWxlc1ttb2R1bGVJZF07XG5cdFx0XHRpZihjdXJyZW50VXBkYXRlZE1vZHVsZXNMaXN0KSBjdXJyZW50VXBkYXRlZE1vZHVsZXNMaXN0LnB1c2gobW9kdWxlSWQpO1xuXHRcdH1cblx0fVxuXHRpZihydW50aW1lKSBjdXJyZW50VXBkYXRlUnVudGltZS5wdXNoKHJ1bnRpbWUpO1xuXHRpZih3YWl0aW5nVXBkYXRlUmVzb2x2ZXNbY2h1bmtJZF0pIHtcblx0XHR3YWl0aW5nVXBkYXRlUmVzb2x2ZXNbY2h1bmtJZF0oKTtcblx0XHR3YWl0aW5nVXBkYXRlUmVzb2x2ZXNbY2h1bmtJZF0gPSB1bmRlZmluZWQ7XG5cdH1cbn07XG5cbnZhciBjdXJyZW50VXBkYXRlQ2h1bmtzO1xudmFyIGN1cnJlbnRVcGRhdGU7XG52YXIgY3VycmVudFVwZGF0ZVJlbW92ZWRDaHVua3M7XG52YXIgY3VycmVudFVwZGF0ZVJ1bnRpbWU7XG5mdW5jdGlvbiBhcHBseUhhbmRsZXIob3B0aW9ucykge1xuXHRpZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5mKSBkZWxldGUgX193ZWJwYWNrX3JlcXVpcmVfXy5mLmpzb25wSG1yO1xuXHRjdXJyZW50VXBkYXRlQ2h1bmtzID0gdW5kZWZpbmVkO1xuXHRmdW5jdGlvbiBnZXRBZmZlY3RlZE1vZHVsZUVmZmVjdHModXBkYXRlTW9kdWxlSWQpIHtcblx0XHR2YXIgb3V0ZGF0ZWRNb2R1bGVzID0gW3VwZGF0ZU1vZHVsZUlkXTtcblx0XHR2YXIgb3V0ZGF0ZWREZXBlbmRlbmNpZXMgPSB7fTtcblxuXHRcdHZhciBxdWV1ZSA9IG91dGRhdGVkTW9kdWxlcy5tYXAoZnVuY3Rpb24gKGlkKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRjaGFpbjogW2lkXSxcblx0XHRcdFx0aWQ6IGlkXG5cdFx0XHR9O1xuXHRcdH0pO1xuXHRcdHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG5cdFx0XHR2YXIgcXVldWVJdGVtID0gcXVldWUucG9wKCk7XG5cdFx0XHR2YXIgbW9kdWxlSWQgPSBxdWV1ZUl0ZW0uaWQ7XG5cdFx0XHR2YXIgY2hhaW4gPSBxdWV1ZUl0ZW0uY2hhaW47XG5cdFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXy5jW21vZHVsZUlkXTtcblx0XHRcdGlmIChcblx0XHRcdFx0IW1vZHVsZSB8fFxuXHRcdFx0XHQobW9kdWxlLmhvdC5fc2VsZkFjY2VwdGVkICYmICFtb2R1bGUuaG90Ll9zZWxmSW52YWxpZGF0ZWQpXG5cdFx0XHQpXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0aWYgKG1vZHVsZS5ob3QuX3NlbGZEZWNsaW5lZCkge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHR5cGU6IFwic2VsZi1kZWNsaW5lZFwiLFxuXHRcdFx0XHRcdGNoYWluOiBjaGFpbixcblx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWRcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGlmIChtb2R1bGUuaG90Ll9tYWluKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dHlwZTogXCJ1bmFjY2VwdGVkXCIsXG5cdFx0XHRcdFx0Y2hhaW46IGNoYWluLFxuXHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZFxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtb2R1bGUucGFyZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgcGFyZW50SWQgPSBtb2R1bGUucGFyZW50c1tpXTtcblx0XHRcdFx0dmFyIHBhcmVudCA9IF9fd2VicGFja19yZXF1aXJlX18uY1twYXJlbnRJZF07XG5cdFx0XHRcdGlmICghcGFyZW50KSBjb250aW51ZTtcblx0XHRcdFx0aWYgKHBhcmVudC5ob3QuX2RlY2xpbmVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSkge1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHR0eXBlOiBcImRlY2xpbmVkXCIsXG5cdFx0XHRcdFx0XHRjaGFpbjogY2hhaW4uY29uY2F0KFtwYXJlbnRJZF0pLFxuXHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxuXHRcdFx0XHRcdFx0cGFyZW50SWQ6IHBhcmVudElkXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAob3V0ZGF0ZWRNb2R1bGVzLmluZGV4T2YocGFyZW50SWQpICE9PSAtMSkgY29udGludWU7XG5cdFx0XHRcdGlmIChwYXJlbnQuaG90Ll9hY2NlcHRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF0pIHtcblx0XHRcdFx0XHRpZiAoIW91dGRhdGVkRGVwZW5kZW5jaWVzW3BhcmVudElkXSlcblx0XHRcdFx0XHRcdG91dGRhdGVkRGVwZW5kZW5jaWVzW3BhcmVudElkXSA9IFtdO1xuXHRcdFx0XHRcdGFkZEFsbFRvU2V0KG91dGRhdGVkRGVwZW5kZW5jaWVzW3BhcmVudElkXSwgW21vZHVsZUlkXSk7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGVsZXRlIG91dGRhdGVkRGVwZW5kZW5jaWVzW3BhcmVudElkXTtcblx0XHRcdFx0b3V0ZGF0ZWRNb2R1bGVzLnB1c2gocGFyZW50SWQpO1xuXHRcdFx0XHRxdWV1ZS5wdXNoKHtcblx0XHRcdFx0XHRjaGFpbjogY2hhaW4uY29uY2F0KFtwYXJlbnRJZF0pLFxuXHRcdFx0XHRcdGlkOiBwYXJlbnRJZFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dHlwZTogXCJhY2NlcHRlZFwiLFxuXHRcdFx0bW9kdWxlSWQ6IHVwZGF0ZU1vZHVsZUlkLFxuXHRcdFx0b3V0ZGF0ZWRNb2R1bGVzOiBvdXRkYXRlZE1vZHVsZXMsXG5cdFx0XHRvdXRkYXRlZERlcGVuZGVuY2llczogb3V0ZGF0ZWREZXBlbmRlbmNpZXNcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gYWRkQWxsVG9TZXQoYSwgYikge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBiW2ldO1xuXHRcdFx0aWYgKGEuaW5kZXhPZihpdGVtKSA9PT0gLTEpIGEucHVzaChpdGVtKTtcblx0XHR9XG5cdH1cblxuXHQvLyBhdCBiZWdpbiBhbGwgdXBkYXRlcyBtb2R1bGVzIGFyZSBvdXRkYXRlZFxuXHQvLyB0aGUgXCJvdXRkYXRlZFwiIHN0YXR1cyBjYW4gcHJvcGFnYXRlIHRvIHBhcmVudHMgaWYgdGhleSBkb24ndCBhY2NlcHQgdGhlIGNoaWxkcmVuXG5cdHZhciBvdXRkYXRlZERlcGVuZGVuY2llcyA9IHt9O1xuXHR2YXIgb3V0ZGF0ZWRNb2R1bGVzID0gW107XG5cdHZhciBhcHBsaWVkVXBkYXRlID0ge307XG5cblx0dmFyIHdhcm5VbmV4cGVjdGVkUmVxdWlyZSA9IGZ1bmN0aW9uIHdhcm5VbmV4cGVjdGVkUmVxdWlyZShtb2R1bGUpIHtcblx0XHRjb25zb2xlLndhcm4oXG5cdFx0XHRcIltITVJdIHVuZXhwZWN0ZWQgcmVxdWlyZShcIiArIG1vZHVsZS5pZCArIFwiKSB0byBkaXNwb3NlZCBtb2R1bGVcIlxuXHRcdCk7XG5cdH07XG5cblx0Zm9yICh2YXIgbW9kdWxlSWQgaW4gY3VycmVudFVwZGF0ZSkge1xuXHRcdGlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLm8oY3VycmVudFVwZGF0ZSwgbW9kdWxlSWQpKSB7XG5cdFx0XHR2YXIgbmV3TW9kdWxlRmFjdG9yeSA9IGN1cnJlbnRVcGRhdGVbbW9kdWxlSWRdO1xuXHRcdFx0LyoqIEB0eXBlIHtUT0RPfSAqL1xuXHRcdFx0dmFyIHJlc3VsdDtcblx0XHRcdGlmIChuZXdNb2R1bGVGYWN0b3J5KSB7XG5cdFx0XHRcdHJlc3VsdCA9IGdldEFmZmVjdGVkTW9kdWxlRWZmZWN0cyhtb2R1bGVJZCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXN1bHQgPSB7XG5cdFx0XHRcdFx0dHlwZTogXCJkaXNwb3NlZFwiLFxuXHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZFxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0LyoqIEB0eXBlIHtFcnJvcnxmYWxzZX0gKi9cblx0XHRcdHZhciBhYm9ydEVycm9yID0gZmFsc2U7XG5cdFx0XHR2YXIgZG9BcHBseSA9IGZhbHNlO1xuXHRcdFx0dmFyIGRvRGlzcG9zZSA9IGZhbHNlO1xuXHRcdFx0dmFyIGNoYWluSW5mbyA9IFwiXCI7XG5cdFx0XHRpZiAocmVzdWx0LmNoYWluKSB7XG5cdFx0XHRcdGNoYWluSW5mbyA9IFwiXFxuVXBkYXRlIHByb3BhZ2F0aW9uOiBcIiArIHJlc3VsdC5jaGFpbi5qb2luKFwiIC0+IFwiKTtcblx0XHRcdH1cblx0XHRcdHN3aXRjaCAocmVzdWx0LnR5cGUpIHtcblx0XHRcdFx0Y2FzZSBcInNlbGYtZGVjbGluZWRcIjpcblx0XHRcdFx0XHRpZiAob3B0aW9ucy5vbkRlY2xpbmVkKSBvcHRpb25zLm9uRGVjbGluZWQocmVzdWx0KTtcblx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuaWdub3JlRGVjbGluZWQpXG5cdFx0XHRcdFx0XHRhYm9ydEVycm9yID0gbmV3IEVycm9yKFxuXHRcdFx0XHRcdFx0XHRcIkFib3J0ZWQgYmVjYXVzZSBvZiBzZWxmIGRlY2xpbmU6IFwiICtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHQubW9kdWxlSWQgK1xuXHRcdFx0XHRcdFx0XHRcdGNoYWluSW5mb1xuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImRlY2xpbmVkXCI6XG5cdFx0XHRcdFx0aWYgKG9wdGlvbnMub25EZWNsaW5lZCkgb3B0aW9ucy5vbkRlY2xpbmVkKHJlc3VsdCk7XG5cdFx0XHRcdFx0aWYgKCFvcHRpb25zLmlnbm9yZURlY2xpbmVkKVxuXHRcdFx0XHRcdFx0YWJvcnRFcnJvciA9IG5ldyBFcnJvcihcblx0XHRcdFx0XHRcdFx0XCJBYm9ydGVkIGJlY2F1c2Ugb2YgZGVjbGluZWQgZGVwZW5kZW5jeTogXCIgK1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdC5tb2R1bGVJZCArXG5cdFx0XHRcdFx0XHRcdFx0XCIgaW4gXCIgK1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdC5wYXJlbnRJZCArXG5cdFx0XHRcdFx0XHRcdFx0Y2hhaW5JbmZvXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwidW5hY2NlcHRlZFwiOlxuXHRcdFx0XHRcdGlmIChvcHRpb25zLm9uVW5hY2NlcHRlZCkgb3B0aW9ucy5vblVuYWNjZXB0ZWQocmVzdWx0KTtcblx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuaWdub3JlVW5hY2NlcHRlZClcblx0XHRcdFx0XHRcdGFib3J0RXJyb3IgPSBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0XHRcdFwiQWJvcnRlZCBiZWNhdXNlIFwiICsgbW9kdWxlSWQgKyBcIiBpcyBub3QgYWNjZXB0ZWRcIiArIGNoYWluSW5mb1xuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImFjY2VwdGVkXCI6XG5cdFx0XHRcdFx0aWYgKG9wdGlvbnMub25BY2NlcHRlZCkgb3B0aW9ucy5vbkFjY2VwdGVkKHJlc3VsdCk7XG5cdFx0XHRcdFx0ZG9BcHBseSA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJkaXNwb3NlZFwiOlxuXHRcdFx0XHRcdGlmIChvcHRpb25zLm9uRGlzcG9zZWQpIG9wdGlvbnMub25EaXNwb3NlZChyZXN1bHQpO1xuXHRcdFx0XHRcdGRvRGlzcG9zZSA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5leGNlcHRpb24gdHlwZSBcIiArIHJlc3VsdC50eXBlKTtcblx0XHRcdH1cblx0XHRcdGlmIChhYm9ydEVycm9yKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0ZXJyb3I6IGFib3J0RXJyb3Jcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGlmIChkb0FwcGx5KSB7XG5cdFx0XHRcdGFwcGxpZWRVcGRhdGVbbW9kdWxlSWRdID0gbmV3TW9kdWxlRmFjdG9yeTtcblx0XHRcdFx0YWRkQWxsVG9TZXQob3V0ZGF0ZWRNb2R1bGVzLCByZXN1bHQub3V0ZGF0ZWRNb2R1bGVzKTtcblx0XHRcdFx0Zm9yIChtb2R1bGVJZCBpbiByZXN1bHQub3V0ZGF0ZWREZXBlbmRlbmNpZXMpIHtcblx0XHRcdFx0XHRpZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5vKHJlc3VsdC5vdXRkYXRlZERlcGVuZGVuY2llcywgbW9kdWxlSWQpKSB7XG5cdFx0XHRcdFx0XHRpZiAoIW91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSlcblx0XHRcdFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdID0gW107XG5cdFx0XHRcdFx0XHRhZGRBbGxUb1NldChcblx0XHRcdFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdLFxuXHRcdFx0XHRcdFx0XHRyZXN1bHQub3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGRvRGlzcG9zZSkge1xuXHRcdFx0XHRhZGRBbGxUb1NldChvdXRkYXRlZE1vZHVsZXMsIFtyZXN1bHQubW9kdWxlSWRdKTtcblx0XHRcdFx0YXBwbGllZFVwZGF0ZVttb2R1bGVJZF0gPSB3YXJuVW5leHBlY3RlZFJlcXVpcmU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGN1cnJlbnRVcGRhdGUgPSB1bmRlZmluZWQ7XG5cblx0Ly8gU3RvcmUgc2VsZiBhY2NlcHRlZCBvdXRkYXRlZCBtb2R1bGVzIHRvIHJlcXVpcmUgdGhlbSBsYXRlciBieSB0aGUgbW9kdWxlIHN5c3RlbVxuXHR2YXIgb3V0ZGF0ZWRTZWxmQWNjZXB0ZWRNb2R1bGVzID0gW107XG5cdGZvciAodmFyIGogPSAwOyBqIDwgb3V0ZGF0ZWRNb2R1bGVzLmxlbmd0aDsgaisrKSB7XG5cdFx0dmFyIG91dGRhdGVkTW9kdWxlSWQgPSBvdXRkYXRlZE1vZHVsZXNbal07XG5cdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18uY1tvdXRkYXRlZE1vZHVsZUlkXTtcblx0XHRpZiAoXG5cdFx0XHRtb2R1bGUgJiZcblx0XHRcdChtb2R1bGUuaG90Ll9zZWxmQWNjZXB0ZWQgfHwgbW9kdWxlLmhvdC5fbWFpbikgJiZcblx0XHRcdC8vIHJlbW92ZWQgc2VsZi1hY2NlcHRlZCBtb2R1bGVzIHNob3VsZCBub3QgYmUgcmVxdWlyZWRcblx0XHRcdGFwcGxpZWRVcGRhdGVbb3V0ZGF0ZWRNb2R1bGVJZF0gIT09IHdhcm5VbmV4cGVjdGVkUmVxdWlyZSAmJlxuXHRcdFx0Ly8gd2hlbiBjYWxsZWQgaW52YWxpZGF0ZSBzZWxmLWFjY2VwdGluZyBpcyBub3QgcG9zc2libGVcblx0XHRcdCFtb2R1bGUuaG90Ll9zZWxmSW52YWxpZGF0ZWRcblx0XHQpIHtcblx0XHRcdG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlcy5wdXNoKHtcblx0XHRcdFx0bW9kdWxlOiBvdXRkYXRlZE1vZHVsZUlkLFxuXHRcdFx0XHRyZXF1aXJlOiBtb2R1bGUuaG90Ll9yZXF1aXJlU2VsZixcblx0XHRcdFx0ZXJyb3JIYW5kbGVyOiBtb2R1bGUuaG90Ll9zZWxmQWNjZXB0ZWRcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdHZhciBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcztcblxuXHRyZXR1cm4ge1xuXHRcdGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGN1cnJlbnRVcGRhdGVSZW1vdmVkQ2h1bmtzLmZvckVhY2goZnVuY3Rpb24gKGNodW5rSWQpIHtcblx0XHRcdFx0ZGVsZXRlIGluc3RhbGxlZENodW5rc1tjaHVua0lkXTtcblx0XHRcdH0pO1xuXHRcdFx0Y3VycmVudFVwZGF0ZVJlbW92ZWRDaHVua3MgPSB1bmRlZmluZWQ7XG5cblx0XHRcdHZhciBpZHg7XG5cdFx0XHR2YXIgcXVldWUgPSBvdXRkYXRlZE1vZHVsZXMuc2xpY2UoKTtcblx0XHRcdHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdHZhciBtb2R1bGVJZCA9IHF1ZXVlLnBvcCgpO1xuXHRcdFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXy5jW21vZHVsZUlkXTtcblx0XHRcdFx0aWYgKCFtb2R1bGUpIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHZhciBkYXRhID0ge307XG5cblx0XHRcdFx0Ly8gQ2FsbCBkaXNwb3NlIGhhbmRsZXJzXG5cdFx0XHRcdHZhciBkaXNwb3NlSGFuZGxlcnMgPSBtb2R1bGUuaG90Ll9kaXNwb3NlSGFuZGxlcnM7XG5cdFx0XHRcdGZvciAoaiA9IDA7IGogPCBkaXNwb3NlSGFuZGxlcnMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRkaXNwb3NlSGFuZGxlcnNbal0uY2FsbChudWxsLCBkYXRhKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmhtckRbbW9kdWxlSWRdID0gZGF0YTtcblxuXHRcdFx0XHQvLyBkaXNhYmxlIG1vZHVsZSAodGhpcyBkaXNhYmxlcyByZXF1aXJlcyBmcm9tIHRoaXMgbW9kdWxlKVxuXHRcdFx0XHRtb2R1bGUuaG90LmFjdGl2ZSA9IGZhbHNlO1xuXG5cdFx0XHRcdC8vIHJlbW92ZSBtb2R1bGUgZnJvbSBjYWNoZVxuXHRcdFx0XHRkZWxldGUgX193ZWJwYWNrX3JlcXVpcmVfXy5jW21vZHVsZUlkXTtcblxuXHRcdFx0XHQvLyB3aGVuIGRpc3Bvc2luZyB0aGVyZSBpcyBubyBuZWVkIHRvIGNhbGwgZGlzcG9zZSBoYW5kbGVyXG5cdFx0XHRcdGRlbGV0ZSBvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF07XG5cblx0XHRcdFx0Ly8gcmVtb3ZlIFwicGFyZW50c1wiIHJlZmVyZW5jZXMgZnJvbSBhbGwgY2hpbGRyZW5cblx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IG1vZHVsZS5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdHZhciBjaGlsZCA9IF9fd2VicGFja19yZXF1aXJlX18uY1ttb2R1bGUuY2hpbGRyZW5bal1dO1xuXHRcdFx0XHRcdGlmICghY2hpbGQpIGNvbnRpbnVlO1xuXHRcdFx0XHRcdGlkeCA9IGNoaWxkLnBhcmVudHMuaW5kZXhPZihtb2R1bGVJZCk7XG5cdFx0XHRcdFx0aWYgKGlkeCA+PSAwKSB7XG5cdFx0XHRcdFx0XHRjaGlsZC5wYXJlbnRzLnNwbGljZShpZHgsIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyByZW1vdmUgb3V0ZGF0ZWQgZGVwZW5kZW5jeSBmcm9tIG1vZHVsZSBjaGlsZHJlblxuXHRcdFx0dmFyIGRlcGVuZGVuY3k7XG5cdFx0XHRmb3IgKHZhciBvdXRkYXRlZE1vZHVsZUlkIGluIG91dGRhdGVkRGVwZW5kZW5jaWVzKSB7XG5cdFx0XHRcdGlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLm8ob3V0ZGF0ZWREZXBlbmRlbmNpZXMsIG91dGRhdGVkTW9kdWxlSWQpKSB7XG5cdFx0XHRcdFx0bW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXy5jW291dGRhdGVkTW9kdWxlSWRdO1xuXHRcdFx0XHRcdGlmIChtb2R1bGUpIHtcblx0XHRcdFx0XHRcdG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzID1cblx0XHRcdFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXNbb3V0ZGF0ZWRNb2R1bGVJZF07XG5cdFx0XHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRcdFx0ZGVwZW5kZW5jeSA9IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzW2pdO1xuXHRcdFx0XHRcdFx0XHRpZHggPSBtb2R1bGUuY2hpbGRyZW4uaW5kZXhPZihkZXBlbmRlbmN5KTtcblx0XHRcdFx0XHRcdFx0aWYgKGlkeCA+PSAwKSBtb2R1bGUuY2hpbGRyZW4uc3BsaWNlKGlkeCwgMSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhcHBseTogZnVuY3Rpb24gKHJlcG9ydEVycm9yKSB7XG5cdFx0XHQvLyBpbnNlcnQgbmV3IGNvZGVcblx0XHRcdGZvciAodmFyIHVwZGF0ZU1vZHVsZUlkIGluIGFwcGxpZWRVcGRhdGUpIHtcblx0XHRcdFx0aWYgKF9fd2VicGFja19yZXF1aXJlX18ubyhhcHBsaWVkVXBkYXRlLCB1cGRhdGVNb2R1bGVJZCkpIHtcblx0XHRcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLm1bdXBkYXRlTW9kdWxlSWRdID0gYXBwbGllZFVwZGF0ZVt1cGRhdGVNb2R1bGVJZF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gcnVuIG5ldyBydW50aW1lIG1vZHVsZXNcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY3VycmVudFVwZGF0ZVJ1bnRpbWUubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Y3VycmVudFVwZGF0ZVJ1bnRpbWVbaV0oX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNhbGwgYWNjZXB0IGhhbmRsZXJzXG5cdFx0XHRmb3IgKHZhciBvdXRkYXRlZE1vZHVsZUlkIGluIG91dGRhdGVkRGVwZW5kZW5jaWVzKSB7XG5cdFx0XHRcdGlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLm8ob3V0ZGF0ZWREZXBlbmRlbmNpZXMsIG91dGRhdGVkTW9kdWxlSWQpKSB7XG5cdFx0XHRcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18uY1tvdXRkYXRlZE1vZHVsZUlkXTtcblx0XHRcdFx0XHRpZiAobW9kdWxlKSB7XG5cdFx0XHRcdFx0XHRtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcyA9XG5cdFx0XHRcdFx0XHRcdG91dGRhdGVkRGVwZW5kZW5jaWVzW291dGRhdGVkTW9kdWxlSWRdO1xuXHRcdFx0XHRcdFx0dmFyIGNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0XHRcdFx0dmFyIGVycm9ySGFuZGxlcnMgPSBbXTtcblx0XHRcdFx0XHRcdHZhciBkZXBlbmRlbmNpZXNGb3JDYWxsYmFja3MgPSBbXTtcblx0XHRcdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRcdFx0dmFyIGRlcGVuZGVuY3kgPSBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llc1tqXTtcblx0XHRcdFx0XHRcdFx0dmFyIGFjY2VwdENhbGxiYWNrID1cblx0XHRcdFx0XHRcdFx0XHRtb2R1bGUuaG90Ll9hY2NlcHRlZERlcGVuZGVuY2llc1tkZXBlbmRlbmN5XTtcblx0XHRcdFx0XHRcdFx0dmFyIGVycm9ySGFuZGxlciA9XG5cdFx0XHRcdFx0XHRcdFx0bW9kdWxlLmhvdC5fYWNjZXB0ZWRFcnJvckhhbmRsZXJzW2RlcGVuZGVuY3ldO1xuXHRcdFx0XHRcdFx0XHRpZiAoYWNjZXB0Q2FsbGJhY2spIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoY2FsbGJhY2tzLmluZGV4T2YoYWNjZXB0Q2FsbGJhY2spICE9PSAtMSkgY29udGludWU7XG5cdFx0XHRcdFx0XHRcdFx0Y2FsbGJhY2tzLnB1c2goYWNjZXB0Q2FsbGJhY2spO1xuXHRcdFx0XHRcdFx0XHRcdGVycm9ySGFuZGxlcnMucHVzaChlcnJvckhhbmRsZXIpO1xuXHRcdFx0XHRcdFx0XHRcdGRlcGVuZGVuY2llc0ZvckNhbGxiYWNrcy5wdXNoKGRlcGVuZGVuY3kpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IGNhbGxiYWNrcy5sZW5ndGg7IGsrKykge1xuXHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdGNhbGxiYWNrc1trXS5jYWxsKG51bGwsIG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzKTtcblx0XHRcdFx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHR5cGVvZiBlcnJvckhhbmRsZXJzW2tdID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGVycm9ySGFuZGxlcnNba10oZXJyLCB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG91dGRhdGVkTW9kdWxlSWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVwZW5kZW5jeUlkOiBkZXBlbmRlbmNpZXNGb3JDYWxsYmFja3Nba11cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoIChlcnIyKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChvcHRpb25zLm9uRXJyb3JlZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnMub25FcnJvcmVkKHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYWNjZXB0LWVycm9yLWhhbmRsZXItZXJyb3JlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG91dGRhdGVkTW9kdWxlSWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZXBlbmRlbmN5SWQ6IGRlcGVuZGVuY2llc0ZvckNhbGxiYWNrc1trXSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGVycm9yOiBlcnIyLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3JpZ2luYWxFcnJvcjogZXJyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCFvcHRpb25zLmlnbm9yZUVycm9yZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXBvcnRFcnJvcihlcnIyKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXBvcnRFcnJvcihlcnIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChvcHRpb25zLm9uRXJyb3JlZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zLm9uRXJyb3JlZCh7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJhY2NlcHQtZXJyb3JlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBvdXRkYXRlZE1vZHVsZUlkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlcGVuZGVuY3lJZDogZGVwZW5kZW5jaWVzRm9yQ2FsbGJhY2tzW2tdLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGVycm9yOiBlcnJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuaWdub3JlRXJyb3JlZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXBvcnRFcnJvcihlcnIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb2FkIHNlbGYgYWNjZXB0ZWQgbW9kdWxlc1xuXHRcdFx0Zm9yICh2YXIgbyA9IDA7IG8gPCBvdXRkYXRlZFNlbGZBY2NlcHRlZE1vZHVsZXMubGVuZ3RoOyBvKyspIHtcblx0XHRcdFx0dmFyIGl0ZW0gPSBvdXRkYXRlZFNlbGZBY2NlcHRlZE1vZHVsZXNbb107XG5cdFx0XHRcdHZhciBtb2R1bGVJZCA9IGl0ZW0ubW9kdWxlO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGl0ZW0ucmVxdWlyZShtb2R1bGVJZCk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdGlmICh0eXBlb2YgaXRlbS5lcnJvckhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0aXRlbS5lcnJvckhhbmRsZXIoZXJyLCB7XG5cdFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxuXHRcdFx0XHRcdFx0XHRcdG1vZHVsZTogX193ZWJwYWNrX3JlcXVpcmVfXy5jW21vZHVsZUlkXVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKGVycjIpIHtcblx0XHRcdFx0XHRcdFx0aWYgKG9wdGlvbnMub25FcnJvcmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5vbkVycm9yZWQoe1xuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzZWxmLWFjY2VwdC1lcnJvci1oYW5kbGVyLWVycm9yZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZCxcblx0XHRcdFx0XHRcdFx0XHRcdGVycm9yOiBlcnIyLFxuXHRcdFx0XHRcdFx0XHRcdFx0b3JpZ2luYWxFcnJvcjogZXJyXG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKCFvcHRpb25zLmlnbm9yZUVycm9yZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXBvcnRFcnJvcihlcnIyKTtcblx0XHRcdFx0XHRcdFx0XHRyZXBvcnRFcnJvcihlcnIpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmIChvcHRpb25zLm9uRXJyb3JlZCkge1xuXHRcdFx0XHRcdFx0XHRvcHRpb25zLm9uRXJyb3JlZCh7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzZWxmLWFjY2VwdC1lcnJvcmVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxuXHRcdFx0XHRcdFx0XHRcdGVycm9yOiBlcnJcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuaWdub3JlRXJyb3JlZCkge1xuXHRcdFx0XHRcdFx0XHRyZXBvcnRFcnJvcihlcnIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb3V0ZGF0ZWRNb2R1bGVzO1xuXHRcdH1cblx0fTtcbn1cbl9fd2VicGFja19yZXF1aXJlX18uaG1ySS5qc29ucCA9IGZ1bmN0aW9uIChtb2R1bGVJZCwgYXBwbHlIYW5kbGVycykge1xuXHRpZiAoIWN1cnJlbnRVcGRhdGUpIHtcblx0XHRjdXJyZW50VXBkYXRlID0ge307XG5cdFx0Y3VycmVudFVwZGF0ZVJ1bnRpbWUgPSBbXTtcblx0XHRjdXJyZW50VXBkYXRlUmVtb3ZlZENodW5rcyA9IFtdO1xuXHRcdGFwcGx5SGFuZGxlcnMucHVzaChhcHBseUhhbmRsZXIpO1xuXHR9XG5cdGlmICghX193ZWJwYWNrX3JlcXVpcmVfXy5vKGN1cnJlbnRVcGRhdGUsIG1vZHVsZUlkKSkge1xuXHRcdGN1cnJlbnRVcGRhdGVbbW9kdWxlSWRdID0gX193ZWJwYWNrX3JlcXVpcmVfXy5tW21vZHVsZUlkXTtcblx0fVxufTtcbl9fd2VicGFja19yZXF1aXJlX18uaG1yQy5qc29ucCA9IGZ1bmN0aW9uIChcblx0Y2h1bmtJZHMsXG5cdHJlbW92ZWRDaHVua3MsXG5cdHJlbW92ZWRNb2R1bGVzLFxuXHRwcm9taXNlcyxcblx0YXBwbHlIYW5kbGVycyxcblx0dXBkYXRlZE1vZHVsZXNMaXN0XG4pIHtcblx0YXBwbHlIYW5kbGVycy5wdXNoKGFwcGx5SGFuZGxlcik7XG5cdGN1cnJlbnRVcGRhdGVDaHVua3MgPSB7fTtcblx0Y3VycmVudFVwZGF0ZVJlbW92ZWRDaHVua3MgPSByZW1vdmVkQ2h1bmtzO1xuXHRjdXJyZW50VXBkYXRlID0gcmVtb3ZlZE1vZHVsZXMucmVkdWNlKGZ1bmN0aW9uIChvYmosIGtleSkge1xuXHRcdG9ialtrZXldID0gZmFsc2U7XG5cdFx0cmV0dXJuIG9iajtcblx0fSwge30pO1xuXHRjdXJyZW50VXBkYXRlUnVudGltZSA9IFtdO1xuXHRjaHVua0lkcy5mb3JFYWNoKGZ1bmN0aW9uIChjaHVua0lkKSB7XG5cdFx0aWYgKFxuXHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vKGluc3RhbGxlZENodW5rcywgY2h1bmtJZCkgJiZcblx0XHRcdGluc3RhbGxlZENodW5rc1tjaHVua0lkXSAhPT0gdW5kZWZpbmVkXG5cdFx0KSB7XG5cdFx0XHRwcm9taXNlcy5wdXNoKGxvYWRVcGRhdGVDaHVuayhjaHVua0lkLCB1cGRhdGVkTW9kdWxlc0xpc3QpKTtcblx0XHRcdGN1cnJlbnRVcGRhdGVDaHVua3NbY2h1bmtJZF0gPSB0cnVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJyZW50VXBkYXRlQ2h1bmtzW2NodW5rSWRdID0gZmFsc2U7XG5cdFx0fVxuXHR9KTtcblx0aWYgKF9fd2VicGFja19yZXF1aXJlX18uZikge1xuXHRcdF9fd2VicGFja19yZXF1aXJlX18uZi5qc29ucEhtciA9IGZ1bmN0aW9uIChjaHVua0lkLCBwcm9taXNlcykge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRjdXJyZW50VXBkYXRlQ2h1bmtzICYmXG5cdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18ubyhjdXJyZW50VXBkYXRlQ2h1bmtzLCBjaHVua0lkKSAmJlxuXHRcdFx0XHQhY3VycmVudFVwZGF0ZUNodW5rc1tjaHVua0lkXVxuXHRcdFx0KSB7XG5cdFx0XHRcdHByb21pc2VzLnB1c2gobG9hZFVwZGF0ZUNodW5rKGNodW5rSWQpKTtcblx0XHRcdFx0Y3VycmVudFVwZGF0ZUNodW5rc1tjaHVua0lkXSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufTtcblxuX193ZWJwYWNrX3JlcXVpcmVfXy5obXJNID0gZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZmV0Y2ggPT09IFwidW5kZWZpbmVkXCIpIHRocm93IG5ldyBFcnJvcihcIk5vIGJyb3dzZXIgc3VwcG9ydDogbmVlZCBmZXRjaCBBUElcIik7XG5cdHJldHVybiBmZXRjaChfX3dlYnBhY2tfcmVxdWlyZV9fLnAgKyBfX3dlYnBhY2tfcmVxdWlyZV9fLmhtckYoKSkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuXHRcdGlmKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSByZXR1cm47IC8vIG5vIHVwZGF0ZSBhdmFpbGFibGVcblx0XHRpZighcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBmZXRjaCB1cGRhdGUgbWFuaWZlc3QgXCIgKyByZXNwb25zZS5zdGF0dXNUZXh0KTtcblx0XHRyZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuXHR9KTtcbn07XG5cbi8vIG5vIG9uIGNodW5rcyBsb2FkZWRcblxuLy8gaW5zdGFsbCBhIEpTT05QIGNhbGxiYWNrIGZvciBjaHVuayBsb2FkaW5nXG52YXIgd2VicGFja0pzb25wQ2FsbGJhY2sgPSBmdW5jdGlvbihwYXJlbnRDaHVua0xvYWRpbmdGdW5jdGlvbiwgZGF0YSkge1xuXHR2YXIgY2h1bmtJZHMgPSBkYXRhWzBdO1xuXHR2YXIgbW9yZU1vZHVsZXMgPSBkYXRhWzFdO1xuXHR2YXIgcnVudGltZSA9IGRhdGFbMl07XG5cdC8vIGFkZCBcIm1vcmVNb2R1bGVzXCIgdG8gdGhlIG1vZHVsZXMgb2JqZWN0LFxuXHQvLyB0aGVuIGZsYWcgYWxsIFwiY2h1bmtJZHNcIiBhcyBsb2FkZWQgYW5kIGZpcmUgY2FsbGJhY2tcblx0dmFyIG1vZHVsZUlkLCBjaHVua0lkLCBpID0gMDtcblx0aWYoY2h1bmtJZHMuc29tZShmdW5jdGlvbihpZCkgeyByZXR1cm4gaW5zdGFsbGVkQ2h1bmtzW2lkXSAhPT0gMDsgfSkpIHtcblx0XHRmb3IobW9kdWxlSWQgaW4gbW9yZU1vZHVsZXMpIHtcblx0XHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhtb3JlTW9kdWxlcywgbW9kdWxlSWQpKSB7XG5cdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18ubVttb2R1bGVJZF0gPSBtb3JlTW9kdWxlc1ttb2R1bGVJZF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmKHJ1bnRpbWUpIHZhciByZXN1bHQgPSBydW50aW1lKF9fd2VicGFja19yZXF1aXJlX18pO1xuXHR9XG5cdGlmKHBhcmVudENodW5rTG9hZGluZ0Z1bmN0aW9uKSBwYXJlbnRDaHVua0xvYWRpbmdGdW5jdGlvbihkYXRhKTtcblx0Zm9yKDtpIDwgY2h1bmtJZHMubGVuZ3RoOyBpKyspIHtcblx0XHRjaHVua0lkID0gY2h1bmtJZHNbaV07XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGluc3RhbGxlZENodW5rcywgY2h1bmtJZCkgJiYgaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdKSB7XG5cdFx0XHRpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF1bMF0oKTtcblx0XHR9XG5cdFx0aW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gMDtcblx0fVxuXG59XG5cbnZhciBjaHVua0xvYWRpbmdHbG9iYWwgPSBzZWxmW1wid2VicGFja0NodW5rY2FwaV9zaW1wbGVfZGVtb1wiXSA9IHNlbGZbXCJ3ZWJwYWNrQ2h1bmtjYXBpX3NpbXBsZV9kZW1vXCJdIHx8IFtdO1xuY2h1bmtMb2FkaW5nR2xvYmFsLmZvckVhY2god2VicGFja0pzb25wQ2FsbGJhY2suYmluZChudWxsLCAwKSk7XG5jaHVua0xvYWRpbmdHbG9iYWwucHVzaCA9IHdlYnBhY2tKc29ucENhbGxiYWNrLmJpbmQobnVsbCwgY2h1bmtMb2FkaW5nR2xvYmFsLnB1c2guYmluZChjaHVua0xvYWRpbmdHbG9iYWwpKTsiLCIiLCIvLyBtb2R1bGUgY2FjaGUgYXJlIHVzZWQgc28gZW50cnkgaW5saW5pbmcgaXMgZGlzYWJsZWRcbi8vIHN0YXJ0dXBcbi8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xudmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvaW5kZXgudHNcIik7XG4iLCIiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=