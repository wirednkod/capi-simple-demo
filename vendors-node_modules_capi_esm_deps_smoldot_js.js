"use strict";
(self["webpackChunkcapi_simple_demo"] = self["webpackChunkcapi_simple_demo"] || []).push([["vendors-node_modules_capi_esm_deps_smoldot_js"],{

/***/ "./node_modules/@substrate/smoldot-light/dist/client.js":
/*!**************************************************************!*\
  !*** ./node_modules/@substrate/smoldot-light/dist/client.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AddChainError": function() { return /* binding */ AddChainError; },
/* harmony export */   "AlreadyDestroyedError": function() { return /* binding */ AlreadyDestroyedError; },
/* harmony export */   "CrashError": function() { return /* binding */ CrashError; },
/* harmony export */   "JsonRpcDisabledError": function() { return /* binding */ JsonRpcDisabledError; },
/* harmony export */   "start": function() { return /* binding */ start; }
/* harmony export */ });
/* harmony import */ var _compat_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compat/index.js */ "./node_modules/@substrate/smoldot-light/dist/compat/index-browser-overwrite.js");
/* harmony import */ var _worker_spawn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./worker/spawn.js */ "./node_modules/@substrate/smoldot-light/dist/worker/spawn-browser-overwrite.js");
// Smoldot
// Copyright (C) 2019-2022  Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.


/**
 * Thrown in case of a problem when initializing the chain.
 */
class AddChainError extends Error {
    constructor(message) {
        super(message);
        this.name = "AddChainError";
    }
}
/**
 * Thrown in case the API user tries to use a chain or client that has already been destroyed.
 */
class AlreadyDestroyedError extends Error {
    constructor() {
        super();
        this.name = "AlreadyDestroyedError";
    }
}
/**
 * Thrown when trying to send a JSON-RPC message to a chain whose JSON-RPC system hasn't been
 * enabled.
 */
class JsonRpcDisabledError extends Error {
    constructor() {
        super();
        this.name = "JsonRpcDisabledError";
    }
}
/**
 * Thrown in case the underlying client encounters an unexpected crash.
 *
 * This is always an internal bug in smoldot and is never supposed to happen.
 */
class CrashError extends Error {
    constructor(message) {
        super(message);
    }
}
/**
 * Initializes a new client. This is a pre-requisite to connecting to a blockchain.
 *
 * Can never fail.
 *
 * @param options Configuration of the client. Defaults to `{}`.
 */
function start(options) {
    options = options || {};
    const logCallback = options.logCallback || ((level, target, message) => {
        // The first parameter of the methods of `console` has some printf-like substitution
        // capabilities. We don't really need to use this, but not using it means that the logs might
        // not get printed correctly if they contain `%`.
        if (level <= 1) {
            console.error("[%s] %s", target, message);
        }
        else if (level == 2) {
            console.warn("[%s] %s", target, message);
        }
        else if (level == 3) {
            console.info("[%s] %s", target, message);
        }
        else if (level == 4) {
            console.debug("[%s] %s", target, message);
        }
        else {
            console.trace("[%s] %s", target, message);
        }
    });
    // The actual execution of Smoldot is performed in a worker thread.
    // Because this specific line of code is a bit sensitive, it is done in a separate file.
    const worker = (0,_worker_spawn_js__WEBPACK_IMPORTED_MODULE_1__["default"])();
    let workerError = null;
    // Whenever an `addChain` or `removeChain` message is sent to the worker, a corresponding entry
    // is pushed to this array. The worker needs to send back a confirmation, which pops the first
    // element of this array. In the case of `addChain`, additional fields are stored in this array
    // to finish the initialization of the chain.
    let pendingConfirmations = [];
    // Contains the information of each chain that is currently.
    // Entries are instantly removed when the user desires to remove a chain even before the worker
    // has confirmed the removal. Doing so avoids a race condition where the worker sends back a
    // database content or a JSON-RPC response/notification even though we've already sent a
    // `removeChain` message to it.
    //
    // This map is also used in general as a way to check whether a chain still exists.
    let chains = new Map();
    // For each chain object returned by `addChain`, the associated internal chain id.
    //
    // Immediately cleared when `remove()` is called on a chain.
    let chainIds = new WeakMap();
    // The worker periodically reports the name of the task it is currently in. This makes it
    // possible, when the worker is frozen, to know which task it was in when frozen.
    const workerCurrentTask = { name: null };
    // The worker periodically sends a message of kind 'livenessPing' in order to notify that it is
    // still alive.
    // If this liveness ping isn't received for a long time, an error is reported in the logs.
    // The first check is delayed in order to account for the fact that the worker has to perform
    // an expensive initialization step when initializing the Wasm VM.
    let livenessTimeout = null;
    const resetLivenessTimeout = () => {
        if (livenessTimeout !== null)
            globalThis.clearTimeout(livenessTimeout);
        livenessTimeout = globalThis.setTimeout(() => {
            livenessTimeout = null;
            if (workerError)
                return; // The unresponsiveness is due to a crash. No need to print more warnings.
            console.warn("Smoldot appears unresponsive" +
                (workerCurrentTask.name ? (" while executing task `" + workerCurrentTask.name + "`") : "") +
                ". Please open an issue at https://github.com/paritytech/smoldot/issues. If you have a " +
                "debugger available, please pause execution, generate a stack trace of the thread " +
                "that isn't the main execution thread, and paste it in the issue. Please also include " +
                "any other log found in the console or elsewhere.");
        }, 10000);
    };
    globalThis.setTimeout(() => resetLivenessTimeout(), 15000);
    // The worker can send us messages whose type is identified through a `kind` field.
    (0,_compat_index_js__WEBPACK_IMPORTED_MODULE_0__.workerOnMessage)(worker, (message) => {
        switch (message.kind) {
            case 'jsonrpc': {
                const cb = chains.get(message.chainId)?.jsonRpcCallback;
                if (cb)
                    cb(message.data);
                break;
            }
            case 'chainAddedOk': {
                const expected = pendingConfirmations.shift();
                const chainId = message.chainId;
                if (chains.has(chainId)) // Sanity check.
                    throw 'Unexpected reuse of a chain ID';
                chains.set(chainId, {
                    jsonRpcCallback: expected.jsonRpcCallback,
                    databasePromises: new Array()
                });
                // `expected` was pushed by the `addChain` method.
                // Resolve the promise that `addChain` returned to the user.
                const newChain = {
                    sendJsonRpc: (request) => {
                        if (workerError)
                            throw workerError;
                        if (!chains.has(chainId))
                            throw new AlreadyDestroyedError();
                        if (!(chains.get(chainId)?.jsonRpcCallback))
                            throw new JsonRpcDisabledError();
                        if (request.length >= 8 * 1024 * 1024)
                            return;
                        postMessage(worker, { ty: 'request', request, chainId });
                    },
                    databaseContent: (maxUtf8BytesSize) => {
                        if (workerError)
                            return Promise.reject(workerError);
                        const databaseContentPromises = chains.get(chainId)?.databasePromises;
                        if (!databaseContentPromises)
                            return Promise.reject(new AlreadyDestroyedError());
                        const promise = new Promise((resolve, reject) => {
                            databaseContentPromises.push({ resolve, reject });
                        });
                        const twoPower32 = (1 << 30) * 4; // `1 << 31` and `1 << 32` in JavaScript don't give the value that you expect.
                        const maxSize = maxUtf8BytesSize || (twoPower32 - 1);
                        const cappedMaxSize = (maxSize >= twoPower32) ? (twoPower32 - 1) : maxSize;
                        postMessage(worker, { ty: 'databaseContent', chainId, maxUtf8BytesSize: cappedMaxSize });
                        return promise;
                    },
                    remove: () => {
                        if (workerError)
                            throw workerError;
                        // Because the `removeChain` message is asynchronous, it is possible for a JSON-RPC
                        // response or database content concerning that `chainId` to arrive after the `remove`
                        // function has returned. We solve that by removing the information immediately.
                        if (!chains.delete(chainId))
                            throw new AlreadyDestroyedError();
                        console.assert(chainIds.has(newChain));
                        chainIds.delete(newChain);
                        postMessage(worker, { ty: 'removeChain', chainId });
                    },
                };
                chainIds.set(newChain, chainId);
                expected.resolve(newChain);
                break;
            }
            case 'chainAddedErr': {
                const expected = pendingConfirmations.shift();
                // `expected` was pushed by the `addChain` method.
                // Reject the promise that `addChain` returned to the user.
                expected.reject(new AddChainError(message.error));
                break;
            }
            case 'databaseContent': {
                const promises = chains.get(message.chainId)?.databasePromises;
                if (promises)
                    promises.shift().resolve(message.data);
                break;
            }
            case 'log': {
                logCallback(message.level, message.target, message.message);
                break;
            }
            case 'livenessPing': {
                resetLivenessTimeout();
                break;
            }
            case 'currentTask': {
                workerCurrentTask.name = message.taskName;
                break;
            }
            default: {
                // Exhaustive check.
                const _exhaustiveCheck = message;
                return _exhaustiveCheck;
            }
        }
    });
    (0,_compat_index_js__WEBPACK_IMPORTED_MODULE_0__.workerOnError)(worker, (error) => {
        // A worker error should only happen in case of a critical error as the result of a bug
        // somewhere. Consequently, nothing is really in place to cleanly report the error.
        const errorToString = error.toString();
        console.error("Smoldot has panicked" +
            (workerCurrentTask.name ? (" while executing task `" + workerCurrentTask.name + "`") : "") +
            ". This is a bug in smoldot. Please open an issue at " +
            "https://github.com/paritytech/smoldot/issues with the following message:\n" +
            errorToString);
        workerError = new CrashError(errorToString);
        // Reject all promises returned by `addChain`.
        for (var pending of pendingConfirmations) {
            if (pending.ty == 'chainAdded')
                pending.reject(workerError);
        }
        pendingConfirmations = [];
        // Reject all promises for database contents.
        for (const chain of chains) {
            for (const promise of chain[1].databasePromises) {
                promise.reject(workerError);
            }
        }
        chains.clear();
    });
    // The first message expected by the worker contains the configuration.
    postMessage(worker, {
        // Maximum level of log entries sent by the client.
        // 0 = Logging disabled, 1 = Error, 2 = Warn, 3 = Info, 4 = Debug, 5 = Trace
        maxLogLevel: options.maxLogLevel || 3,
        enableCurrentTask: true,
        cpuRateLimit: options.cpuRateLimit || 1.0,
        forbidTcp: options.forbidTcp || false,
        forbidWs: options.forbidWs || false,
        forbidNonLocalWs: options.forbidNonLocalWs || false,
        forbidWss: options.forbidWss || false,
    });
    return {
        addChain: (options) => {
            if (workerError)
                throw workerError;
            // Passing a JSON object for the chain spec is an easy mistake, so we provide a more
            // readable error.
            if (!(typeof options.chainSpec === 'string'))
                throw new Error("Chain specification must be a string");
            let potentialRelayChainsIds = [];
            if (!!options.potentialRelayChains) {
                for (const chain of options.potentialRelayChains) {
                    // The content of `options.potentialRelayChains` are supposed to be chains earlier
                    // returned by `addChain`.
                    const id = chainIds.get(chain);
                    if (id === undefined) // It is possible for `id` to be missing if it has earlier been removed.
                        continue;
                    potentialRelayChainsIds.push(id);
                }
            }
            // Build a promise that will be resolved or rejected after the chain has been added.
            // TODO: because of https://github.com/microsoft/TypeScript/issues/11498 we need to define the callbacks as possibly null, and go through `unknown`
            let chainAddedPromiseResolve;
            let chainAddedPromiseReject;
            const chainAddedPromise = new Promise((resolve, reject) => {
                chainAddedPromiseResolve = resolve;
                chainAddedPromiseReject = reject;
            });
            pendingConfirmations.push({
                ty: 'chainAdded',
                reject: chainAddedPromiseReject,
                resolve: chainAddedPromiseResolve,
                jsonRpcCallback: options.jsonRpcCallback,
            });
            postMessage(worker, {
                ty: 'addChain',
                chainSpec: options.chainSpec,
                databaseContent: typeof options.databaseContent === 'string' ? options.databaseContent : "",
                potentialRelayChains: potentialRelayChainsIds,
                jsonRpcRunning: !!options.jsonRpcCallback,
            });
            return chainAddedPromise;
        },
        terminate: () => {
            if (workerError)
                return Promise.reject(workerError);
            workerError = new AlreadyDestroyedError();
            if (livenessTimeout !== null)
                globalThis.clearTimeout(livenessTimeout);
            return (0,_compat_index_js__WEBPACK_IMPORTED_MODULE_0__.workerTerminate)(worker);
        }
    };
}
// Separate function in order to enforce types.
function postMessage(worker, message) {
    worker.postMessage(message);
}


/***/ }),

/***/ "./node_modules/@substrate/smoldot-light/dist/compat/index-browser-overwrite.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@substrate/smoldot-light/dist/compat/index-browser-overwrite.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createConnection": function() { return /* binding */ createConnection; },
/* harmony export */   "getRandomValues": function() { return /* binding */ getRandomValues; },
/* harmony export */   "isTcpAvailable": function() { return /* binding */ isTcpAvailable; },
/* harmony export */   "performanceNow": function() { return /* binding */ performanceNow; },
/* harmony export */   "postMessage": function() { return /* binding */ postMessage; },
/* harmony export */   "setOnMessage": function() { return /* binding */ setOnMessage; },
/* harmony export */   "workerOnError": function() { return /* binding */ workerOnError; },
/* harmony export */   "workerOnMessage": function() { return /* binding */ workerOnMessage; },
/* harmony export */   "workerTerminate": function() { return /* binding */ workerTerminate; }
/* harmony export */ });
// Smoldot
// Copyright (C) 2019-2022  Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
// Overrides `index.js` when in a browser.
function workerOnMessage(worker, callback) {
    worker.onmessage = (event) => callback(event.data);
}
function workerOnError(worker, callback) {
    worker.onerror = (event) => {
        // For reference:
        // https://html.spec.whatwg.org/multipage/indices.html#event-error
        // https://html.spec.whatwg.org/multipage/webappapis.html#errorevent
        // If `event.error` exists, then it will likely be an instance of `Error`.
        // However, that's not guaranteed by the spec and it could also be
        // something else. So, our second best try is the `event.message`
        // property. Finally, our last resort is to create an Error from the event.
        if (event.error instanceof Error)
            callback(event.error);
        else
            callback(new Error(event.message || event));
    };
}
function workerTerminate(worker) {
    worker.terminate();
    return Promise.resolve();
}
function postMessage(msg) {
    self.postMessage(msg);
}
function setOnMessage(callback) {
    self.onmessage = (event) => callback(event.data);
}
function performanceNow() {
    return performance.now();
}
function isTcpAvailable() {
    return false;
}
function createConnection(_opts, _connectionListener) {
    throw new Error('TCP connections not available');
}
function getRandomValues(buffer) {
    const crypto = globalThis.crypto;
    if (!crypto)
        throw new Error('randomness not available');
    crypto.getRandomValues(buffer);
}


/***/ }),

/***/ "./node_modules/@substrate/smoldot-light/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@substrate/smoldot-light/dist/index.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AddChainError": function() { return /* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_0__.AddChainError; },
/* harmony export */   "AlreadyDestroyedError": function() { return /* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_0__.AlreadyDestroyedError; },
/* harmony export */   "CrashError": function() { return /* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_0__.CrashError; },
/* harmony export */   "JsonRpcDisabledError": function() { return /* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_0__.JsonRpcDisabledError; },
/* harmony export */   "start": function() { return /* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_0__.start; }
/* harmony export */ });
/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./client.js */ "./node_modules/@substrate/smoldot-light/dist/client.js");
// Smoldot
// Copyright (C) 2019-2022  Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
 // TODO: precise exports


/***/ }),

/***/ "./node_modules/@substrate/smoldot-light/dist/worker/spawn-browser-overwrite.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@substrate/smoldot-light/dist/worker/spawn-browser-overwrite.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
// Smoldot
// Copyright (C) 2019-2022  Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
    if (!window.Worker)
        throw new Error("Workers not available");
    // The line of code below (`new Worker(...)`) is designed to hopefully work across all
    // platforms and bundlers.
    // Because this line is precisely recognized by bundlers, we extract it to a separate
    // JavaScript file.
    // See also the README.md for more context.
    // Note that, at the time of writing, Firefox doesn't support the `type: "module"` option.
    // Because browsers don't fully support modules yet, this code is expected to be run through
    // a bundler (e.g. WebPack) before being given to a browser, which will remove all usage of
    // modules in the worker code. It is thus also the role of this bundler to tweak or remove
    // the value of this `type` property to indicate to the browser that modules aren't in use.
    //
    // WebPack in particular does this, but it is unclear whether *all* bundlers do it.
    // Whether bundlers actually do this or not, it is nonetheless more correct to indicate
    // `type: "module"` and doing so doesn't have any drawback.
    const worker = new Worker(new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u("smoldot"), __webpack_require__.b), { name: "smoldot", type: undefined });
    return worker;
}


/***/ }),

/***/ "./node_modules/capi/esm/deps/smoldot.js":
/*!***********************************************!*\
  !*** ./node_modules/capi/esm/deps/smoldot.js ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AddChainError": function() { return /* reexport safe */ _substrate_smoldot_light__WEBPACK_IMPORTED_MODULE_0__.AddChainError; },
/* harmony export */   "AlreadyDestroyedError": function() { return /* reexport safe */ _substrate_smoldot_light__WEBPACK_IMPORTED_MODULE_0__.AlreadyDestroyedError; },
/* harmony export */   "CrashError": function() { return /* reexport safe */ _substrate_smoldot_light__WEBPACK_IMPORTED_MODULE_0__.CrashError; },
/* harmony export */   "JsonRpcDisabledError": function() { return /* reexport safe */ _substrate_smoldot_light__WEBPACK_IMPORTED_MODULE_0__.JsonRpcDisabledError; },
/* harmony export */   "start": function() { return /* reexport safe */ _substrate_smoldot_light__WEBPACK_IMPORTED_MODULE_0__.start; }
/* harmony export */ });
/* harmony import */ var _substrate_smoldot_light__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @substrate/smoldot-light */ "./node_modules/@substrate/smoldot-light/dist/index.js");
// Smoldot is a peer dependency; we only utilize its types, never its runtime.

//# sourceMappingURL=smoldot.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfY2FwaV9lc21fZGVwc19zbW9sZG90X2pzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ29GO0FBQ3hDO0FBQzVDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQkFBbUIsNERBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLElBQUksaUVBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxpQ0FBaUM7QUFDL0UscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGlCQUFpQjtBQUM1RSx5QkFBeUI7QUFDekIsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQSw4Q0FBOEMsaUVBQWlFO0FBQy9HO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDRCQUE0QjtBQUMxRSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksK0RBQWE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpRUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDNEIsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7O0FDYjdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBZSxzQ0FBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxtR0FBOEIsS0FBSyx1QkFBdUIsU0FBUSxFQUFFO0FBQzFHO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaENBLGlDQUFpQztBQUNRO0FBQ3pDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9Ac3Vic3RyYXRlL3Ntb2xkb3QtbGlnaHQvZGlzdC9jbGllbnQuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9Ac3Vic3RyYXRlL3Ntb2xkb3QtbGlnaHQvZGlzdC9jb21wYXQvaW5kZXgtYnJvd3Nlci1vdmVyd3JpdGUuanMiLCJ3ZWJwYWNrOi8vY2FwaS1zaW1wbGUtZGVtby8uL25vZGVfbW9kdWxlcy9Ac3Vic3RyYXRlL3Ntb2xkb3QtbGlnaHQvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9jYXBpLXNpbXBsZS1kZW1vLy4vbm9kZV9tb2R1bGVzL0BzdWJzdHJhdGUvc21vbGRvdC1saWdodC9kaXN0L3dvcmtlci9zcGF3bi1icm93c2VyLW92ZXJ3cml0ZS5qcyIsIndlYnBhY2s6Ly9jYXBpLXNpbXBsZS1kZW1vLy4vbm9kZV9tb2R1bGVzL2NhcGkvZXNtL2RlcHMvc21vbGRvdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTbW9sZG90XG4vLyBDb3B5cmlnaHQgKEMpIDIwMTktMjAyMiAgUGFyaXR5IFRlY2hub2xvZ2llcyAoVUspIEx0ZC5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBHUEwtMy4wLW9yLWxhdGVyIFdJVEggQ2xhc3NwYXRoLWV4Y2VwdGlvbi0yLjBcbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3Jcbi8vIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuaW1wb3J0IHsgd29ya2VyT25NZXNzYWdlLCB3b3JrZXJPbkVycm9yLCB3b3JrZXJUZXJtaW5hdGUgfSBmcm9tICcuL2NvbXBhdC9pbmRleC5qcyc7XG5pbXBvcnQgc3Bhd25Xb3JrZXIgZnJvbSAnLi93b3JrZXIvc3Bhd24uanMnO1xuLyoqXG4gKiBUaHJvd24gaW4gY2FzZSBvZiBhIHByb2JsZW0gd2hlbiBpbml0aWFsaXppbmcgdGhlIGNoYWluLlxuICovXG5leHBvcnQgY2xhc3MgQWRkQ2hhaW5FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkFkZENoYWluRXJyb3JcIjtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biBpbiBjYXNlIHRoZSBBUEkgdXNlciB0cmllcyB0byB1c2UgYSBjaGFpbiBvciBjbGllbnQgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGRlc3Ryb3llZC5cbiAqL1xuZXhwb3J0IGNsYXNzIEFscmVhZHlEZXN0cm95ZWRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJBbHJlYWR5RGVzdHJveWVkRXJyb3JcIjtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIHRyeWluZyB0byBzZW5kIGEgSlNPTi1SUEMgbWVzc2FnZSB0byBhIGNoYWluIHdob3NlIEpTT04tUlBDIHN5c3RlbSBoYXNuJ3QgYmVlblxuICogZW5hYmxlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIEpzb25ScGNEaXNhYmxlZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkpzb25ScGNEaXNhYmxlZEVycm9yXCI7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gaW4gY2FzZSB0aGUgdW5kZXJseWluZyBjbGllbnQgZW5jb3VudGVycyBhbiB1bmV4cGVjdGVkIGNyYXNoLlxuICpcbiAqIFRoaXMgaXMgYWx3YXlzIGFuIGludGVybmFsIGJ1ZyBpbiBzbW9sZG90IGFuZCBpcyBuZXZlciBzdXBwb3NlZCB0byBoYXBwZW4uXG4gKi9cbmV4cG9ydCBjbGFzcyBDcmFzaEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgfVxufVxuLyoqXG4gKiBJbml0aWFsaXplcyBhIG5ldyBjbGllbnQuIFRoaXMgaXMgYSBwcmUtcmVxdWlzaXRlIHRvIGNvbm5lY3RpbmcgdG8gYSBibG9ja2NoYWluLlxuICpcbiAqIENhbiBuZXZlciBmYWlsLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIENvbmZpZ3VyYXRpb24gb2YgdGhlIGNsaWVudC4gRGVmYXVsdHMgdG8gYHt9YC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0KG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBsb2dDYWxsYmFjayA9IG9wdGlvbnMubG9nQ2FsbGJhY2sgfHwgKChsZXZlbCwgdGFyZ2V0LCBtZXNzYWdlKSA9PiB7XG4gICAgICAgIC8vIFRoZSBmaXJzdCBwYXJhbWV0ZXIgb2YgdGhlIG1ldGhvZHMgb2YgYGNvbnNvbGVgIGhhcyBzb21lIHByaW50Zi1saWtlIHN1YnN0aXR1dGlvblxuICAgICAgICAvLyBjYXBhYmlsaXRpZXMuIFdlIGRvbid0IHJlYWxseSBuZWVkIHRvIHVzZSB0aGlzLCBidXQgbm90IHVzaW5nIGl0IG1lYW5zIHRoYXQgdGhlIGxvZ3MgbWlnaHRcbiAgICAgICAgLy8gbm90IGdldCBwcmludGVkIGNvcnJlY3RseSBpZiB0aGV5IGNvbnRhaW4gYCVgLlxuICAgICAgICBpZiAobGV2ZWwgPD0gMSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlslc10gJXNcIiwgdGFyZ2V0LCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZXZlbCA9PSAyKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbJXNdICVzXCIsIHRhcmdldCwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGV2ZWwgPT0gMykge1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiWyVzXSAlc1wiLCB0YXJnZXQsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxldmVsID09IDQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoXCJbJXNdICVzXCIsIHRhcmdldCwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLnRyYWNlKFwiWyVzXSAlc1wiLCB0YXJnZXQsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gVGhlIGFjdHVhbCBleGVjdXRpb24gb2YgU21vbGRvdCBpcyBwZXJmb3JtZWQgaW4gYSB3b3JrZXIgdGhyZWFkLlxuICAgIC8vIEJlY2F1c2UgdGhpcyBzcGVjaWZpYyBsaW5lIG9mIGNvZGUgaXMgYSBiaXQgc2Vuc2l0aXZlLCBpdCBpcyBkb25lIGluIGEgc2VwYXJhdGUgZmlsZS5cbiAgICBjb25zdCB3b3JrZXIgPSBzcGF3bldvcmtlcigpO1xuICAgIGxldCB3b3JrZXJFcnJvciA9IG51bGw7XG4gICAgLy8gV2hlbmV2ZXIgYW4gYGFkZENoYWluYCBvciBgcmVtb3ZlQ2hhaW5gIG1lc3NhZ2UgaXMgc2VudCB0byB0aGUgd29ya2VyLCBhIGNvcnJlc3BvbmRpbmcgZW50cnlcbiAgICAvLyBpcyBwdXNoZWQgdG8gdGhpcyBhcnJheS4gVGhlIHdvcmtlciBuZWVkcyB0byBzZW5kIGJhY2sgYSBjb25maXJtYXRpb24sIHdoaWNoIHBvcHMgdGhlIGZpcnN0XG4gICAgLy8gZWxlbWVudCBvZiB0aGlzIGFycmF5LiBJbiB0aGUgY2FzZSBvZiBgYWRkQ2hhaW5gLCBhZGRpdGlvbmFsIGZpZWxkcyBhcmUgc3RvcmVkIGluIHRoaXMgYXJyYXlcbiAgICAvLyB0byBmaW5pc2ggdGhlIGluaXRpYWxpemF0aW9uIG9mIHRoZSBjaGFpbi5cbiAgICBsZXQgcGVuZGluZ0NvbmZpcm1hdGlvbnMgPSBbXTtcbiAgICAvLyBDb250YWlucyB0aGUgaW5mb3JtYXRpb24gb2YgZWFjaCBjaGFpbiB0aGF0IGlzIGN1cnJlbnRseS5cbiAgICAvLyBFbnRyaWVzIGFyZSBpbnN0YW50bHkgcmVtb3ZlZCB3aGVuIHRoZSB1c2VyIGRlc2lyZXMgdG8gcmVtb3ZlIGEgY2hhaW4gZXZlbiBiZWZvcmUgdGhlIHdvcmtlclxuICAgIC8vIGhhcyBjb25maXJtZWQgdGhlIHJlbW92YWwuIERvaW5nIHNvIGF2b2lkcyBhIHJhY2UgY29uZGl0aW9uIHdoZXJlIHRoZSB3b3JrZXIgc2VuZHMgYmFjayBhXG4gICAgLy8gZGF0YWJhc2UgY29udGVudCBvciBhIEpTT04tUlBDIHJlc3BvbnNlL25vdGlmaWNhdGlvbiBldmVuIHRob3VnaCB3ZSd2ZSBhbHJlYWR5IHNlbnQgYVxuICAgIC8vIGByZW1vdmVDaGFpbmAgbWVzc2FnZSB0byBpdC5cbiAgICAvL1xuICAgIC8vIFRoaXMgbWFwIGlzIGFsc28gdXNlZCBpbiBnZW5lcmFsIGFzIGEgd2F5IHRvIGNoZWNrIHdoZXRoZXIgYSBjaGFpbiBzdGlsbCBleGlzdHMuXG4gICAgbGV0IGNoYWlucyA9IG5ldyBNYXAoKTtcbiAgICAvLyBGb3IgZWFjaCBjaGFpbiBvYmplY3QgcmV0dXJuZWQgYnkgYGFkZENoYWluYCwgdGhlIGFzc29jaWF0ZWQgaW50ZXJuYWwgY2hhaW4gaWQuXG4gICAgLy9cbiAgICAvLyBJbW1lZGlhdGVseSBjbGVhcmVkIHdoZW4gYHJlbW92ZSgpYCBpcyBjYWxsZWQgb24gYSBjaGFpbi5cbiAgICBsZXQgY2hhaW5JZHMgPSBuZXcgV2Vha01hcCgpO1xuICAgIC8vIFRoZSB3b3JrZXIgcGVyaW9kaWNhbGx5IHJlcG9ydHMgdGhlIG5hbWUgb2YgdGhlIHRhc2sgaXQgaXMgY3VycmVudGx5IGluLiBUaGlzIG1ha2VzIGl0XG4gICAgLy8gcG9zc2libGUsIHdoZW4gdGhlIHdvcmtlciBpcyBmcm96ZW4sIHRvIGtub3cgd2hpY2ggdGFzayBpdCB3YXMgaW4gd2hlbiBmcm96ZW4uXG4gICAgY29uc3Qgd29ya2VyQ3VycmVudFRhc2sgPSB7IG5hbWU6IG51bGwgfTtcbiAgICAvLyBUaGUgd29ya2VyIHBlcmlvZGljYWxseSBzZW5kcyBhIG1lc3NhZ2Ugb2Yga2luZCAnbGl2ZW5lc3NQaW5nJyBpbiBvcmRlciB0byBub3RpZnkgdGhhdCBpdCBpc1xuICAgIC8vIHN0aWxsIGFsaXZlLlxuICAgIC8vIElmIHRoaXMgbGl2ZW5lc3MgcGluZyBpc24ndCByZWNlaXZlZCBmb3IgYSBsb25nIHRpbWUsIGFuIGVycm9yIGlzIHJlcG9ydGVkIGluIHRoZSBsb2dzLlxuICAgIC8vIFRoZSBmaXJzdCBjaGVjayBpcyBkZWxheWVkIGluIG9yZGVyIHRvIGFjY291bnQgZm9yIHRoZSBmYWN0IHRoYXQgdGhlIHdvcmtlciBoYXMgdG8gcGVyZm9ybVxuICAgIC8vIGFuIGV4cGVuc2l2ZSBpbml0aWFsaXphdGlvbiBzdGVwIHdoZW4gaW5pdGlhbGl6aW5nIHRoZSBXYXNtIFZNLlxuICAgIGxldCBsaXZlbmVzc1RpbWVvdXQgPSBudWxsO1xuICAgIGNvbnN0IHJlc2V0TGl2ZW5lc3NUaW1lb3V0ID0gKCkgPT4ge1xuICAgICAgICBpZiAobGl2ZW5lc3NUaW1lb3V0ICE9PSBudWxsKVxuICAgICAgICAgICAgZ2xvYmFsVGhpcy5jbGVhclRpbWVvdXQobGl2ZW5lc3NUaW1lb3V0KTtcbiAgICAgICAgbGl2ZW5lc3NUaW1lb3V0ID0gZ2xvYmFsVGhpcy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGxpdmVuZXNzVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICBpZiAod29ya2VyRXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBUaGUgdW5yZXNwb25zaXZlbmVzcyBpcyBkdWUgdG8gYSBjcmFzaC4gTm8gbmVlZCB0byBwcmludCBtb3JlIHdhcm5pbmdzLlxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiU21vbGRvdCBhcHBlYXJzIHVucmVzcG9uc2l2ZVwiICtcbiAgICAgICAgICAgICAgICAod29ya2VyQ3VycmVudFRhc2submFtZSA/IChcIiB3aGlsZSBleGVjdXRpbmcgdGFzayBgXCIgKyB3b3JrZXJDdXJyZW50VGFzay5uYW1lICsgXCJgXCIpIDogXCJcIikgK1xuICAgICAgICAgICAgICAgIFwiLiBQbGVhc2Ugb3BlbiBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vcGFyaXR5dGVjaC9zbW9sZG90L2lzc3Vlcy4gSWYgeW91IGhhdmUgYSBcIiArXG4gICAgICAgICAgICAgICAgXCJkZWJ1Z2dlciBhdmFpbGFibGUsIHBsZWFzZSBwYXVzZSBleGVjdXRpb24sIGdlbmVyYXRlIGEgc3RhY2sgdHJhY2Ugb2YgdGhlIHRocmVhZCBcIiArXG4gICAgICAgICAgICAgICAgXCJ0aGF0IGlzbid0IHRoZSBtYWluIGV4ZWN1dGlvbiB0aHJlYWQsIGFuZCBwYXN0ZSBpdCBpbiB0aGUgaXNzdWUuIFBsZWFzZSBhbHNvIGluY2x1ZGUgXCIgK1xuICAgICAgICAgICAgICAgIFwiYW55IG90aGVyIGxvZyBmb3VuZCBpbiB0aGUgY29uc29sZSBvciBlbHNld2hlcmUuXCIpO1xuICAgICAgICB9LCAxMDAwMCk7XG4gICAgfTtcbiAgICBnbG9iYWxUaGlzLnNldFRpbWVvdXQoKCkgPT4gcmVzZXRMaXZlbmVzc1RpbWVvdXQoKSwgMTUwMDApO1xuICAgIC8vIFRoZSB3b3JrZXIgY2FuIHNlbmQgdXMgbWVzc2FnZXMgd2hvc2UgdHlwZSBpcyBpZGVudGlmaWVkIHRocm91Z2ggYSBga2luZGAgZmllbGQuXG4gICAgd29ya2VyT25NZXNzYWdlKHdvcmtlciwgKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgc3dpdGNoIChtZXNzYWdlLmtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgJ2pzb25ycGMnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2IgPSBjaGFpbnMuZ2V0KG1lc3NhZ2UuY2hhaW5JZCk/Lmpzb25ScGNDYWxsYmFjaztcbiAgICAgICAgICAgICAgICBpZiAoY2IpXG4gICAgICAgICAgICAgICAgICAgIGNiKG1lc3NhZ2UuZGF0YSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdjaGFpbkFkZGVkT2snOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWQgPSBwZW5kaW5nQ29uZmlybWF0aW9ucy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYWluSWQgPSBtZXNzYWdlLmNoYWluSWQ7XG4gICAgICAgICAgICAgICAgaWYgKGNoYWlucy5oYXMoY2hhaW5JZCkpIC8vIFNhbml0eSBjaGVjay5cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ1VuZXhwZWN0ZWQgcmV1c2Ugb2YgYSBjaGFpbiBJRCc7XG4gICAgICAgICAgICAgICAgY2hhaW5zLnNldChjaGFpbklkLCB7XG4gICAgICAgICAgICAgICAgICAgIGpzb25ScGNDYWxsYmFjazogZXhwZWN0ZWQuanNvblJwY0NhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgICBkYXRhYmFzZVByb21pc2VzOiBuZXcgQXJyYXkoKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIGBleHBlY3RlZGAgd2FzIHB1c2hlZCBieSB0aGUgYGFkZENoYWluYCBtZXRob2QuXG4gICAgICAgICAgICAgICAgLy8gUmVzb2x2ZSB0aGUgcHJvbWlzZSB0aGF0IGBhZGRDaGFpbmAgcmV0dXJuZWQgdG8gdGhlIHVzZXIuXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Q2hhaW4gPSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmRKc29uUnBjOiAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmtlckVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHdvcmtlckVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGFpbnMuaGFzKGNoYWluSWQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBBbHJlYWR5RGVzdHJveWVkRXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGNoYWlucy5nZXQoY2hhaW5JZCk/Lmpzb25ScGNDYWxsYmFjaykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25ScGNEaXNhYmxlZEVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5sZW5ndGggPj0gOCAqIDEwMjQgKiAxMDI0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHdvcmtlciwgeyB0eTogJ3JlcXVlc3QnLCByZXF1ZXN0LCBjaGFpbklkIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkYXRhYmFzZUNvbnRlbnQ6IChtYXhVdGY4Qnl0ZXNTaXplKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod29ya2VyRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHdvcmtlckVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFiYXNlQ29udGVudFByb21pc2VzID0gY2hhaW5zLmdldChjaGFpbklkKT8uZGF0YWJhc2VQcm9taXNlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGF0YWJhc2VDb250ZW50UHJvbWlzZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBBbHJlYWR5RGVzdHJveWVkRXJyb3IoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFiYXNlQ29udGVudFByb21pc2VzLnB1c2goeyByZXNvbHZlLCByZWplY3QgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHR3b1Bvd2VyMzIgPSAoMSA8PCAzMCkgKiA0OyAvLyBgMSA8PCAzMWAgYW5kIGAxIDw8IDMyYCBpbiBKYXZhU2NyaXB0IGRvbid0IGdpdmUgdGhlIHZhbHVlIHRoYXQgeW91IGV4cGVjdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1heFNpemUgPSBtYXhVdGY4Qnl0ZXNTaXplIHx8ICh0d29Qb3dlcjMyIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYXBwZWRNYXhTaXplID0gKG1heFNpemUgPj0gdHdvUG93ZXIzMikgPyAodHdvUG93ZXIzMiAtIDEpIDogbWF4U2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHdvcmtlciwgeyB0eTogJ2RhdGFiYXNlQ29udGVudCcsIGNoYWluSWQsIG1heFV0ZjhCeXRlc1NpemU6IGNhcHBlZE1heFNpemUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod29ya2VyRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgd29ya2VyRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCZWNhdXNlIHRoZSBgcmVtb3ZlQ2hhaW5gIG1lc3NhZ2UgaXMgYXN5bmNocm9ub3VzLCBpdCBpcyBwb3NzaWJsZSBmb3IgYSBKU09OLVJQQ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzcG9uc2Ugb3IgZGF0YWJhc2UgY29udGVudCBjb25jZXJuaW5nIHRoYXQgYGNoYWluSWRgIHRvIGFycml2ZSBhZnRlciB0aGUgYHJlbW92ZWBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZ1bmN0aW9uIGhhcyByZXR1cm5lZC4gV2Ugc29sdmUgdGhhdCBieSByZW1vdmluZyB0aGUgaW5mb3JtYXRpb24gaW1tZWRpYXRlbHkuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNoYWlucy5kZWxldGUoY2hhaW5JZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFscmVhZHlEZXN0cm95ZWRFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoY2hhaW5JZHMuaGFzKG5ld0NoYWluKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbklkcy5kZWxldGUobmV3Q2hhaW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2Uod29ya2VyLCB7IHR5OiAncmVtb3ZlQ2hhaW4nLCBjaGFpbklkIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY2hhaW5JZHMuc2V0KG5ld0NoYWluLCBjaGFpbklkKTtcbiAgICAgICAgICAgICAgICBleHBlY3RlZC5yZXNvbHZlKG5ld0NoYWluKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2NoYWluQWRkZWRFcnInOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWQgPSBwZW5kaW5nQ29uZmlybWF0aW9ucy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIC8vIGBleHBlY3RlZGAgd2FzIHB1c2hlZCBieSB0aGUgYGFkZENoYWluYCBtZXRob2QuXG4gICAgICAgICAgICAgICAgLy8gUmVqZWN0IHRoZSBwcm9taXNlIHRoYXQgYGFkZENoYWluYCByZXR1cm5lZCB0byB0aGUgdXNlci5cbiAgICAgICAgICAgICAgICBleHBlY3RlZC5yZWplY3QobmV3IEFkZENoYWluRXJyb3IobWVzc2FnZS5lcnJvcikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnZGF0YWJhc2VDb250ZW50Jzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gY2hhaW5zLmdldChtZXNzYWdlLmNoYWluSWQpPy5kYXRhYmFzZVByb21pc2VzO1xuICAgICAgICAgICAgICAgIGlmIChwcm9taXNlcylcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMuc2hpZnQoKS5yZXNvbHZlKG1lc3NhZ2UuZGF0YSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdsb2cnOiB7XG4gICAgICAgICAgICAgICAgbG9nQ2FsbGJhY2sobWVzc2FnZS5sZXZlbCwgbWVzc2FnZS50YXJnZXQsIG1lc3NhZ2UubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdsaXZlbmVzc1BpbmcnOiB7XG4gICAgICAgICAgICAgICAgcmVzZXRMaXZlbmVzc1RpbWVvdXQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2N1cnJlbnRUYXNrJzoge1xuICAgICAgICAgICAgICAgIHdvcmtlckN1cnJlbnRUYXNrLm5hbWUgPSBtZXNzYWdlLnRhc2tOYW1lO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIC8vIEV4aGF1c3RpdmUgY2hlY2suXG4gICAgICAgICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9leGhhdXN0aXZlQ2hlY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB3b3JrZXJPbkVycm9yKHdvcmtlciwgKGVycm9yKSA9PiB7XG4gICAgICAgIC8vIEEgd29ya2VyIGVycm9yIHNob3VsZCBvbmx5IGhhcHBlbiBpbiBjYXNlIG9mIGEgY3JpdGljYWwgZXJyb3IgYXMgdGhlIHJlc3VsdCBvZiBhIGJ1Z1xuICAgICAgICAvLyBzb21ld2hlcmUuIENvbnNlcXVlbnRseSwgbm90aGluZyBpcyByZWFsbHkgaW4gcGxhY2UgdG8gY2xlYW5seSByZXBvcnQgdGhlIGVycm9yLlxuICAgICAgICBjb25zdCBlcnJvclRvU3RyaW5nID0gZXJyb3IudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlNtb2xkb3QgaGFzIHBhbmlja2VkXCIgK1xuICAgICAgICAgICAgKHdvcmtlckN1cnJlbnRUYXNrLm5hbWUgPyAoXCIgd2hpbGUgZXhlY3V0aW5nIHRhc2sgYFwiICsgd29ya2VyQ3VycmVudFRhc2submFtZSArIFwiYFwiKSA6IFwiXCIpICtcbiAgICAgICAgICAgIFwiLiBUaGlzIGlzIGEgYnVnIGluIHNtb2xkb3QuIFBsZWFzZSBvcGVuIGFuIGlzc3VlIGF0IFwiICtcbiAgICAgICAgICAgIFwiaHR0cHM6Ly9naXRodWIuY29tL3Bhcml0eXRlY2gvc21vbGRvdC9pc3N1ZXMgd2l0aCB0aGUgZm9sbG93aW5nIG1lc3NhZ2U6XFxuXCIgK1xuICAgICAgICAgICAgZXJyb3JUb1N0cmluZyk7XG4gICAgICAgIHdvcmtlckVycm9yID0gbmV3IENyYXNoRXJyb3IoZXJyb3JUb1N0cmluZyk7XG4gICAgICAgIC8vIFJlamVjdCBhbGwgcHJvbWlzZXMgcmV0dXJuZWQgYnkgYGFkZENoYWluYC5cbiAgICAgICAgZm9yICh2YXIgcGVuZGluZyBvZiBwZW5kaW5nQ29uZmlybWF0aW9ucykge1xuICAgICAgICAgICAgaWYgKHBlbmRpbmcudHkgPT0gJ2NoYWluQWRkZWQnKVxuICAgICAgICAgICAgICAgIHBlbmRpbmcucmVqZWN0KHdvcmtlckVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBwZW5kaW5nQ29uZmlybWF0aW9ucyA9IFtdO1xuICAgICAgICAvLyBSZWplY3QgYWxsIHByb21pc2VzIGZvciBkYXRhYmFzZSBjb250ZW50cy5cbiAgICAgICAgZm9yIChjb25zdCBjaGFpbiBvZiBjaGFpbnMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvbWlzZSBvZiBjaGFpblsxXS5kYXRhYmFzZVByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5yZWplY3Qod29ya2VyRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNoYWlucy5jbGVhcigpO1xuICAgIH0pO1xuICAgIC8vIFRoZSBmaXJzdCBtZXNzYWdlIGV4cGVjdGVkIGJ5IHRoZSB3b3JrZXIgY29udGFpbnMgdGhlIGNvbmZpZ3VyYXRpb24uXG4gICAgcG9zdE1lc3NhZ2Uod29ya2VyLCB7XG4gICAgICAgIC8vIE1heGltdW0gbGV2ZWwgb2YgbG9nIGVudHJpZXMgc2VudCBieSB0aGUgY2xpZW50LlxuICAgICAgICAvLyAwID0gTG9nZ2luZyBkaXNhYmxlZCwgMSA9IEVycm9yLCAyID0gV2FybiwgMyA9IEluZm8sIDQgPSBEZWJ1ZywgNSA9IFRyYWNlXG4gICAgICAgIG1heExvZ0xldmVsOiBvcHRpb25zLm1heExvZ0xldmVsIHx8IDMsXG4gICAgICAgIGVuYWJsZUN1cnJlbnRUYXNrOiB0cnVlLFxuICAgICAgICBjcHVSYXRlTGltaXQ6IG9wdGlvbnMuY3B1UmF0ZUxpbWl0IHx8IDEuMCxcbiAgICAgICAgZm9yYmlkVGNwOiBvcHRpb25zLmZvcmJpZFRjcCB8fCBmYWxzZSxcbiAgICAgICAgZm9yYmlkV3M6IG9wdGlvbnMuZm9yYmlkV3MgfHwgZmFsc2UsXG4gICAgICAgIGZvcmJpZE5vbkxvY2FsV3M6IG9wdGlvbnMuZm9yYmlkTm9uTG9jYWxXcyB8fCBmYWxzZSxcbiAgICAgICAgZm9yYmlkV3NzOiBvcHRpb25zLmZvcmJpZFdzcyB8fCBmYWxzZSxcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRDaGFpbjogKG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIGlmICh3b3JrZXJFcnJvcilcbiAgICAgICAgICAgICAgICB0aHJvdyB3b3JrZXJFcnJvcjtcbiAgICAgICAgICAgIC8vIFBhc3NpbmcgYSBKU09OIG9iamVjdCBmb3IgdGhlIGNoYWluIHNwZWMgaXMgYW4gZWFzeSBtaXN0YWtlLCBzbyB3ZSBwcm92aWRlIGEgbW9yZVxuICAgICAgICAgICAgLy8gcmVhZGFibGUgZXJyb3IuXG4gICAgICAgICAgICBpZiAoISh0eXBlb2Ygb3B0aW9ucy5jaGFpblNwZWMgPT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaGFpbiBzcGVjaWZpY2F0aW9uIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgICAgICAgICBsZXQgcG90ZW50aWFsUmVsYXlDaGFpbnNJZHMgPSBbXTtcbiAgICAgICAgICAgIGlmICghIW9wdGlvbnMucG90ZW50aWFsUmVsYXlDaGFpbnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNoYWluIG9mIG9wdGlvbnMucG90ZW50aWFsUmVsYXlDaGFpbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGNvbnRlbnQgb2YgYG9wdGlvbnMucG90ZW50aWFsUmVsYXlDaGFpbnNgIGFyZSBzdXBwb3NlZCB0byBiZSBjaGFpbnMgZWFybGllclxuICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5lZCBieSBgYWRkQ2hhaW5gLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZCA9IGNoYWluSWRzLmdldChjaGFpbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZCA9PT0gdW5kZWZpbmVkKSAvLyBJdCBpcyBwb3NzaWJsZSBmb3IgYGlkYCB0byBiZSBtaXNzaW5nIGlmIGl0IGhhcyBlYXJsaWVyIGJlZW4gcmVtb3ZlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxSZWxheUNoYWluc0lkcy5wdXNoKGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBCdWlsZCBhIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIG9yIHJlamVjdGVkIGFmdGVyIHRoZSBjaGFpbiBoYXMgYmVlbiBhZGRlZC5cbiAgICAgICAgICAgIC8vIFRPRE86IGJlY2F1c2Ugb2YgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8xMTQ5OCB3ZSBuZWVkIHRvIGRlZmluZSB0aGUgY2FsbGJhY2tzIGFzIHBvc3NpYmx5IG51bGwsIGFuZCBnbyB0aHJvdWdoIGB1bmtub3duYFxuICAgICAgICAgICAgbGV0IGNoYWluQWRkZWRQcm9taXNlUmVzb2x2ZTtcbiAgICAgICAgICAgIGxldCBjaGFpbkFkZGVkUHJvbWlzZVJlamVjdDtcbiAgICAgICAgICAgIGNvbnN0IGNoYWluQWRkZWRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNoYWluQWRkZWRQcm9taXNlUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgY2hhaW5BZGRlZFByb21pc2VSZWplY3QgPSByZWplY3Q7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBlbmRpbmdDb25maXJtYXRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5OiAnY2hhaW5BZGRlZCcsXG4gICAgICAgICAgICAgICAgcmVqZWN0OiBjaGFpbkFkZGVkUHJvbWlzZVJlamVjdCxcbiAgICAgICAgICAgICAgICByZXNvbHZlOiBjaGFpbkFkZGVkUHJvbWlzZVJlc29sdmUsXG4gICAgICAgICAgICAgICAganNvblJwY0NhbGxiYWNrOiBvcHRpb25zLmpzb25ScGNDYWxsYmFjayxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcG9zdE1lc3NhZ2Uod29ya2VyLCB7XG4gICAgICAgICAgICAgICAgdHk6ICdhZGRDaGFpbicsXG4gICAgICAgICAgICAgICAgY2hhaW5TcGVjOiBvcHRpb25zLmNoYWluU3BlYyxcbiAgICAgICAgICAgICAgICBkYXRhYmFzZUNvbnRlbnQ6IHR5cGVvZiBvcHRpb25zLmRhdGFiYXNlQ29udGVudCA9PT0gJ3N0cmluZycgPyBvcHRpb25zLmRhdGFiYXNlQ29udGVudCA6IFwiXCIsXG4gICAgICAgICAgICAgICAgcG90ZW50aWFsUmVsYXlDaGFpbnM6IHBvdGVudGlhbFJlbGF5Q2hhaW5zSWRzLFxuICAgICAgICAgICAgICAgIGpzb25ScGNSdW5uaW5nOiAhIW9wdGlvbnMuanNvblJwY0NhbGxiYWNrLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY2hhaW5BZGRlZFByb21pc2U7XG4gICAgICAgIH0sXG4gICAgICAgIHRlcm1pbmF0ZTogKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHdvcmtlckVycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh3b3JrZXJFcnJvcik7XG4gICAgICAgICAgICB3b3JrZXJFcnJvciA9IG5ldyBBbHJlYWR5RGVzdHJveWVkRXJyb3IoKTtcbiAgICAgICAgICAgIGlmIChsaXZlbmVzc1RpbWVvdXQgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgZ2xvYmFsVGhpcy5jbGVhclRpbWVvdXQobGl2ZW5lc3NUaW1lb3V0KTtcbiAgICAgICAgICAgIHJldHVybiB3b3JrZXJUZXJtaW5hdGUod29ya2VyKTtcbiAgICAgICAgfVxuICAgIH07XG59XG4vLyBTZXBhcmF0ZSBmdW5jdGlvbiBpbiBvcmRlciB0byBlbmZvcmNlIHR5cGVzLlxuZnVuY3Rpb24gcG9zdE1lc3NhZ2Uod29ya2VyLCBtZXNzYWdlKSB7XG4gICAgd29ya2VyLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xufVxuIiwiLy8gU21vbGRvdFxuLy8gQ29weXJpZ2h0IChDKSAyMDE5LTIwMjIgIFBhcml0eSBUZWNobm9sb2dpZXMgKFVLKSBMdGQuXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogR1BMLTMuMC1vci1sYXRlciBXSVRIIENsYXNzcGF0aC1leGNlcHRpb24tMi4wXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4vLyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbi8vIE92ZXJyaWRlcyBgaW5kZXguanNgIHdoZW4gaW4gYSBicm93c2VyLlxuZXhwb3J0IGZ1bmN0aW9uIHdvcmtlck9uTWVzc2FnZSh3b3JrZXIsIGNhbGxiYWNrKSB7XG4gICAgd29ya2VyLm9ubWVzc2FnZSA9IChldmVudCkgPT4gY2FsbGJhY2soZXZlbnQuZGF0YSk7XG59XG5leHBvcnQgZnVuY3Rpb24gd29ya2VyT25FcnJvcih3b3JrZXIsIGNhbGxiYWNrKSB7XG4gICAgd29ya2VyLm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgLy8gRm9yIHJlZmVyZW5jZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sI2V2ZW50LWVycm9yXG4gICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3dlYmFwcGFwaXMuaHRtbCNlcnJvcmV2ZW50XG4gICAgICAgIC8vIElmIGBldmVudC5lcnJvcmAgZXhpc3RzLCB0aGVuIGl0IHdpbGwgbGlrZWx5IGJlIGFuIGluc3RhbmNlIG9mIGBFcnJvcmAuXG4gICAgICAgIC8vIEhvd2V2ZXIsIHRoYXQncyBub3QgZ3VhcmFudGVlZCBieSB0aGUgc3BlYyBhbmQgaXQgY291bGQgYWxzbyBiZVxuICAgICAgICAvLyBzb21ldGhpbmcgZWxzZS4gU28sIG91ciBzZWNvbmQgYmVzdCB0cnkgaXMgdGhlIGBldmVudC5tZXNzYWdlYFxuICAgICAgICAvLyBwcm9wZXJ0eS4gRmluYWxseSwgb3VyIGxhc3QgcmVzb3J0IGlzIHRvIGNyZWF0ZSBhbiBFcnJvciBmcm9tIHRoZSBldmVudC5cbiAgICAgICAgaWYgKGV2ZW50LmVycm9yIGluc3RhbmNlb2YgRXJyb3IpXG4gICAgICAgICAgICBjYWxsYmFjayhldmVudC5lcnJvcik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihldmVudC5tZXNzYWdlIHx8IGV2ZW50KSk7XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3b3JrZXJUZXJtaW5hdGUod29ya2VyKSB7XG4gICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwb3N0TWVzc2FnZShtc2cpIHtcbiAgICBzZWxmLnBvc3RNZXNzYWdlKG1zZyk7XG59XG5leHBvcnQgZnVuY3Rpb24gc2V0T25NZXNzYWdlKGNhbGxiYWNrKSB7XG4gICAgc2VsZi5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IGNhbGxiYWNrKGV2ZW50LmRhdGEpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBlcmZvcm1hbmNlTm93KCkge1xuICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1RjcEF2YWlsYWJsZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29ubmVjdGlvbihfb3B0cywgX2Nvbm5lY3Rpb25MaXN0ZW5lcikge1xuICAgIHRocm93IG5ldyBFcnJvcignVENQIGNvbm5lY3Rpb25zIG5vdCBhdmFpbGFibGUnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRSYW5kb21WYWx1ZXMoYnVmZmVyKSB7XG4gICAgY29uc3QgY3J5cHRvID0gZ2xvYmFsVGhpcy5jcnlwdG87XG4gICAgaWYgKCFjcnlwdG8pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmFuZG9tbmVzcyBub3QgYXZhaWxhYmxlJyk7XG4gICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhidWZmZXIpO1xufVxuIiwiLy8gU21vbGRvdFxuLy8gQ29weXJpZ2h0IChDKSAyMDE5LTIwMjIgIFBhcml0eSBUZWNobm9sb2dpZXMgKFVLKSBMdGQuXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogR1BMLTMuMC1vci1sYXRlciBXSVRIIENsYXNzcGF0aC1leGNlcHRpb24tMi4wXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4vLyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbmV4cG9ydCAqIGZyb20gJy4vY2xpZW50LmpzJzsgLy8gVE9ETzogcHJlY2lzZSBleHBvcnRzXG4iLCIvLyBTbW9sZG90XG4vLyBDb3B5cmlnaHQgKEMpIDIwMTktMjAyMiAgUGFyaXR5IFRlY2hub2xvZ2llcyAoVUspIEx0ZC5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBHUEwtMy4wLW9yLWxhdGVyIFdJVEggQ2xhc3NwYXRoLWV4Y2VwdGlvbi0yLjBcbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3Jcbi8vIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuICAgIGlmICghd2luZG93LldvcmtlcilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV29ya2VycyBub3QgYXZhaWxhYmxlXCIpO1xuICAgIC8vIFRoZSBsaW5lIG9mIGNvZGUgYmVsb3cgKGBuZXcgV29ya2VyKC4uLilgKSBpcyBkZXNpZ25lZCB0byBob3BlZnVsbHkgd29yayBhY3Jvc3MgYWxsXG4gICAgLy8gcGxhdGZvcm1zIGFuZCBidW5kbGVycy5cbiAgICAvLyBCZWNhdXNlIHRoaXMgbGluZSBpcyBwcmVjaXNlbHkgcmVjb2duaXplZCBieSBidW5kbGVycywgd2UgZXh0cmFjdCBpdCB0byBhIHNlcGFyYXRlXG4gICAgLy8gSmF2YVNjcmlwdCBmaWxlLlxuICAgIC8vIFNlZSBhbHNvIHRoZSBSRUFETUUubWQgZm9yIG1vcmUgY29udGV4dC5cbiAgICAvLyBOb3RlIHRoYXQsIGF0IHRoZSB0aW1lIG9mIHdyaXRpbmcsIEZpcmVmb3ggZG9lc24ndCBzdXBwb3J0IHRoZSBgdHlwZTogXCJtb2R1bGVcImAgb3B0aW9uLlxuICAgIC8vIEJlY2F1c2UgYnJvd3NlcnMgZG9uJ3QgZnVsbHkgc3VwcG9ydCBtb2R1bGVzIHlldCwgdGhpcyBjb2RlIGlzIGV4cGVjdGVkIHRvIGJlIHJ1biB0aHJvdWdoXG4gICAgLy8gYSBidW5kbGVyIChlLmcuIFdlYlBhY2spIGJlZm9yZSBiZWluZyBnaXZlbiB0byBhIGJyb3dzZXIsIHdoaWNoIHdpbGwgcmVtb3ZlIGFsbCB1c2FnZSBvZlxuICAgIC8vIG1vZHVsZXMgaW4gdGhlIHdvcmtlciBjb2RlLiBJdCBpcyB0aHVzIGFsc28gdGhlIHJvbGUgb2YgdGhpcyBidW5kbGVyIHRvIHR3ZWFrIG9yIHJlbW92ZVxuICAgIC8vIHRoZSB2YWx1ZSBvZiB0aGlzIGB0eXBlYCBwcm9wZXJ0eSB0byBpbmRpY2F0ZSB0byB0aGUgYnJvd3NlciB0aGF0IG1vZHVsZXMgYXJlbid0IGluIHVzZS5cbiAgICAvL1xuICAgIC8vIFdlYlBhY2sgaW4gcGFydGljdWxhciBkb2VzIHRoaXMsIGJ1dCBpdCBpcyB1bmNsZWFyIHdoZXRoZXIgKmFsbCogYnVuZGxlcnMgZG8gaXQuXG4gICAgLy8gV2hldGhlciBidW5kbGVycyBhY3R1YWxseSBkbyB0aGlzIG9yIG5vdCwgaXQgaXMgbm9uZXRoZWxlc3MgbW9yZSBjb3JyZWN0IHRvIGluZGljYXRlXG4gICAgLy8gYHR5cGU6IFwibW9kdWxlXCJgIGFuZCBkb2luZyBzbyBkb2Vzbid0IGhhdmUgYW55IGRyYXdiYWNrLlxuICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIobmV3IFVSTCgnLi93b3JrZXIuanMnLCBpbXBvcnQubWV0YS51cmwpLCB7IG5hbWU6IFwic21vbGRvdFwiLCB0eXBlOiBcIm1vZHVsZVwiIH0pO1xuICAgIHJldHVybiB3b3JrZXI7XG59XG4iLCIvLyBTbW9sZG90IGlzIGEgcGVlciBkZXBlbmRlbmN5OyB3ZSBvbmx5IHV0aWxpemUgaXRzIHR5cGVzLCBuZXZlciBpdHMgcnVudGltZS5cbmV4cG9ydCAqIGZyb20gXCJAc3Vic3RyYXRlL3Ntb2xkb3QtbGlnaHRcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNtb2xkb3QuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9